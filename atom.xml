<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>牧羊少年的个人博客</title>
  
  <subtitle>welcome</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.locusland.xyz/"/>
  <updated>2017-12-14T10:41:32.251Z</updated>
  <id>http://blog.locusland.xyz/</id>
  
  <author>
    <name>牧羊少年</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从源码角度实现一个自己的Promise</title>
    <link href="http://blog.locusland.xyz/2017/12/14/my-promise/"/>
    <id>http://blog.locusland.xyz/2017/12/14/my-promise/</id>
    <published>2017-12-14T03:12:18.000Z</published>
    <updated>2017-12-14T10:41:32.251Z</updated>
    
    <content type="html"><![CDATA[<p>关于Promise的概念以及意义就不在这里介绍了，最近看到了一些实现Promise的核心思想，在这里整理一下。写这篇文章并不是为了实现一个自己的Promise，毕竟现在es6已经标准支持，而且还有一大堆的第三方Promise库，主要是为了从最底层的角度深入理解一下Promise的实现思路。<br><a id="more"></a></p><h3 id="1-从状态机出发"><a href="#1-从状态机出发" class="headerlink" title="1.从状态机出发"></a>1.从状态机出发</h3><p>我们知道，Promise的作用在于包裹一个异步（或同步）操作，然后通过then方法实现这个操作成功（或失败）的回调，而这其中的原理则是可以通过一个类似状态机的机制来控制。首先需要明确几个概念，这些概念可以从Promise/A的API规范中找到：</p><ul><li><p>Promise（中文：承诺）其实为一个有限状态机，共有三种状态：pending（执行中）、fulfilled（执行成功）和rejected（执行失败）。</p></li><li><p>其中pending为初始状态，fulfilled和rejected为结束状态（结束状态表示promise的生命周期已结束）。</p></li><li><p>状态转换关系为：fulfill方法(pending-&gt;fulfilled)，reject(pending-&gt;rejected)，此状态转换不可逆。</p></li><li><p>随着状态的转换将触发各种事件（如执行成功事件、执行失败事件等）。 </p></li></ul><p>根据这些信息，我们就可以得出一个Promise的初始模型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//存储状态：PENDING, FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">let</span> state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储 FULFILLED 或者 REJECTED时传入的参数value</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储</span></span><br><span class="line">  <span class="keyword">let</span> handlers = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    state = FULFILLED;</span><br><span class="line">    value = result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    state = REJECTED;</span><br><span class="line">    value = error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-实现handle方法"><a href="#2-实现handle方法" class="headerlink" title="2.实现handle方法"></a>2.实现handle方法</h3><p>有了上面的初始模型，接下来需要一个resolve方法，我们知道new Promise（）的时候传入的参数是一个function，而这个function有两个参数resolve和reject，并且这两个参数都是一个function，就是说是一个带了两个function参数的function。而里面的resolve和reject方法决定了这个Promise的走向（fulfill方法还是reject），我们的handle方法就是决定这个走向用的，说起来有点绕，看一下handle大致做了什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//存储状态：PENDING, FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">let</span> state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储 FULFILLED 或者 REJECTED时传入的参数value</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储</span></span><br><span class="line">  <span class="keyword">let</span> defers = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    state = FULFILLED;</span><br><span class="line">    value = result;</span><br><span class="line">    handle(defers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    state = REJECTED;</span><br><span class="line">    value = error;</span><br><span class="line">    handle(defers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">      defers = handler;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">        <span class="comment">//do sth fulfilled</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (state === REJECTED) &#123;</span><br><span class="line">        <span class="comment">//do sth rejected</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fn(fulfill, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-实现then方法"><a href="#3-实现then方法" class="headerlink" title="3.实现then方法"></a>3.实现then方法</h3><p>then方法接受两个参数，分别是fulfill方法之后的回调onResolved以及reject之后的回调onRejected。同时因为Promise内的方法可能是同步页可能是异步，为了保证handle都能正常执行，我们需要一个defers变量，这样同步情况下，fulfill方法不会执行handle，而是到then的时候再执行handle，处于一个完全同步状态，而异步情况，在pending的时候将相应的handler存到defer中，直到fulfill的时候去进行处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//存储状态：PENDING, FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">let</span> state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储 FULFILLED 或者 REJECTED时传入的参数value</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储异步情况相应的handler</span></span><br><span class="line">  <span class="keyword">let</span> defers = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    state = FULFILLED;</span><br><span class="line">    value = result;</span><br><span class="line">    <span class="keyword">if</span> (defers) &#123;</span><br><span class="line">      handle(defers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    state = REJECTED;</span><br><span class="line">    value = error;</span><br><span class="line">    <span class="keyword">if</span> (defers) &#123;</span><br><span class="line">      handle(defers);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">      defers = handler;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">        handler.onFulfilled(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (state === REJECTED) &#123;</span><br><span class="line">        handler.onRejected(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    handle(&#123;</span><br><span class="line">      onFulfilled,</span><br><span class="line">      onRejected</span><br><span class="line">    &#125;);</span><br><span class="line">   &#125;;</span><br><span class="line">  fn(fulfill, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里基本的逻辑已经出来了，但实际上还有很多可以改进的地方。比如Promise不仅仅可以接收一个单独的值，同样可以接收一个Promise对象，而then的返回值也是一个Promise对象，也就是完全支持链式调用。下面从这两个角度出发，进行完善。</p><h3 id="支持Promise参数"><a href="#支持Promise参数" class="headerlink" title="支持Promise参数"></a>支持Promise参数</h3><p>resolve 既可以接受一个 Promise，也可以接受一个基本类型。当 resolve 一个 Promise 时，就成了酱紫：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">'aaa'</span>)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>我们上面的方法就无法达到效果，这时我们需要一个新的方法来进行改进，可以把这个方法就叫做resolve，而之前的fulfill方法我们仅仅当做是一个改变state状态的方法，也就是说简单来说，resolve其实就是改进了一下fulfill，那么最开始其实就是 这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  fulfill(result)</span><br><span class="line">&#125;</span><br><span class="line">fn(resolve, reject);</span><br></pre></td></tr></table></figure></p><p>嗯就这样，下面开始改进。因为resolve可能接收一个Promise对象，Promise一定有then方法，我们可以对这点进行一个判断，是否为Promise对象进行不同的处理，同时还需要一个doResolve方法进行对传入的Promise对象的递归处理（因为传入的Promise对象rosolve的可能还是个Promise对象，不一定嵌套了多少层- -）…这两个方法实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThen</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.then;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResolve</span> (<span class="params">fn, onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> done = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 执行由 resolve 传入的 resolve 回调</span></span><br><span class="line">      onFulfilled(value)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      onRejected(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">    done = <span class="literal">true</span></span><br><span class="line">    onRejected(ex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> then = getThen(result)</span><br><span class="line">    <span class="keyword">if</span> (then) &#123;</span><br><span class="line">      <span class="comment">// 递归 resolve 待解析的 Promise</span></span><br><span class="line">      doResolve(then.bind(result), resolve, reject)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fulfill(result)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getThen其实很简单，就是判断这个对象是否有then方法，如果有，我们当做Promise处理，通过doResolve来递归resolve方法，直到遇到的不是Promise对象为止，resolve出真正的值。而doResolve大致就是一个tryCallTwo的功能，让第一个fn参数以后两个参数为参数去执行,即做了最开始fn(resolve, reject)的工作，类似这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryCallTwo</span>(<span class="params">fn, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(a, b);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">return</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时doResolve需要确保 onFulfilled 与 onRejected 只会被调用一次，而我们的最后一行的fn(resolve, reject)需要替换成doResolve(fn, resolve, reject),至此为止，完整的实现为（getThen和doResolve做为两个辅助函数，为了更清晰，我们放在Promise外面）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThen</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.then;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResolve</span> (<span class="params">fn, onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> done = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 执行由 resolve 传入的 resolve 回调</span></span><br><span class="line">      onFulfilled(value)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      onRejected(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">    done = <span class="literal">true</span></span><br><span class="line">    onRejected(ex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//存储状态：PENDING, FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">let</span> state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储 FULFILLED 或者 REJECTED时传入的参数value</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储异步情况相应的handler</span></span><br><span class="line">  <span class="keyword">let</span> defers = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    state = FULFILLED;</span><br><span class="line">    value = result;</span><br><span class="line">    <span class="keyword">if</span> (defers) &#123;</span><br><span class="line">      handle(defers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    state = REJECTED;</span><br><span class="line">    value = error;</span><br><span class="line">    <span class="keyword">if</span> (defers) &#123;</span><br><span class="line">      handle(defers);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = getThen(result)</span><br><span class="line">      <span class="keyword">if</span> (then) &#123;</span><br><span class="line">        <span class="comment">// 递归 resolve 待解析的 Promise</span></span><br><span class="line">        doResolve(then.bind(result), resolve, reject)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      fulfill(result)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">      defers = handler;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">        handler.onFulfilled(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (state === REJECTED) &#123;</span><br><span class="line">        handler.onRejected(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    handle(&#123;</span><br><span class="line">      onFulfilled,</span><br><span class="line">      onRejected</span><br><span class="line">    &#125;);</span><br><span class="line">   &#125;;</span><br><span class="line">  doResolve(fn, resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="优化handle方法"><a href="#优化handle方法" class="headerlink" title="优化handle方法"></a>优化handle方法</h3><p>这里的handle方法有一点小问题，首先，handle传入参数handler，这个handler这里可以看出是then带过来的一个对象，其中包含了成功和拒绝两个状态的回调onFulfilled, onRejected，当然我们在then中完全可以不写参数（虽然这样没有了then的意义），比如这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'sth'</span>)</span><br><span class="line">&#125;).then();</span><br></pre></td></tr></table></figure></p><p>这种情况会因为handler.onFulfilled或者handler.onRejected不存在而导致报错，于是可以把handle方法稍微优化一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">    defers = handler;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> handlerCallback;</span><br><span class="line">    <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">      handlerCallback = handler.onFulfilled || <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handlerCallback = handler.onRejected || <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handlerCallback) &#123;</span><br><span class="line">      handlerCallback(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过一个handlerCallback存储回调。。。没有的时候，就什么也不做就可以了。</p><h3 id="实现链式调用"><a href="#实现链式调用" class="headerlink" title="实现链式调用"></a>实现链式调用</h3><p>我们都知道，then方法的回调可以return一个值，而then方法本身返回的是一个Promise，而这个Promise中resolve的结果就是这个return的值，所以可以实现完整的链式调用，对于这一点，我们只需要把上述的then方法稍微加工一下，让它返回一个Promise：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    handle(&#123;</span><br><span class="line">      onFulfilled,</span><br><span class="line">      onRejected,</span><br><span class="line">      resolve,</span><br><span class="line">      reject</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>then方法改了之后，handle方法也需要进行一些改进,因为此时handle的参数handler不仅仅有onFulfilled, onRejected这两个回调，还需要传入then返回的Promise的reslove和reject方法。而传给下一个then（链式）的值就是这个resolve所解析出来的value，所以在这个handle方法的最后，一定要resolve这个value。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">    defers = handler;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> handlerCallback = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">      handlerCallback = handler.onFulfilled;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handlerCallback = handler.onRejected;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handlerCallback) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">        handler.resolve(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler.reject(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ret = handlerCallback(value);</span><br><span class="line">    handler.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把优化后的再整理一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThen</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.then;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResolve</span> (<span class="params">fn, onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> done = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 执行由 resolve 传入的 resolve 回调</span></span><br><span class="line">      onFulfilled(value)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      onRejected(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">    done = <span class="literal">true</span></span><br><span class="line">    onRejected(ex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//存储状态：PENDING, FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">let</span> state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储 FULFILLED 或者 REJECTED时传入的参数value</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储异步情况相应的handler</span></span><br><span class="line">  <span class="keyword">let</span> defers = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    state = FULFILLED;</span><br><span class="line">    value = result;</span><br><span class="line">    <span class="keyword">if</span> (defers) &#123;</span><br><span class="line">      handle(defers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    state = REJECTED;</span><br><span class="line">    value = error;</span><br><span class="line">    <span class="keyword">if</span> (defers) &#123;</span><br><span class="line">      handle(defers);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = getThen(result)</span><br><span class="line">      <span class="keyword">if</span> (then) &#123;</span><br><span class="line">        <span class="comment">// 递归 resolve 待解析的 Promise</span></span><br><span class="line">        doResolve(then.bind(result), resolve, reject)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      fulfill(result)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">      defers = handler;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> handlerCallback = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">        handlerCallback = handler.onFulfilled;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handlerCallback = handler.onRejected;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!handlerCallback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">          handler.resolve(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          handler.reject(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> ret = handlerCallback(value);</span><br><span class="line">      handler.resolve(ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onFulfilled,</span><br><span class="line">        onRejected,</span><br><span class="line">        resolve,</span><br><span class="line">        reject</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125;;</span><br><span class="line">  doResolve(fn, resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此为止，基本上的功能已经完成了，当然，ES6标注的Promise还有Promise.all,Promise.race等方法，不过只要Promise的基本实现原理弄明白了，这些扩展起来也是很简单事情。<br>还有一点需要注意，Promise内部是纯异步实现的，即使是同步直接传入一个resolve值也会是异步完成，在ES6标准中的Promise是通过Job Queue来完成（可以参考以前的文章Micro-task），在这里我们可以通过setTimeout来简单模拟一下，虽然不完全相同（setTimeout属于Macro-task），但是可以大体上实现纯异步的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">    defers = handler;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> handlerCallback = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">        handlerCallback = handler.onFulfilled;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handlerCallback = handler.onRejected;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!handlerCallback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">          handler.resolve(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          handler.reject(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> ret = handlerCallback(value);</span><br><span class="line">      handler.resolve(ret);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯就酱~~~~参考链接：</p><p>-<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise MDN</a><br>-<a href="http://es6.ruanyifeng.com/?search=mixin&amp;x=0&amp;y=0#docs/promise" target="_blank" rel="noopener">阮一峰–ES6标准——Promise</a><br>-<a href="https://github.com/then/promise/blob/master/src/core.js" target="_blank" rel="noopener">implements Promise in a very similar way.</a><br>-<a href="https://www.promisejs.org/" target="_blank" rel="noopener">promisejs.org</a><br>-<a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">【翻译】Promises/A+规范</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Promise的概念以及意义就不在这里介绍了，最近看到了一些实现Promise的核心思想，在这里整理一下。写这篇文章并不是为了实现一个自己的Promise，毕竟现在es6已经标准支持，而且还有一大堆的第三方Promise库，主要是为了从最底层的角度深入理解一下Promise的实现思路。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="Promise" scheme="http://blog.locusland.xyz/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>task-and-job</title>
    <link href="http://blog.locusland.xyz/2017/11/15/task-and-job/"/>
    <id>http://blog.locusland.xyz/2017/11/15/task-and-job/</id>
    <published>2017-11-15T09:50:41.000Z</published>
    <updated>2017-11-15T07:33:21.569Z</updated>
    
    <content type="html"><![CDATA[<p>讲道理，从16年3月入前端的坑，到现在总觉得好歹也应该够了解js了，不过最近看到关于setTimeout (fn, 0)突然让我想到了刚学js的时候就一知半解的Event Loop，还有相关的Task queue,后来听说过的Macro task，Micro task(当然只是听说，啥也不懂)。今天把最近学到的一些东西整理一下，还是从一道题开始吧~<br><a id="more"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'global1'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'global2'</span>);</span><br></pre></td></tr></table></figure><p>对就是酱紫，而且这是一个简单版本，相信有很多小伙伴也看过这种，也知道结果。对于我来说，先前知道的可能也就是setTimeout (fn, 0)会把回调放到一个任务队列（task queue）里，ajax回调也是，Promise的resolve回调也是，dom事件监听（click等）同样，这些回调脱离了主线程，而在主线程空闲下来的时候去执行这些回调，但又不是完全结束之后，而是在适当的时机执行适当的回调。。。什么乱七八糟的啊~！@%#……￥&amp;就是说，如果ajax请求结果很慢是不是就要很后面执行？setTimeout和ajax，Promise都有什么顺序关系吗？为什么上面的Promise的then一定要timeout前面？<br>所以说，之前我只知道有一些callback会延迟执行，放到一个什么任务队列里，但具体是什么样的，时间循环怎么循环的，基本上是处于完全混乱状态。<br>今天在这里整理一下~<br>看了很多文章，基本的解释都一样，最通俗的解释就是，我们执行js代码需要一个函数调用栈（我这就叫执行栈吧），需要执行什么就push进去执行，执行过后再释放，所有的方法都是依赖于这个执行栈。而我们有两种任务类型宏任务macro-task，和微任务micio-task，它们都依赖于执行栈去执行。</p><ul><li>macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</li><li>micro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)。<br>而执行整体代码时，直接执行的直接放到执行栈中，遇到相应的task则放在其对应的task queue中。<br><em>一个事件循环从macro-task开始执行，当前执行栈没有可执行的东西时，开始执行micro-task的内容，然后开启下一个事件循环。而setTimeout被放入macro-task的队列，所以要等到下一个循环才能出来。</em>这就解释了为什么timeout在then后面。<br>我说的好像很乱，他<a href="http://www.jianshu.com/p/12b9f73c5a4f#" target="_blank" rel="noopener">这里</a>有图,可以参照这个去理解一下~<br>其实这篇文章已经写得很详细了，基本原理就是这样，还给了很长的例子来图解~~只是看完我突然想到，事件监听的回调，或者ajax的回调，放到这里会是什么样呢？理论上这些回调应该是属于macro-task（至于为什么一会再说），于是我在上面加了几句话：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'global1'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>)</span><br><span class="line">&#125;;</span><br><span class="line">btn.click();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'global2'</span>);</span><br></pre></td></tr></table></figure><p>不出所料，click在global1和global2之间输出的。也就是说，立即点击的按钮虽然放了回调，但是它的回调什么时候入栈执行取决于什么时候点击，就是点击的时机，如果点击就是在第一个event loop中，那就是在第一个event loop中执行。当然在实际中，我们点击某个按钮肯定不会在第一个event loop，这里的第一个指的就是整体script，我们在某个时机点击，点击的时候才将console.log(‘click’)放入相应的任务队列，而这个队列应该处于未来的某次循环中，而且这个应该属于event task，与setTimeout是不同的任务源，应该是不同的任务队列。从这里基本上就可以知道，其实将callback放入队列（macro-task或micro-task）的时机是不确定的，setTimeout设置5000的话应该就是5秒之后放入，对于点击则是具体click的时候，那么ajax应该就是返回请求完成的时候，取决于这次请求到底花了多久。</p><p>————————————————————————————————我是分隔线——————————————————————————————————————————<br>以上是我自己的理解，写得也比较乱，下面从规范的角度重新把这个问题捋一捋…</p><h3 id="关于event-loop"><a href="#关于event-loop" class="headerlink" title="关于event loop"></a>关于event loop</h3><p>以下几点可以从<a href="https://www.w3.org/TR/html5/webappapis.html#event-loop" target="_blank" rel="noopener">event loop</a>规范中整理出来</p><ol><li>event loop依赖于浏览器环境（这里不考虑node中的event loop以及worker中的event loop），1个浏览器环境至多有1个event loop，如果这个浏览器环境销毁，event loop也随之消失。</li><li>一个event loop可以有1个或多个任务队列（task queues）。</li><li>一个task queue是一列有序的task，用来做以下工作：Events task，Parsing task， Callbacks task， Using a resource task， Reacting to DOM manipulation task等。</li><li>每一个task都和相应的document相关联，一般这个documnet就是当前script所在的浏览器上下文的document。event loop用来处理相应document下的tasks。</li><li>每一个task都有相应的task source（任务源），从同一个task source来的task必须放到同一个task queue，从不同源来的则被添加到不同task queue。</li><li>每个(task source对应的)task queue都保证自己队列的先进先出的执行顺序，但event loop的每个turn，是由浏览器决定从哪个task source挑选task。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。</li></ol><h3 id="关于Job，Job-queues"><a href="#关于Job，Job-queues" class="headerlink" title="关于Job，Job queues"></a>关于Job，Job queues</h3><p>来看<a href="http://ecma-international.org/ecma-262/6.0/index.html#sec-jobs-and-job-queues" target="_blank" rel="noopener">ES20-15</a>规范中提到的Job和Job queues<br><img src="https://pic4.zhimg.com/5014ab6454bc214f76e3260fb68c3a1b_r.png" alt=""><br>一个Job Queue是一个先进先出的队列。一个ECMAScript实现必须至少包含以上两个Job Queue。<br>以下又强调了，单独的任务队列中的任务总是按先进先出的顺序执行，但是不保证多个任务队列中的任务优先级，具体实现可能会交叉执行。<br><img src="https://pic4.zhimg.com/50/0c6864c8a0e8a5f7f5abd8f9ddcddbe3_hd.jpg" alt=""><br>跟随PromiseJobs到25.4章节，可以看到<br><img src="https://pic4.zhimg.com/fed4b5f8710e3c3473e12a181394845f_b.png" alt=""><br>promise中reslove（fullfilled）的部分会把一个任务放到名为“PromiseJobs”的任务队列中，其实就是我们所说的micro-task。</p><p>综上从task和job两个规范可以得出，EcmaScript的Job queue与HTML的Task queue有异曲同工之妙。它们都可以有好几个，多个任务队列之间的顺序都是不保证的。但是，有一点可以确定，在当前的event loop的一次turn中，micro-task应该是在macro-task之后执行。<br>为什么呢？还是那个问题，为什么micro在macro后面，也就是为什么Promise的then在timeout后面？<br>这里有一个翻译的<a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">图灵社区 : 阅读 : 【翻译】Promises/A+规范</a>,在这篇文章中提到了所谓的macro-task和micro-task。有一个关键点就是script（整体代码）属于macro-task，我们从整体代码开始执行，在macro中遇到Promise产生了micro任务，遇到settimeout产出了新的macro任务，而settimeout产生的新的macro任务不会放到当前的循环中了，只能等到下一个循环的macro中去执行，而micro任务则可以在当前循环macro任务全部完成之后开始依次执行。<br>这里还有个问题，就是为什么settimeout不能放在当前的循环中呢。之前说的setTimeout (fn, 0)，之前说过不同task source（任务源）会放入不同的task queue（任务队列），所以setTimeout的回调会进入一个单独存放setTimeout的task queue（任务队列），而不可能放入当前整体代码的marco-task队列，即使我们将延迟时间设置为0，它定义的操作仍然需要等待所有代码执行完毕之后才开始执行。这里的延迟时间，并非相对于setTimeout执行这一刻，而是相对于其他代码执行完毕这一刻。所以说setTimeout方法不可能在当前循环的macro任务中执行。</p><p>好吧扯了一大堆，现在来把最开始那个题简单梳理一下~~~~<br>首先，全局代码（整体script）在macro-task中。</p><ol><li>从整体代码的macro-task开始执行，执行到global1，直接放到执行栈中执行，直接输出。</li><li>遇到setTimeOut，将此回调放到setTimeOut任务源的macro-task队列中，具体什么时候放取决于setTimeOut的第二个参数。</li><li>遇到了Promise，这里面的参数fn属于当前整体代码的macro-task，会立即执行，输出promise1。</li><li>for循环并不会导致进入其他任务队列，遇到resolve方法并执行。</li><li>继续执行输出promise2。</li><li>Promise的构造函数中resolve执行完毕的情况下，遇到then方法，从当前的macro-task创建了一个micro-task，并将这里resolve的回调（也就是then中的内容）打入这个micro-task队列。</li><li>继续执行，输出global2。</li><li>整体代码已经没有可执行的东西了，说明此次循环macro-task结束，开始执行micro-task队列，输出then1。</li><li>当前循环的micro-task也没东西了，开始下一次循环，只剩下setTimeOut的那个队列，输出timeout1。</li></ol><p>————————————————————————————————我也是分隔线——————————————————————————————————————————<br>刚刚的macro-task和micro-task都有提到node中关于定时器的一些东东比如setImmediate，process.nextTick等，setImmediate比较好说，可以初步理解为一个延迟为0的setTimeOut，当然是有一些区别不在这里详细介绍，输入macro-task。这里需要说明的一点是process.nextTick，按照归类它属于micro-task，那么看这个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">    res()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'nexttick'</span>))</span><br></pre></td></tr></table></figure><p>在node中执行结果process.nextTick()永远是优先于Promise的。这个似乎用上面的逻辑解释不通，nextTick中的可执行任务执行完毕之后，才会开始执行Promise队列中的任务。实际上在v8中，process.nextTick()严格来讲并不完全属于micro-task，看一下<a href="https://github.com/nodejs/node/blob/master/lib/internal/process/next_tick.js" target="_blank" rel="noopener">node的源码</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run callbacks that have no domain.</span></span><br><span class="line">  <span class="comment">// Using domains will cause this to be overridden.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_tickCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (tickInfo[kIndex] &lt; tickInfo[kLength]) &#123;</span><br><span class="line">        ++tickInfo[kIndex];</span><br><span class="line">        <span class="keyword">const</span> tock = nextTickQueue.shift();</span><br><span class="line">        <span class="keyword">const</span> callback = tock.callback;</span><br><span class="line">        <span class="keyword">const</span> args = tock.args;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CHECK(Number.isSafeInteger(tock[async_id_symbol]))</span></span><br><span class="line">        <span class="comment">// CHECK(tock[async_id_symbol] &gt; 0)</span></span><br><span class="line">        <span class="comment">// CHECK(Number.isSafeInteger(tock[trigger_async_id_symbol]))</span></span><br><span class="line">        <span class="comment">// CHECK(tock[trigger_async_id_symbol] &gt; 0)</span></span><br><span class="line"></span><br><span class="line">        emitBefore(tock[async_id_symbol], tock[trigger_async_id_symbol]);</span><br><span class="line">        <span class="comment">// emitDestroy() places the async_id_symbol into an asynchronous queue</span></span><br><span class="line">        <span class="comment">// that calls the destroy callback in the future. It's called before</span></span><br><span class="line">        <span class="comment">// calling tock.callback so destroy will be called even if the callback</span></span><br><span class="line">        <span class="comment">// throws an exception that is handles by 'uncaughtException' or a</span></span><br><span class="line">        <span class="comment">// domain.</span></span><br><span class="line">        <span class="comment">// TODO(trevnorris): This is a bit of a hack. It relies on the fact</span></span><br><span class="line">        <span class="comment">// that nextTick() doesn't allow the event loop to proceed, but if</span></span><br><span class="line">        <span class="comment">// any async hooks are enabled during the callback's execution then</span></span><br><span class="line">        <span class="comment">// this tock's after hook will be called, but not its destroy hook.</span></span><br><span class="line">        <span class="keyword">if</span> (async_hook_fields[kDestroy] &gt; <span class="number">0</span>)</span><br><span class="line">          emitDestroy(tock[async_id_symbol]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using separate callback execution functions allows direct</span></span><br><span class="line">        <span class="comment">// callback invocation with small numbers of arguments to avoid the</span></span><br><span class="line">        <span class="comment">// performance hit associated with using `fn.apply()`</span></span><br><span class="line">        _combinedTickCallback(args, callback);</span><br><span class="line"></span><br><span class="line">        emitAfter(tock[async_id_symbol]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kMaxCallbacksPerLoop &lt; tickInfo[kIndex])</span><br><span class="line">          tickDone();</span><br><span class="line">      &#125;</span><br><span class="line">      tickDone();</span><br><span class="line">      _runMicrotasks();</span><br><span class="line">      emitPendingUnhandledRejections();</span><br><span class="line">    &#125; <span class="keyword">while</span> (tickInfo[kLength] !== <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，_tickCallback 执行时不断取 nextTickQueue 中元素并执行。执行完以后，执行 _runMicrotasks() ，也就是执行 microtasks 。从这个角度来说，nextTick 和 microtask 是同一层级的。而_runMicrotasks() 调用 v8 的 RunMicrotasks，处理 v8 的 microtasks。而从实际效果来说，process.nextTick 被看作 microtask 没有问题。</p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/80x15.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲道理，从16年3月入前端的坑，到现在总觉得好歹也应该够了解js了，不过最近看到关于setTimeout (fn, 0)突然让我想到了刚学js的时候就一知半解的Event Loop，还有相关的Task queue,后来听说过的Macro task，Micro task(当然只是听说，啥也不懂)。今天把最近学到的一些东西整理一下，还是从一道题开始吧~&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="task" scheme="http://blog.locusland.xyz/tags/task/"/>
    
      <category term="event loop" scheme="http://blog.locusland.xyz/tags/event-loop/"/>
    
  </entry>
  
  <entry>
    <title>关于一道题想到的...</title>
    <link href="http://blog.locusland.xyz/2017/11/14/settimeout/"/>
    <id>http://blog.locusland.xyz/2017/11/14/settimeout/</id>
    <published>2017-11-14T07:51:06.000Z</published>
    <updated>2017-11-14T09:59:49.537Z</updated>
    
    <content type="html"><![CDATA[<p>最新偶然看到一个关于for + setTimeout (fn, 0)的问题，其实在面试中，我们也经常被问到关于这类问题，一般涉及到闭包，作用域和作用域链，然后关于setTimeout (fn, 0)的执行顺序，顺便可以带出一些异步执行，任务队列，时间循环的东西，关于这些自己在一年前找工作的时候了解了一些，但是也不是很透彻。当时看的是阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a>,只是大概知道有这么个东西，但具体来说还是…一脸萌比的状态<br><a id="more"></a><br>先来看看最开始说的那一道题吧，虽然和主要想写的东西没啥关系…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯就是这么一道题，相信稍微了解js的都能知道输出结果—&gt;在1秒之后连续输出5个5。而且原因简单来说就是setTimeout会延迟执行，等到里面执行的时候，i已经变成5了。嗯这么说倒是一点毛病没有，但是关于这个setTimeout往深了讲，能挖出来的东西就太多了。不过这里就先不挖了，这个时候我们还可能被问到如何修改一下变成输出0到4？？？<br>这个解决方法也是很多啦~~~不过大多数同学应该想到的就是利用<a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife" target="_blank" rel="noopener">IIFE</a>增加一个闭包来解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">   setTimeout( (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理也不用细说了吧，应该都知道，就是让里面的i就是里面的i，外面的i就是外面的i，如果真的不理解原理可以参考<a href="http://www.jianshu.com/p/9b4a54a98660" target="_blank" rel="noopener">这个</a>。<br>当然我之前不知道的是，除了这种传统的方法（或者类似的），还发现了很多‘野路子’，比如把上边那段代码去掉两行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">   setTimeout( (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(i);</span><br><span class="line">   &#125;)(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你对js理解很深，完全可以看懂这个套路。理论上setTimeout传入的第一个参数应该是个fn，这里传的是一个IIFE，然而这个函数并没有return值，所以最后的结果就是undefined，所以for里面的实际就是setTimeout(undefined, 1000），当然啦这个没有任何效果，不过里面的东西可是会立即执行的，当然这么写会立即输出而不是延迟1秒。<br>当然啦还有一些其他的方法咯，比如这这样,使用ES5的bind的方法<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind传送门</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">  setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;.bind(<span class="literal">null</span>,i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还可以这样，也许你不知道setTimeout方法可以传3个以上的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过现在有了ES6，其实只要改3个字母就可以咯：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面也说过，这个和主要想写的没啥关系，其实最近看了很多关于时间循环机制（event loop）的东西，打算在下一篇整理一下~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最新偶然看到一个关于for + setTimeout (fn, 0)的问题，其实在面试中，我们也经常被问到关于这类问题，一般涉及到闭包，作用域和作用域链，然后关于setTimeout (fn, 0)的执行顺序，顺便可以带出一些异步执行，任务队列，时间循环的东西，关于这些自己在一年前找工作的时候了解了一些，但是也不是很透彻。当时看的是阮一峰老师的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/10/event-loop.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 运行机制详解：再谈Event Loop&lt;/a&gt;,只是大概知道有这么个东西，但具体来说还是…一脸萌比的状态&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="闭包" scheme="http://blog.locusland.xyz/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="IIFE" scheme="http://blog.locusland.xyz/tags/IIFE/"/>
    
  </entry>
  
  <entry>
    <title>pwa-service-worker</title>
    <link href="http://blog.locusland.xyz/2017/09/19/pwa-service-worker/"/>
    <id>http://blog.locusland.xyz/2017/09/19/pwa-service-worker/</id>
    <published>2017-09-19T07:31:58.000Z</published>
    <updated>2017-11-09T08:06:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在2014年，W3C公布了service worker的草案，service worker提供了很多新的能力，使得web app拥有与native app相同的离线体验、消息推送体验。<br>Service Worker是PWA的核心。谷歌给以 Service Worker API 为核心实现的 web 应用取了个高大上的名字：Progressive Web Apps（PWA，渐进式增强 WEB 应用），并且在其主要产品上进行了深入的实践。<br><a id="more"></a></p><h3 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h3><p>Service Worker是Web Workers大家族中的一员，所以这里还是首先介绍一下Web Workers。<br>Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。此外，他们可以使用XMLHttpRequest执行 I/O  (尽管responseXML和通道属性总是为空)。一旦创建， 一个worker 可以将消息发送到创建它的JavaScript代码, 通过将消息发布到该代码指定的事件处理程序 (反之亦然)。<br>实际上是一种多线程的机制，worker与用户页面的JS是相互独立的两个线程，所以能够互不干扰，worker有自己的作用域（如专用Worker的作用域DedicatedWorkerGlobalScope），worker内可以使用大多数JavaScript特性，包括Navigator，XMLHttpRequest，Math，Date等等。需要注意的是，worker内的代码不能操作DOM，也无法影响页面外观，综合整理worker大致有如下特点：</p><ul><li>全局对象就是worker对象本身，就是说self和this都指向worker对象。</li><li>最小化的navigator对象，有online，appName，appVersion，userAgent和platFrom属性。</li><li>只读的location</li><li>WindowTimers.setTimeout 和 WindowTimers.setInterval</li><li>XMLHttpRequest</li><li>Array, Date, Math, String<br>在一个worker中最主要的你不能做的事情就是直接影响父页面。包括操作父页面的节点以及使用页面中的对象。比如通过PostMessage方法。<br>目前主要的web worker大致有以下几种：</li><li>Worker（专用worker）：正如名字一样，就是一个正常的worker，可以通过var myWorker = new Worker(‘worker.js’)穿件;</li><li>SharedWorker（共享worker）：一个共享worker可以被多个脚本使用——即使这些脚本正在被不同的window、iframe或者worker访问，生成共享worker可以通过var myWorker = new SharedWorker(‘worker.js’)创建;</li><li>ServiceWorker： 一般作为web应用程序、浏览器和网络（如果可用）之前的代理服务器。它们旨在（除开其他方面）创建有效的离线体验，拦截网络请求，以及根据网络是否可用采取合适的行动并更新驻留在服务器上的资源。他们还将允许访问推送通知和后台同步API。本文详细介绍。</li><li>Chrome Workers： 一种仅适用于firefox的worker。如果您正在开发附加组件，希望在扩展程序中使用worker且有在你的worker中访问  js-ctypes 的权限，你可以使用Chrome Workers。详情请参阅<a href="https://developer.mozilla.org/en-US/docs/Web/API/ChromeWorker" target="_blank" rel="noopener">ChromeWorker</a>。</li><li>Audio Workers（音频worker）：配合Web Audio API使用，使得在web worker上下文中直接完成脚本化音频处理成为可能。</li></ul><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>Service Worker做为Worker一种，具有上述提到的worker的所有特性，同时还提供的自己独有的一些功能。例如：在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。<br>基于 Service Worker API 的特性，结合 Fetch API、Cache API、Push API、postMessage API 和 Notification API，可以在基于浏览器的 web 应用中实现如离线缓存、消息推送、静默更新等 native 应用常见的功能，以给 web 应用提供更好更丰富的使用体验。</p><h4 id="Service-Worker兼容性"><a href="#Service-Worker兼容性" class="headerlink" title="Service Worker兼容性"></a>Service Worker兼容性</h4><p>参考<a href="http://caniuse.com/#feat=serviceworkers" target="_blank" rel="noopener">http://caniuse.com/#feat=serviceworkers</a><br><img src="https://raw.githubusercontent.com/geniuspeng/image-storage/master/blog/service-worker/sw-caniuse.png" alt="img"><br>当前，Edge已经竖起了小绿旗（默认不支持但可以手动开启），只剩下苹果的Safari还是一片红，虽然如此，不过最近似乎也开始在默默地搞起来了，支持sw只是时间的问题，至于IE嘛，不想多说。</p><h4 id="Service-Worker生命周期"><a href="#Service-Worker生命周期" class="headerlink" title="Service Worker生命周期"></a>Service Worker生命周期</h4><p>服务工作线程的生命周期完全独立于网页，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install -&gt; installed -&gt; actvating -&gt; Active -&gt; Activated -&gt; Redundant</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geniuspeng/image-storage/master/blog/service-worker/sw-lifecycle.png" alt="img"><br>要为网站安装服务工作线程，您需要先在页面的 JavaScript 中注册。 注册服务工作线程将会导致浏览器在后台启动服务工作线程安装步骤。</p><p>在安装过程中，您通常需要缓存某些静态资产。如果所有文件均已成功缓存，那么服务工作线程就安装完毕。如果任何文件下载失败或缓存失败，那么安装步骤将会失败，服务工作线程就无法激活（也就是说，不会安装）。 如果发生这种情况，不必担心，它下次会再试一次。 但这意味着，如果安装完成，您可以知道您已在缓存中获得那些静态资产。</p><p>安装之后，接下来就是激活步骤，这是管理旧缓存的绝佳机会，我们将在服务工作线程的更新部分对此详加介绍。</p><p>激活之后，服务工作线程将会对其作用域内的所有页面实施控制，不过，首次注册该服务工作线程的页面需要再次加载才会受其控制。服务工作线程实施控制后，它将处于以下两种状态之一：服务工作线程终止以节省内存，或处理获取和消息事件，从页面发出网络请求或消息后将会出现后一种状态。</p><h4 id="使用Service-Worker"><a href="#使用Service-Worker" class="headerlink" title="使用Service Worker"></a>使用Service Worker</h4><p>使用Service Worker有几个需要注意的地方，首先，要对一些前置的基础知识有一些了解，主要是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a>,以及前文提到的Fetch API，Cache API。<br>其次，由于一些不可描述的原因，Service Worker只能跑在HTTPS的服务器上，当然，Chrome等浏览器都对localhost跳过了安全认证，我们可以使用本地localhost进行调试。<br>这里主要介绍Service Worker的注册，以及相关事件的监听处理。</p><h5 id="注册Service-Worker"><a href="#注册Service-Worker" class="headerlink" title="注册Service Worker"></a>注册Service Worker</h5><p>Service Worker的注册不同于其他web workers，但是也很简单，只需要使用一个register方法即可，例如注册/sw/sw.js文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">navigator.serviceWorker</span><br><span class="line">         .register(<span class="string">'/sw/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/'</span>&#125;)</span><br><span class="line">         .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Service Worker Registered'</span>); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里有一个作用域的问题，如果你的sw.js写在/sw/路径下，不带第二个scope参数，Service worker只能监听/sw/路径下的fetch事件，而无法监听此目录外的fetch，使用scope可以改变这个作用域到根目录，对整个站点生效。另外Service Worker 没有页面作用域的概念，作用域范围内的所有页面请求都会被当前激活的 Service Worker 所监控。</p><h5 id="install事件"><a href="#install事件" class="headerlink" title="install事件"></a>install事件</h5><p>只有注册是在页面js内实现，而sw所有的事件处理都写在worker的js下。首先是install事件，当前脚本被安装时，会触发 install 事件，在这个事件里，通常会做一些缓存的添加处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cacheName = <span class="string">'my-cache'</span>;</span><br><span class="line"><span class="keyword">let</span> filesToCache = [</span><br><span class="line">  <span class="string">'/index.html'</span>,</span><br><span class="line">  <span class="string">'/js/test.js'</span>,</span><br><span class="line">  <span class="string">'/css/test.css'</span></span><br><span class="line">];</span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Install'</span>);</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(cacheName).then(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Caching app shell'</span>);</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(filesToCache);</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意这里的event参数，实际上是一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/InstallEvent" target="_blank" rel="noopener">InstallEvent</a>实例，它继承了父类<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ExtendableEvent" target="_blank" rel="noopener">ExtendableEvent</a>和Event的方法。<br>Event &lt;- ExtendableEvent &lt;- InstallEvent<br>而ExtendableEvent有一个独有的方法waitUnti(),这个方法接收一个Promise（或者async function），会阻塞当前事件的行为而优先执行该Promise，直到Promise结束，再继续进行当前事件。所以在install事件里一般在安装之前先把重要的app shell进行缓存，确切的说一般缓存的是用于离线展示的相关资源。需要注意的是，filesToCache全部缓存之后，才会执行install事件，也就是说如果waitUntil内的Promise没有成功，install事件将不会触发而导致Service worker安装失败而进入redundant (废弃)状态，所以这里应尽量减少filesToCache中的缓存资源。<br>安装成功后，即进入等待(waiting)或激活(active)状态。在激活状态可通过监听各种事件，实现更为复杂的逻辑需求。</p><h4 id="activate事件"><a href="#activate事件" class="headerlink" title="activate事件"></a>activate事件</h4><p>当安装完成后并进入激活状态，会触发 activate 事件。通过监听 activate 事件你可以做一些预处理，如对于旧版本的更新、对于无用缓存的清理等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Activate'</span>);</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keyList.map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== cacheName) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Removing old cache'</span>, key);</span><br><span class="line">          <span class="keyword">return</span> caches.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> self.clients.claim();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的event同样继承了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ExtendableEvent" target="_blank" rel="noopener">ExtendableEvent</a>，在这里对CacheStorage对象进行遍历，将过期的cache进行一个移除操作，及时清理CacheStorage的存储空间。<br>waitUntil阻塞activate事件，这可以确保清理操作会在第一次 fetch 事件之前完成。<br>在激活时执行clients.claim 方法，更新所有客户端上的 Service Worker。</p><h4 id="fetch事件"><a href="#fetch事件" class="headerlink" title="fetch事件"></a>fetch事件</h4><p>当浏览器发起请求时，会触发 fetch 事件。<br>Service Worker 安装成功并进入激活状态后即运行于浏览器后台，可以通过 fetch 事件可以拦截到当前作用域范围内的 http/https 请求，并且给出自己的响应。结合 Fetch API ，可以简单方便地处理请求响应，实现对网络请求的控制。这个功能十分强大，可以说是PWA的核心功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[Service Worker] Fetch'</span>, e.request.url);</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> response || fetch(e.request);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此处的参数是一个FetchEvent的实例，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent" target="_blank" rel="noopener">FetchEvent</a>继承了Event的属性和方法，同时拥有自己的方法respondWith。<br>FetchEvent 接口的 respondWith() 方法旨在包裹代码，这些代码为来自页面的request生成自定义的response。这些代码通过返回一个 Response 、 network error 或者 Fetch的方式resolve。</p><h4 id="push事件"><a href="#push事件" class="headerlink" title="push事件"></a>push事件</h4><p>push 事件是为推送准备的。不过首先你需要了解一下 Notification API 和 PUSH API。</p><p>通过 PUSH API，当订阅了推送服务后，可以使用推送方式唤醒 ServiceWorker 以响应来自系统消息传递服务的消息，即使用户已经关闭了页面。</p><p>推送的实现有两步：</p><p>不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging<gcm> 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通）。</gcm></p><h4 id="sync事件"><a href="#sync事件" class="headerlink" title="sync事件"></a>sync事件</h4><p>sync事件由background sync发出，是一种后台同步事件。background sync 是 Google 配合 SW 推出的 API，用于为 SW 提供一个可以实现注册和监听同步处理的方法。但它还不在 W3C WEB API 标准中。在 Chrome 中这也只是一个实验性功能，需要访问 chrome://flags/#enable-experimental-web-platform-features ，开启该功能，然后重启生效。<br>后台同步功能允许你一次性或按间隔请求后台数据同步，可以配合其他API实现一些很强大的功能如定时推送，定时更新等。用户无需打开页面，只要唤醒了Service Worker，就可以收到sync事件。<br>在页面注册sync事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register your service worker:</span></span><br><span class="line">navigator.serviceWorker.register(<span class="string">'/sw.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then later, request a one-off sync:</span></span><br><span class="line">navigator.serviceWorker.ready.then(<span class="function"><span class="keyword">function</span>(<span class="params">swRegistration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> swRegistration.sync.register(<span class="string">'myFirstSync'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在sw.js中监听sync事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'sync'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.tag == <span class="string">'myFirstSync'</span>) &#123;</span><br><span class="line">    event.waitUntil(doSomeStuff());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一个很酷的地方在于，sync事件可以在离线时发出，ServiceWorker会记住发出的事件，并且在重新联网时做出响应，这可以解决我们实际生活中很多不必要的“时间浪费”，比如我们提交某个表单，提交的时候可能网络不好等了好久，最后还没提交成功又要重新填写表单数据，有了sync时间我们完全不必考虑网络情况，让后台同步解决就可以了。</p><h4 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h4><p>前面说过，ServiceWorker同其他Worker一样，运行于一个独立的沙盒中，无法访问DOM等页面相关的信息，但我们可以通过 postMessage<br>API，实现Service Worker与页面之间的通信。</p><h5 id="页面向SW发消息"><a href="#页面向SW发消息" class="headerlink" title="页面向SW发消息"></a>页面向SW发消息</h5><p>首先在sw注册之后，才可以navigator.serviceWorker.controller句柄。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sendMessageToSW = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  navigator.serviceWorker.controller &amp;&amp; navigator.serviceWorker.controller.postMessage(msg);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">           .register(<span class="string">'/service-worker.js'</span>)</span><br><span class="line">           .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Service Worker Registered'</span>); &#125;)</span><br><span class="line">           .then(<span class="function"><span class="params">()</span> =&gt;</span> sendMessageToSW(<span class="string">'hello sw!'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在sw.js监听message事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>反过来 service worker 给主页面发消息就要复杂一点了。在 service worker 里发送信息需要通过 Client 对象的 postMessage 方法。获取 Client 的方法有很多，比如，刚从主页面发来的消息，事件的来源就是一个 Client 对象，即 event.source。不过，这只能向来源发消息，但如果你开了几个网页，或者不是通过主页消息发来的该怎么办哪？方法还是有的，在 service workers 中可以通过 clients 来获取所有的页面对象或其他的 service workers。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.clients.matchAll().then(<span class="function"><span class="keyword">function</span>(<span class="params">clientList</span>) </span>&#123;</span><br><span class="line">    clientList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">        client.postMessage(<span class="string">'Service worker attached.'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意这里的postMessage都不是window作用域下的，而是页面中的navigator.serviceWorker.controller下面的postMessage，同样Service Worker下拥有client的postMessage方法可以实现从Service Worker向页面发送消息。</p><h4 id="online-offline事件"><a href="#online-offline事件" class="headerlink" title="online/offline事件"></a>online/offline事件</h4><p>当网络状态发生变化时，会触发 online 或 offline 事件。结合这两个事件，可以与 Service Worker 结合实现更好的离线使用体验，例如当网络发生改变时，替换/隐藏需要在线状态才能使用的链接导航等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'离线了'</span>)</span><br><span class="line">  Notification.requestPermission().then(<span class="function">(<span class="params">grant</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grant !== <span class="string">'granted'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> notification = <span class="keyword">new</span> Notification(<span class="string">"网络挂掉了哦~"</span>, &#123;</span><br><span class="line">      body: <span class="string">'虽然离线了，但是我还可以访问'</span>,</span><br><span class="line">      icon: <span class="string">'http://si1.go2yd.com/get-image/0Gp8bLbHOkK'</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Service-Worker调试"><a href="#Service-Worker调试" class="headerlink" title="Service Worker调试"></a>Service Worker调试</h3><p>在 Chrome 中，service worker 的信息显示在 Application -&gt; Service Workers 中，就像这样</p><p>一些旧版本的Chrome可能把sw放在一个单独的地方，这时我们需要通过手动点击Service Worker后面的inspect来唤起调试窗口。<br>调试Service Worker可能是一项挑战，并且在涉及缓存的情况下，如果缓存未在您预期的时间进行更新，就可能变成一场更可怕的恶梦。典型Service Worker生命周期和代码错误的双重夹击可能很快令您感到失望。但请不要失望。您可以利用一些工具来改善自己的处境。</p><h3 id="Service-Worker更新"><a href="#Service-Worker更新" class="headerlink" title="Service Worker更新"></a>Service Worker更新</h3><p>如果 sw.js 文件的内容有改动，当访问网站页面时浏览器获取了新的文件，它会认为有更新，于是会安装新的文件并触发 install 事件。但是此时已经处于激活状态的旧的 Service Worker 还在运行，新的 Service Worker 完成安装后会进入 waiting 状态。直到所有已打开的页面都关闭，旧的 Service Worker 自动停止，新的 Service Worker 才会在接下来打开的页面里生效。<br>可以在 install 事件中执行 skipWaiting 方法跳过 waiting 状态，然后会直接进入 activate 阶段。接着在 activate 事件发生时，通过执行 clients.claim 方法，更新所有客户端上的 Service Worker。示例：</p><h3 id="一些参考链接"><a href="#一些参考链接" class="headerlink" title="一些参考链接"></a>一些参考链接</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener">MDN Cache</a></li><li><a href="https://zhuanlan.zhihu.com/p/27586862" target="_blank" rel="noopener">解锁缓存新姿势——更灵活的 Cache</a></li><li><a href="https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/?hl=zh-cn#_17" target="_blank" rel="noopener">your-first-pwapp</a></li><li><a href="https://github.com/camsong/blog/issues/2" target="_blank" rel="noopener">Fetch</a></li><li><a href="http://bubkoo.com/2015/05/08/introduction-to-fetch/" target="_blank" rel="noopener">fetch API 简介</a></li><li><a href="https://segmentfault.com/a/1190000010911535" target="_blank" rel="noopener">前端每周清单半年盘点之 PWA 篇</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在2014年，W3C公布了service worker的草案，service worker提供了很多新的能力，使得web app拥有与native app相同的离线体验、消息推送体验。&lt;br&gt;Service Worker是PWA的核心。谷歌给以 Service Worker API 为核心实现的 web 应用取了个高大上的名字：Progressive Web Apps（PWA，渐进式增强 WEB 应用），并且在其主要产品上进行了深入的实践。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.locusland.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="WebApp" scheme="http://blog.locusland.xyz/tags/WebApp/"/>
    
  </entry>
  
  <entry>
    <title>pwa-cache</title>
    <link href="http://blog.locusland.xyz/2017/09/19/pwa-cache/"/>
    <id>http://blog.locusland.xyz/2017/09/19/pwa-cache/</id>
    <published>2017-09-19T01:58:51.000Z</published>
    <updated>2017-09-19T03:23:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章介绍了Fetch API，这里主要介绍Service Worker API的另一个重要成员：Cache API。Cache 接口提供缓存的 Request / Response 对象对的存储机制，例如作为ServiceWorker 生命周期的一部分。 Cache 接口像 workers 一样, 是暴露在 window 作用域下的。尽管它被定义在 service worker 的标准中,  但是它不必一定要配合 service worker 使用。<br><a id="more"></a></p><h3 id="Cache-和-CacheStorage"><a href="#Cache-和-CacheStorage" class="headerlink" title="Cache 和 CacheStorage"></a>Cache 和 CacheStorage</h3><p>Cache 和 CacheStorage是两个不同的东西。Cache直接和请求打交道，CacheStorage和Cache对象打交道。通俗点来说，Cachestorage对象可以看作是当前域名下所有Cache对象的集合体，它提供了一系列接口去操作Cache对象，可以通过暴露在window中的caches属性来访问。例如，虽然API上显示的是CacheStorage.open()，但我们实际使用的时候，直接使用caches.open()。使用CacheStorage.open()打开一个Cache对象，就可以使用 Cache 对象的方法去处理缓存了。<br>你需要定期地清理缓存条目, 因为每个浏览器都严格限制了一个域下缓存数据的大小。 浏览器尽其所能去管理磁盘空间，浏览器有可能去删除一个域下的缓存数据，确保你的代码可以安全地操作缓存。</p><h3 id="了解CacheStorage"><a href="#了解CacheStorage" class="headerlink" title="了解CacheStorage"></a>了解CacheStorage</h3><p>刚刚提到过CacheStorage主要用来管理Cache对象，在 W3C 规范中，CacheStorage 对应到内核的 ServiceWorkerCacheStorage 对象。它提供了很多JS接口用于操作Cache 对象，这些接口均返回一个Promise对象：</p><ul><li>CacheStorage.open(cacheName) 用于获取一个 Cache 对象实例。传入一个cacheName，resolve结果是cacheName对应的Cache对象。</li><li>CacheStorage.match(request, options) 用于检查 CacheStorage 中是否存在以Request 为 key 的 Cache 对象。传入一个Request对象（或者url），resolve结果是对应Request所匹配的Response对象。</li><li>CacheStorage.has(cacheName) 用于检查是否存在指定名称的 Cache 对象。resolve结果是true或者false。</li><li>CacheStorage.keys() 用于返回 CacheStorage 中所有 Cache 对象的 cacheName 列表。resolve结果是对应的keyList。</li><li>CacheStorage.delete(cacheName) 用于删除指定 cacheName 的 Cache 对象。根据删除是否成功resolve对应的true或者false。</li></ul><p>一些注意事项：</p><ul><li>任意 CacheStorage 方法的调用，都有机会引起创建 ServiceWorkerCacheStorage 对象。</li><li>ServiceWorkerCacheStorageManager 维护一个 cache_storage<em>map</em>（std::map<gurl, serviceworkercachestorage*="">），这个 map 管理了所有的 origin + ServiceWorkerCacheStorage。</gurl,></li><li>任何一个域名只会创建一个 ServiceWorkerCacheStorage 对象,同一域名下的CacheStorage存储在一个目录。</li><li>ServiceWorkerCacheStorage 维护一个 cache<em>map</em>（std::map<std::string, base::weakptr<serviceworkercache=""> &gt;），这个 map 管理了同一 origin 下所有的 cacheName + ServiceWorkerCache。</std::string,></li></ul><p>前端从这些情况可以得到哪些信息呢？资源的存储不是按照资源的域名处理的，而是按照 Service Worker 的 origin 来处理，所以 Cache 的资源是无法跨域共享的，意思就是说，不同域的 Service Worker 无法共享使用对方的 Cache，即使是 Foreign Cache 请求的跨域资源，同样也是存放在这个 origin 之下。因为 ServiceWorkerCache 通过 cacheName 标记缓存版本，所以就会存在多个版本的 ServiceWorkerCache 资源。为什么需要 cacheName 来标记版本呢？</p><p>假设当前域名下所有的覆盖式发布的静态资源和接口数据全部存储在同一个 cacheName 里面，业务部署更新后，无法识别旧的冗余资源，单靠前端无法完全清除。这是因为 Service Worker 不知道完整的静态资源路径表，只能在客户端发起请求时去做判断，那些当前不会用到的资源不代表以后一定不会使用到。假如静态资源是非覆盖式发布，那么冗余的资源就更多了。这里要特别注意的是，Cache 不会过期，只能显式删除。</p><p>如果版本更新后，更换 cacheName，这意味着旧 cacheName 的资源是不会使用到了，业务逻辑可以放心的把旧 cacheName 对应的所有资源全部清除，而无需知道完整的静态资源路径表。</p><h3 id="了解Cache"><a href="#了解Cache" class="headerlink" title="了解Cache"></a>了解Cache</h3><p>一个域可以有多个 Cache 对象.  你将在你的代码中处理和更新缓存 (e.g. in a ServiceWorker) . 在 Cache 除非显示地更新缓存, 否则缓存将不会被更新; 缓存数据不会过期, 除非删除它. 使用 CacheStorage.open(cacheName) 打开一个Cache 对象, 再使用 Cache 对象的方法去处理缓存.<br>规范里 Cache 对应内核的 ServiceWorkerCache 对象，提供了已缓存的 Request / Response 对象体的存储管理机制。它提供了一系列管理存储的JS接口，除了add，addAll和put这三个用于添加cache的方法，其他接口接口同样统统返回一个Promise对象：</p><ul><li>Cache.match(request, options) 用于查找是否存在以 Request 为 key 的Cache 对象，resolve的结果是跟 Cache 对象匹配的第一个已经缓存的请求。</li><li>Cache.matchAll(request, options) 用于查找是否存在一组以 Request 为 key 的 Cache 对象组，resolve的结果是跟 Cache 对象匹配的所有请求组成的数组。</li><li>Cache.put(request, response)，同时抓取一个请求及其响应，并将其添加到给定的cache。</li><li>Cache.add(request)用于抓取这个URL, 检索并把返回的response对象添加到给定的Cache对象.这在功能上等同于调用 fetch(), 然后使用 Cache.put() 将response添加到cache中.</li><li>Cache.addAll(requests)，抓取一个URL数组，检索并把返回的response对象添加到给定的Cache对象。</li><li>Cache.delete(request, options)，搜索key值为request的Cache 条目。如果找到，则删除该Cache 条目，并且返回一个resolve为true的Promise对象；如果未找到，则返回一个resolve为false的Promise对象。</li><li>Cache.keys(request, options)，返回一个Promise对象，resolve的结果是Cache对象key值组成的数组。</li></ul><p>说到存储，那必然会涉及到存储的容量大小，Service Worker 规范并没有明确规定 ServiceWorkerCache 的容量限制，在 Chromium 50 以下版本的内核限制为 512M，Chromium 50 及以上版本内核不作限制（即为std::numeric_limits<int>::max）。当然，这只是 Service Worker 层面的限制，它还会受浏览器 QuotaManager 的限制。</int></p><p>一般来说，Service Worker 层面对 ServiceWorkerCache 的限制都会大于浏览器对每个域名的限制，所以，通常可理解为，ServiceWorkerCache 仅受浏览器 容量管理系统（QuotaManager） 对域名可使用存储的限制。对于前端开发同学来说，必须有清理冗余缓存的业务逻辑，并且提高缓存资源的使用率。</p><p>关于它与http cache的区别，HTTP Cache 中，一个 URL 只能对应一个 Response，但 Cache API 规范要求同一 URL（不同的 Header）可以对应多个 Response，另外，HTTP Cache 没有使用容量管理系统（QuotaManager）而 Cache API 需要使用。当 Service Worker 从 Cache 拿不到资源时，就会去 http cache 查找，找不到才去请求网络。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章介绍了Fetch API，这里主要介绍Service Worker API的另一个重要成员：Cache API。Cache 接口提供缓存的 Request / Response 对象对的存储机制，例如作为ServiceWorker 生命周期的一部分。 Cache 接口像 workers 一样, 是暴露在 window 作用域下的。尽管它被定义在 service worker 的标准中,  但是它不必一定要配合 service worker 使用。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.locusland.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="WebApp" scheme="http://blog.locusland.xyz/tags/WebApp/"/>
    
  </entry>
  
  <entry>
    <title>PWA：fetch API</title>
    <link href="http://blog.locusland.xyz/2017/09/14/pwa-fetch/"/>
    <id>http://blog.locusland.xyz/2017/09/14/pwa-fetch/</id>
    <published>2017-09-14T07:27:23.000Z</published>
    <updated>2017-09-19T01:59:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一次听PWA（Progressive Web App）这个词，还是在刚入职的时候。当时刚入坑前端几个月的我还是一脸萌币的状态，只是有一种不明觉厉的感觉。后来忙来忙去的也就扔在一边了，然后最近看到裕波大大的一篇文章：<a href="https://zhuanlan.zhihu.com/p/28293894" target="_blank" rel="noopener">震惊！苹果向开发者低头？！！开始支持Service Worker</a>,之前都是说这东西在国内发展不起来主要是因为国内的果粉太多，而苹果对ServiceWork一直处于冷漠的观望态度- -实际上，好像并没有那么冷漠233333…废话完毕，把最近学到的东西整理下：<br><a id="more"></a></p><h3 id="打算分三个方面吧："><a href="#打算分三个方面吧：" class="headerlink" title="打算分三个方面吧："></a>打算分三个方面吧：</h3><ol><li>Fetch API</li><li>Cache API</li><li>Service Worker</li></ol><h3 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h3><p>嗯这里主要讲fetch。其实说到底，fetch API和PWA关系并不是很大(但还是要了解这个东东)，而且Fetch API并不是为了PWA而生的，确切的说，我倒是觉得这货是为了取代Ajax的XMLHttpRequest而生的。先看一下fetch的基本用法（取自<a href="https://www.sitepoint.com/introduction-to-the-fetch-api/" target="_blank" rel="noopener">Introduction to the Fetch API</a>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* API URL, you need to supply your API key */</span></span><br><span class="line"><span class="keyword">var</span> URL = <span class="string">'https://api.flickr.com/services/rest/?method=flickr.photos.search&amp;api_key=your_api_key&amp;format=json&amp;nojsoncallback=1&amp;tags=penguins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fetch(URL).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    insertPhotos(json);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetchDemo();</span><br></pre></td></tr></table></figure><p>fetch可以接受两个参数，基本语法为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise&lt;Response&gt; fetch(input[, init]);</span><br></pre></td></tr></table></figure><p>第一个参数input可以是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/USVString" target="_blank" rel="noopener">USVString</a> 字符串，包含要获取资源的 URL，也可以是一个Request对象。第二个参数init是一个可选的配置对象，详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch" target="_blank" rel="noopener">这里</a>。<br>返回值是一个Promise对象，resolve结果为该请求对应的Response对象。</p><h3 id="Request-amp-amp-Response"><a href="#Request-amp-amp-Response" class="headerlink" title="Request &amp;&amp; Response"></a>Request &amp;&amp; Response</h3><p>Fetch引入了三个接口：Headers，Request和Response。<br>上面提到了Request对象和Response对象，这两个对象用来表示Fetch API的资源请求和响应。<br>你可以使用  Request.Request() 构造函数创建一个 Request 对象，Request对象也可能被其他API返回，比如一个 service worker FetchEvent.request。Request对象接受两个参数，这两个参数和Fetch接受的参数一模一样,其中headers可以通过Headers对象生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line">headers.append(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>);</span><br><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> Request(URL, &#123;</span><br><span class="line">method: <span class="string">'GET'</span>,</span><br><span class="line">header: headers, </span><br><span class="line">cache: <span class="string">'reload'</span></span><br><span class="line">&#125;);</span><br><span class="line">fetch(req).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  insertPhotos(json);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而且，我们可以从一个Request去生成另一个Request，下面的例子通过一个GET类型的Request，使用相同的配置新建了一个POST类型的Request。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postReq = <span class="keyword">new</span> Request(req, &#123;<span class="attr">method</span>: <span class="string">'POST'</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>同样的，我们可以使用Response的构造器建立一个Response对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myResponse = <span class="keyword">new</span> Response();</span><br></pre></td></tr></table></figure><p>Response对象的相关属性可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response" target="_blank" rel="noopener">MDN</a>。<br>尽管如此，我们实际上使用的Response对象大多都是其他API返回的，比如Fetch API，之前也说过，Fetch API返回的promise对象resolve的结果就是一个Response对象。</p><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Request和Response对象都实现了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body" target="_blank" rel="noopener">Body</a>对象的方法。<br>body可以是以下类型的实例：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView" target="_blank" rel="noopener">ArrayBufferView</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank" rel="noopener">File</a></li><li>String</li><li><a href="https://url.spec.whatwg.org/#interface-urlsearchparams" target="_blank" rel="noopener">URLSearchParams</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" target="_blank" rel="noopener">FormData</a></li></ul><p>Request和Response都为他们的body提供了以下方法，这些方法都返回一个Promise对象：</p><ul><li>arrayBuffer()</li><li>blob()</li><li>json()</li><li>text()</li><li>formData()</li></ul><h3 id="WHY-FETCH？"><a href="#WHY-FETCH？" class="headerlink" title="WHY FETCH？"></a>WHY FETCH？</h3><p>使用XHR发起一个请求一般是这样： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, url);</span><br><span class="line">xhr.responseType = <span class="string">'json'</span>;</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>而使用fetch：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>即使我们现在有jquery等类库对ajax进行了完美的封装，但xhr终归是一个设计较为粗糙的API，配置和调用起来并不是那么友好，而且基于事件的异步模型写起来也没有现代的Promise，而Request和Response对象遵循HTTP协议规范设计，而且基于Promise实现，配合现在的箭头函数，async/await可以更好地表现。在使用非文本方面，Body提供的相应方法使得Fetch API和XHR相比提供了极大的便利。<br>这里可能有人会有个疑问：Response就应该是请求来返回的，我们在浏览器端制造Response对象有什么意义？Service Workers API会告诉你答案。</p><h3 id="一些常见的坑"><a href="#一些常见的坑" class="headerlink" title="一些常见的坑"></a>一些常见的坑</h3><ol><li>首先，Fetch API发起的请求默认是不带cookie的，如果需要携带cookie请设置 fetch(url, {credentials: ‘include’})。</li><li>服务器返回 400，500 错误码时并不会 reject，仅仅是Response的ok字段变为false，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li><li>关于跨域，Fetch的第二个参数对象有一个 mode 属性，mode 属性用来决定是否允许跨域请求，以及哪些response属性可读。可选的mode属性值为 same-origin ， no-cors （默认）以及 cors 。</li></ol><ul><li>same-origin 模式很简单，如果一个请求是跨域的，那么返回一个简单的error，这样确保所有的请求遵守同源策略。</li><li>no-cors 模式允许来自CDN的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的method只能是”HEAD”,”GET”或者”POST”。此外，任何 ServiceWorkers 拦截了这些请求，它不能随意添加或者改写任何headers，除了<a href="https://fetch.spec.whatwg.org/#simple-header" target="_blank" rel="noopener">这些</a> 。JavaScript不能访问Response中的任何属性，这保证了 ServiceWorkers 不会导致任何跨域下的安全问题而隐私信息泄漏。</li><li>cors 模式我们通常用作跨域请求来从第三方提供的API获取数据。这个模式遵守 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">CORS协议</a> 。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次听PWA（Progressive Web App）这个词，还是在刚入职的时候。当时刚入坑前端几个月的我还是一脸萌币的状态，只是有一种不明觉厉的感觉。后来忙来忙去的也就扔在一边了，然后最近看到裕波大大的一篇文章：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28293894&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;震惊！苹果向开发者低头？！！开始支持Service Worker&lt;/a&gt;,之前都是说这东西在国内发展不起来主要是因为国内的果粉太多，而苹果对ServiceWork一直处于冷漠的观望态度- -实际上，好像并没有那么冷漠233333…废话完毕，把最近学到的东西整理下：&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.locusland.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="WebApp" scheme="http://blog.locusland.xyz/tags/WebApp/"/>
    
  </entry>
  
  <entry>
    <title>那些移动端web踩过的坑</title>
    <link href="http://blog.locusland.xyz/2017/08/24/mobile-issues/"/>
    <id>http://blog.locusland.xyz/2017/08/24/mobile-issues/</id>
    <published>2017-08-24T07:43:38.000Z</published>
    <updated>2017-08-24T11:07:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>扔了N久，还是捡回来了。好好弄一下吧。刚工作的时候挺忙的，后来不那么忙了，但是变懒了。<br>这一年大多数时间都在在做移动端的东东，做了之后才发现，同样是web前端，移动端的坑真的是深不可测，各种各样的，只有想不到，没有遇不到。在这里把最近踩过的坑整理一下。<br><a id="more"></a></p><h3 id="No-1-大字体问题"><a href="#No-1-大字体问题" class="headerlink" title="No.1 大字体问题"></a>No.1 大字体问题</h3><p>首先，要解决的关键问题是如何为设备选择可视视口尺寸，采用理想视口尺寸作为可视视口尺寸，代码也十分简单，只需要将缩放比定为 1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1,maximum-scale=1, minimum-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之所以把它放在第一个也是因为这个印象最深，记得第一次做移动端html5页面的时候，啥都不懂，还在用px作为像素单位，当然这个px是相对的（关于px可参考<a href="https://lscho.com/tech/css_company.html" target="_blank" rel="noopener">css 长度单位知多少</a>），然而在移动端使用px是相当不靠谱的，随随便便换一个大小不一样的设备，可能就会出现样式错乱。。。当然后来使用了rem，众所周知1rem=1 htmlFontSize,所以这里只要我们把html的字体大小事先定好，就可以基本上解决字体的适配问题。那么怎么选择这个htmlFontSize呢？<br>一般UI的设计稿都是3倍大小，这里已1080为例子（我拿到的一般都是1080的），实际上就是360px宽度的device，比如我自己习惯上想让1rem=100px(这里的px是实际像素，相当于设计稿的300像素)，那么问题关键就在于，htmlFontSize的多少px正好对应设计稿的300px，那么根元素html的fontsize（设为fz）与设备实际宽度(设为dw)的对应关系应为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dw/1080 = fz/300</span><br><span class="line">fz = dw/3.6</span><br></pre></td></tr></table></figure><p>这样，你的设备宽度用rem表示其实就是3.6rem，即使不是360px，也可以按比例来缩放，而设计稿中的每300px对应为1rem，使用rem布局，字体大小就可以随着设备宽度来自己调整。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRootFontSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="keyword">var</span> dw = r.getBoundingClientRect().width;</span><br><span class="line">  <span class="keyword">var</span> fz = ~~( dw &lt;= <span class="number">720</span> ? dw : <span class="number">720</span> ) / <span class="number">3.6</span>;</span><br><span class="line">  r.style.fontSize = fz + <span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setRootFontSize);</span><br><span class="line">setRootFontSize();</span><br></pre></td></tr></table></figure><p>这段代码基本上可以满足字体在移动端的自适应要求，可是如果用户主动把设备字体调大，也就是1px对应的大小变大，字体虽然px数不变，显示还是会变大，而有些比较复杂的h5页面字体稍微有些变化就会有问题，所以有时候还需要限定页面的字体大小不随设备字体的调整而影响，这时需要用到getComputedStyle这个方法，getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值（可参考<a href="http://www.zhangxinxu.com/wordpress/2012/05/getcomputedstyle-js-getpropertyvalue-currentstyle/" target="_blank" rel="noopener">获取元素CSS值之getComputedStyle方法熟悉</a>）。通过对比算出来的fz和实际的realfz，对其进行相应缩放即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRootFontSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="keyword">var</span> dw = r.getBoundingClientRect().width;</span><br><span class="line">  <span class="keyword">var</span> fz = ~~( dw &lt;= <span class="number">720</span> ? dw : <span class="number">720</span> ) / <span class="number">3.6</span>;</span><br><span class="line">  r.style.fontSize = fz + <span class="string">"px"</span>;</span><br><span class="line">  <span class="keyword">var</span> realfz = ~~(+<span class="built_in">window</span>.getComputedStyle(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"html"</span>)[<span class="number">0</span>]).fontSize.replace(<span class="string">'px'</span>,<span class="string">''</span>) * <span class="number">10000</span>) / <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">if</span>(fz !== realfz)&#123; r.style.fontSize = fz *(fz / realfz) + <span class="string">"px"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setRootFontSize);</span><br><span class="line">setRootFontSize();</span><br></pre></td></tr></table></figure><h3 id="No-2-滚动时最底层（或顶层）回弹问题"><a href="#No-2-滚动时最底层（或顶层）回弹问题" class="headerlink" title="No.2 滚动时最底层（或顶层）回弹问题"></a>No.2 滚动时最底层（或顶层）回弹问题</h3><p>这个坑应该做过移动端的都踩过（只是大多数情况根本不算坑，然而我要做的东西基本上都要禁掉这玩意），试过很多方法，都不是很理想，最终的解决方案就是禁用父级元素的滚动，手动模拟滚动条：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scroll = <span class="function"><span class="keyword">function</span>(<span class="params">container, childSelector, style</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!container || !container.length) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(container <span class="keyword">instanceof</span> $)) &#123;</span><br><span class="line">    container = $(container);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (container.css(<span class="string">'position'</span>) === <span class="string">'static'</span>) &#123;</span><br><span class="line">    container.css(<span class="string">'position'</span>, <span class="string">'relative'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> child = container.find(childSelector);</span><br><span class="line">  child.css(&#123;</span><br><span class="line">    <span class="string">'transform'</span>: <span class="string">'translate3d(0px, 0px, 0px)'</span>,</span><br><span class="line">    <span class="string">'-webkit-transform'</span>: <span class="string">'translate3d(0px, 0px, 0px)'</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> childTop = <span class="number">0</span>; <span class="comment">//距离容器顶部的距离 </span></span><br><span class="line">  <span class="keyword">var</span> conHeight = container.height(); <span class="comment">//容器高度</span></span><br><span class="line">  <span class="keyword">var</span> childHeight = child.height(); <span class="comment">//子容器高度</span></span><br><span class="line">  <span class="keyword">var</span> diffHeight = conHeight - childHeight; <span class="comment">//父子容器高度差</span></span><br><span class="line">  <span class="keyword">var</span> clientY = <span class="number">0</span>; <span class="comment">//手指在当前对象上触摸时的坐标</span></span><br><span class="line">  <span class="comment">//添加滚动条</span></span><br><span class="line">  <span class="keyword">var</span> defaultStyle = &#123;</span><br><span class="line">    width: <span class="string">'6px'</span>,</span><br><span class="line">    position: <span class="string">'absolute'</span>,</span><br><span class="line">    <span class="string">'border-radius'</span>: <span class="string">'10000px'</span>,</span><br><span class="line">    <span class="string">'background-color'</span>: <span class="string">'rgba(0, 0, 0, 0.3)'</span>,</span><br><span class="line">    <span class="string">'pointer-events'</span>: <span class="string">'none'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  $.extend(defaultStyle, style);</span><br><span class="line">  <span class="keyword">if</span> (!defaultStyle.height) &#123;</span><br><span class="line">    <span class="keyword">if</span> (diffHeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      defaultStyle.height = conHeight/childHeight * (conHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      defaultStyle.height = <span class="string">'0px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!defaultStyle.top &amp;&amp; !defaultStyle.right &amp;&amp; !defaultStyle.bottom &amp;&amp; !defaultStyle.left) &#123;</span><br><span class="line">    defaultStyle.top = <span class="number">0</span>;</span><br><span class="line">    defaultStyle.right = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> scrollBar = $(<span class="string">'&lt;section class="scroll-bar ui-scroll-bar"&gt;&lt;section&gt;'</span>);</span><br><span class="line">  scrollBar.css(defaultStyle);</span><br><span class="line">  container.find(<span class="string">'.scroll-bar'</span>).remove();</span><br><span class="line">  container.append(scrollBar);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定前先移除事件</span></span><br><span class="line">  container.off(<span class="string">'touchstart'</span>);</span><br><span class="line">  container.off(<span class="string">'touchmove'</span>);</span><br><span class="line">  container.on(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    childTop = child.position().top;</span><br><span class="line">    clientY = e.targetTouches[<span class="number">0</span>].clientY;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  container.on(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (diffHeight &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> curClientY = e.targetTouches[<span class="number">0</span>].clientY;</span><br><span class="line">    <span class="keyword">var</span> tempTop = childTop + (curClientY - clientY);</span><br><span class="line">    <span class="keyword">if</span> (tempTop &lt;= diffHeight) &#123;</span><br><span class="line">      tempTop = diffHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tempTop &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      tempTop = <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    child.css(&#123;</span><br><span class="line">      <span class="string">'transform'</span>: <span class="string">'translate3d(0px, '</span> + tempTop + <span class="string">'px, 0px)'</span>,</span><br><span class="line">      <span class="string">'-webkit-transform'</span>: <span class="string">'translate3d(0px, '</span> + tempTop + <span class="string">'px, 0px)'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    scrollBar.css(&#123;</span><br><span class="line">      <span class="string">'transform'</span>: <span class="string">'translate3d(0px, '</span> + (-tempTop* (conHeight/childHeight)) + <span class="string">'px, 0px)'</span>,</span><br><span class="line">      <span class="string">'-webkit-transform'</span>: <span class="string">'translate3d(0px, '</span> + (-tempTop* (conHeight/childHeight)) + <span class="string">'px, 0px)'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">scroll($(<span class="string">'.parent'</span>), <span class="string">'.child'</span>)</span><br></pre></td></tr></table></figure><p>原理其实还是很简单，先计算一下滚动条的高度，然后按照比例去设置transform（还有很多可优化扩展的地方），第一个参数是父元素的zepto（或jquery）选择器对象,第二个参数是需要滚动的子元素包裹层，第三个是滚动条的样式（可选，有默认），需要把parent元素设置为overflow：hidden，child元素的height设置为auto。</p><h3 id="No-3-Modal弹出层滚动带动底层一起滚动"><a href="#No-3-Modal弹出层滚动带动底层一起滚动" class="headerlink" title="No.3 Modal弹出层滚动带动底层一起滚动"></a>No.3 Modal弹出层滚动带动底层一起滚动</h3><p>这个也是只有移动端才有的坑，类似与一种穿透吧，手指在弹出层滑动的同时，如果底层有滚动条的话也会跟着一起滑动,解决方案:<br>css添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*禁止modal底层滚动*/</span></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.dialog-open</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SCROLL_TOP = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*禁止modal带动底部滚动*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">to</span>(<span class="params">scrollTop</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.scrollTop = <span class="built_in">document</span>.documentElement.scrollTop = scrollTop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollTop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*modal弹出时使用*/</span></span><br><span class="line">SCROLL_TOP = getScrollTop();</span><br><span class="line"><span class="built_in">document</span>.body.classList.add(<span class="string">'dialog-open'</span>); </span><br><span class="line"><span class="built_in">document</span>.body.style.top = -SCROLL_TOP + <span class="string">'px'</span>;</span><br><span class="line"><span class="comment">/*modal关闭时使用*/</span></span><br><span class="line">to(SCROLL_TOP);</span><br></pre></td></tr></table></figure><h3 id="No-4-tap事件穿透"><a href="#No-4-tap事件穿透" class="headerlink" title="No.4 tap事件穿透"></a>No.4 tap事件穿透</h3><p>这算是zepto的一个bug了，具体这个bug的源头还得追到zepto对于tap事件的模拟（参考<a href="https://segmentfault.com/a/1190000003848737" target="_blank" rel="noopener">也来说说touch事件与点击穿透问题</a>），我后来用的解决方法也是参考这里来的，就是使用pointer-events这个属性，这里就不多介绍了,这里的第三种方法，使用<a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">fastclick</a>库模拟click也可以完美解决移动端的点穿问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#closePopup'</span>).on(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    $(<span class="string">'#popupLayer'</span>).hide();</span><br><span class="line">    $(<span class="string">'#bgMask'</span>).hide();</span><br><span class="line"></span><br><span class="line">    $(<span class="string">'#underLayer'</span>).css(<span class="string">'pointer-events'</span>, <span class="string">'none'</span>);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">'#underLayer'</span>).css(<span class="string">'pointer-events'</span>, <span class="string">'auto'</span>);</span><br><span class="line">    &#125;, <span class="number">400</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="http://www.zhangxinxu.com/wordpress/2012/05/getcomputedstyle-js-getpropertyvalue-currentstyle/" target="_blank" rel="noopener">获取元素CSS值之getComputedStyle方法熟悉</a></li><li><a href="https://lscho.com/tech/css_company.html" target="_blank" rel="noopener">css 长度单位知多少</a></li><li><a href="https://zhuanlan.zhihu.com/p/25216275" target="_blank" rel="noopener">网易和淘宝移动WEB适配方案再分析</a></li><li><a href="https://segmentfault.com/a/1190000003848737" target="_blank" rel="noopener">也来说说touch事件与点击穿透问题</a></li><li><a href="https://github.com/hijiangtao/hijiangtao.github.io/blob/master/_posts/2017-07-08-Device-Viewport-and-Pixel-Introduction.md" target="_blank" rel="noopener">前端涉及的各种像素概念以及 viewport 汇总</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;扔了N久，还是捡回来了。好好弄一下吧。刚工作的时候挺忙的，后来不那么忙了，但是变懒了。&lt;br&gt;这一年大多数时间都在在做移动端的东东，做了之后才发现，同样是web前端，移动端的坑真的是深不可测，各种各样的，只有想不到，没有遇不到。在这里把最近踩过的坑整理一下。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="mobile" scheme="http://blog.locusland.xyz/tags/mobile/"/>
    
  </entry>
  
  <entry>
    <title>一个目前的to-do-list</title>
    <link href="http://blog.locusland.xyz/2015/11/10/todolist/"/>
    <id>http://blog.locusland.xyz/2015/11/10/todolist/</id>
    <published>2015-11-10T13:42:28.000Z</published>
    <updated>2017-08-23T06:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>自十一假期回来就进入了疯狂的笔试面试阶段，到11月初终于工作尘埃落定。前一阵子也是写了个传说中的励志的故事<a href="http://mp.weixin.qq.com/s?__biz=MzI5MjA5MDQzNA==&amp;mid=400211500&amp;idx=1&amp;sn=881f3ce8213571ac223db7c250cd35b9#rd" target="_blank" rel="noopener">链接戳我</a>，从3月接触前端走到现在真的是不容易，好在没有放弃。不过这段时间一直忙着找工作的事情也是好久没有去搞一搞自己喜欢的东西了，确实前端这里还有好多东西要学，于是先来搞一个TODOlist：<br><a id="more"></a></p><ul><li><a href="http://www.phperz.com/article/15/0523/129259.html" target="_blank" rel="noopener">reactJS</a></li><li><a href="http://docs.reactjs-china.com/react/docs/why-react-zh-CN.html" target="_blank" rel="noopener">为什么使用react</a></li><li><a href="https://www.codecademy.com/en/learn/learn-angularjs?utm_campaign=2015-06-10-learn-angularjs-announce&amp;utm_source=email" target="_blank" rel="noopener">angularJS</a></li><li><a href="http://amazeui.org/getting-started?utm_source=baidu&amp;utm_medium=cpc&amp;utm_campaign=Download" target="_blank" rel="noopener">amazeUI</a></li><li><a href="http://coffee-script.org/" target="_blank" rel="noopener">coffee script</a></li><li><a href="http://www.1024i.com/demo/less/" target="_blank" rel="noopener">less</a></li><li><a href="http://www.w3cplus.com/sassguide/" target="_blank" rel="noopener">sass</a></li><li><a href="http://www.zhangxinxu.com/jq/stylus/" target="_blank" rel="noopener">stylus</a></li><li><a href="http://www.gulpjs.com.cn/docs/getting-started/" target="_blank" rel="noopener">gulp</a></li><li><a href="http://www.gruntjs.net/" target="_blank" rel="noopener">grunt</a><br>好吧先这么多，总之从一个菜鸟成长起来一定会有些辛苦的，要加油啦！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自十一假期回来就进入了疯狂的笔试面试阶段，到11月初终于工作尘埃落定。前一阵子也是写了个传说中的励志的故事&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MjA5MDQzNA==&amp;amp;mid=400211500&amp;amp;idx=1&amp;amp;sn=881f3ce8213571ac223db7c250cd35b9#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接戳我&lt;/a&gt;，从3月接触前端走到现在真的是不容易，好在没有放弃。不过这段时间一直忙着找工作的事情也是好久没有去搞一搞自己喜欢的东西了，确实前端这里还有好多东西要学，于是先来搞一个TODOlist：&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://blog.locusland.xyz/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="web前端" scheme="http://blog.locusland.xyz/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础面试问题总结</title>
    <link href="http://blog.locusland.xyz/2015/09/20/it-interview/"/>
    <id>http://blog.locusland.xyz/2015/09/20/it-interview/</id>
    <published>2015-09-20T11:12:04.000Z</published>
    <updated>2017-08-23T06:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天奔波于各路招聘会以及笔试，我一个应聘前端的各种考计算机基础题和C，感觉整个人都不好了，笔试过后还有面试，导师那边还得偷着跑出去，人生真是如此艰难。。。吐槽完毕开始总结(毕竟我是个前端，还是主要总结一下网络这方面的)：</p><a id="more"></a><h1 id="IT-interview"><a href="#IT-interview" class="headerlink" title="IT-interview"></a>IT-interview</h1><p>为了面试，为了面试，为了面试，我决定回到考研那个年代：</p><h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="$算法与数据结构"></a>$算法与数据结构</h2><p>这个我是真不太懂，反正都是网上摘的，就直接上链接了：</p><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><a href="http://blog.csdn.net/whuslei/article/details/6442755" target="_blank" rel="noopener">常见排序算法小结</a></p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p><a href="http://blog.csdn.net/luckyxiaoqiang/article/details/7518888/" target="_blank" rel="noopener">轻松搞定面试中的二叉树题目</a></p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="$计算机网络"></a>$计算机网络</h2><h3 id="http-https协议详解"><a href="#http-https协议详解" class="headerlink" title="http/https协议详解"></a>http/https协议详解</h3><p>[http协议]（<a href="http://blog.csdn.net/hguisu/article/details/8680808" target="_blank" rel="noopener">http://blog.csdn.net/hguisu/article/details/8680808</a>)</p><h3 id="post与get方法的区别"><a href="#post与get方法的区别" class="headerlink" title="post与get方法的区别"></a>post与get方法的区别</h3><p>1.GET是从服务器上获取数据，POST是向服务器传送数据，在FORM（表单）中，Method默认为”GET”。<br>2.GET 是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。POST是通过HTTP POST机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。<br>3.对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据。<br>4.GET传送的数据量较小，不能大于2KB（这主要是因为受URL长度限制）。POST传送的数据量较大，一般被默认为不受限制。但理论上，限制取决于服务器的处理能力。<br>5.GET 安全性较低，POST安全性较高。因为GET在传输过程，数据被放在请求的URL中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记 录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一 同显示在用户面前。POST的所有操作对用户来说都是不可见的。</p><p><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="noopener">然而对于网上流传的说法这些区别有些并不准确</a><br><a href="http://blog.csdn.net/gideal_wang/article/details/4316691" target="_blank" rel="noopener">这个文章还不错</a></p><h3 id="osi七层，tcp-ip四层。区别？"><a href="#osi七层，tcp-ip四层。区别？" class="headerlink" title="osi七层，tcp/ip四层。区别？"></a>osi七层，tcp/ip四层。区别？</h3><p>TCP/IP:<br>数据链路层：ARP,RARP<br>网络层： IP,ICMP,IGMP<br>传输层：TCP ,UDP,UGP<br>应用层：Telnet,FTP,SMTP,SNMP.</p><p>OSI:<br>物理层：EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45, Ethernet, 802.3, 802.5, FDDI, NRZI, NRZ, B8ZS<br>数据链路层：Frame Relay, HDLC, PPP, IEEE 802.3/802.2, FDDI, ATM,  IEEE 802.5/802.2<br>网络层：IP，IPX，AppleTalk DDP<br>传输层：TCP，UDP，SPX<br>会话层：RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP<br>表示层:TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML<br>应用层：FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP</p><p>应用层<br>1.主要功能 ：用户接口、应用程序<br>application 2.典型设备：网关<br>3.典型协议、标准和应用：TELNET, FTP, HTTP</p><p>表示层<br>1.主要功能 ：数据的表示、压缩和加密<br>presentation2.典型设备：网关<br>3.典型协议、标准和应用：ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG</p><p>会话层<br>1.主要功能 ：会话的建立和结束<br>session2.典型设备：网关<br>3.典型协议、标准和应用：RPC、SQL、NFS 、X WINDOWS、ASP</p><p>传输层<br>1.主要功能 ：端到端控制<br>transport 2.典型设备：网关<br>3.典型协议、标准和应用：TCP、UDP、SPX</p><p>网络层<br>1.主要功能 ：路由，寻址<br>network2.典型设备：路由器<br>3.典型协议、标准和应用：IP、IPX、APPLETALK、ICMP</p><p>数据链路层<br>1.主要功能 ：保证误差错的数据链路<br>data link 2.典型设备：交换机、网桥、网卡<br>3.典型协议、标准和应用：802.2、802.3ATM、HDLC、FRAME RELAY</p><p>物理层<br>1.主要功能 ：传输比特流<br>physical2.典型设备：集线器、中继器<br>3.典型协议、标准和应用：V.35、EIA/TIA-232</p><p>TCP/IP网络协议<br>TCP/IP(Transmission Control Protocol/Internet Protocol，传输控制协议/网间网协议)是目前世界上应用最为广泛的协议，它的流行与Internet的迅猛发展密切相关—TCP/IP最初是为互联网的原型ARPANET所设计的，目的是提供一整套方便实用、能应用于多种网络上的协议，事实证明TCP/IP做到了这一点，它使网络互联变得容易起来，并且使越来越多的网络加入其中，成为Internet的事实标准。</p><ul><li><p>应用层—应用层是所有用户所面向的应用程序的统称。ICP/IP协议族在这一层面有着很多协议来支持不同的应用，许多大家所熟悉的基于Internet的应用的实现就离不开这些协议。如我们进行万维网（WWW）访问用到了HTTP协议、文件传输用FTP协议、电子邮件发送用SMTP、域名的解析用DNS协议、远程登录用Telnet协议等等，都是属于TCP/IP应用层的；就用户而言，看到的是由一个个软件所构筑的大多为图形化的操作界面，而实际后台运行的便是上述协议。</p></li><li><p>传输层—这一层的的功能主要是提供应用程序间的通信，TCP/IP协议族在这一层的协议有TCP和UDP。</p></li><li><p>网络层—是TCP/IP协议族中非常关键的一层，主要定义了IP地址格式，从而能够使得不同应用类型的数据在Internet上通畅地传输，IP协议就是一个网络层协议。</p></li><li><p>网络接口层—这是TCP/IP软件的最低层，负责接收IP数据包并通过网络发送之，或者从网络上接收物理帧，抽出IP数据报，交给IP层。</p></li></ul><p>OSI与TCP/IP的比较：<br>分层结构<br>OSI参考模型与TCP/IP协议都采用了分层结构，都是基于独立的协议栈的概念。OSI参考模型有7层，而TCP/IP协议只有4层，即TCP/IP协议没有了表示层和会话层，并且把数据链路层和物理层合并为网络接口层。不过，二者的分层之间有一定的对应关系</p><p>标准的特色<br>OSI参考模型的标准最早是由ISO和CCITT（ITU的前身）制定的，有浓厚的通信背景，因此也打上了深厚的通信系统的特色，比如对服务质量（QoS）、差错率的保证，只考虑了面向连接的服务。并且是先定义一套功能完整的构架，再根据该构架来发展相应的协议与系统。</p><p>TCP/IP协议产生于对Internet网络的研究与实践中，是应实际需求而产生的，再由IAB、IETF等组织标准化，而并不是之前定义一个严谨的框架。而且TCP/IP最早是在UNIX系统中实现的，考虑了计算机网络的特点，比较适合计算机实现和使用。</p><p>连接服务<br>OSI的网络层基本与TCP/IP的网际层对应，二者的功能基本相似，但是寻址方式有较大的区别。</p><p>OSI的地址空间为不固定的可变长，由选定的地址命名方式决定，最长可达160byte，可以容纳非常大的网络，因而具有较大的成长空间。根据OSI的规定，网络上每个系统至多可以有256个通信地址。</p><p>TCP/IP网络的地址空间为固定的4byte（在目前常用的IPV4中是这样，在IPV6中将扩展到16byte）。网络上的每一个系统至少有一个唯一的地址与之对应。</p><p>传输服务<br>OSI与TCP/IP的传输层都对不同的业务采取不同的传输策略。OSI定义了五个不同层次的服务：TP1，TP2，TP3，TP4，TP5。TCP/IP定义了TCP和UPD两种协议，分别具有面向连接和面向无连接的性质。其中TCP与OSI中的TP4，UDP与OSI中的TP0在构架和功能上大体相同，只是内部细节有一些差异。</p><p>应用范围<br>OSI由于体系比较复杂，而且设计先于实现，有许多设计过于理想，不太方便计算机软件实现，因而完全实现OSI参考模型的系统并不多，应用的范围有限。而TCP/IP协议最早在计算机系统中实现，在UNIX、Windows平台中都有稳定的实现，并且提供了简单方便的编程接口（API），可以在其上开发出丰富的应用程序，因此得到了广泛的应用。TCP/IP协议已成为目前网际互联事实上的国际标准和工业标准。</p><h3 id="什么是TCP-UDP协议，IP协议"><a href="#什么是TCP-UDP协议，IP协议" class="headerlink" title="什么是TCP/UDP协议，IP协议"></a>什么是TCP/UDP协议，IP协议</h3><p>1．TCP/UDP协议<br>TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。其中TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；而UDP则不为IP提供可靠性、流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。TCP支持的应用协议主要有：Telnet、FTP、SMTP等；UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。</p><ol><li>IP协议的定义、IP地址的分类及特点</li></ol><p>什么是IP协议，IP地址如何表示，分为几类，各有什么特点？<br>为了便于寻址和层次化地构造网络，IP地址被分为A、B、C、D、E五类，商业应用中只用到A、B、C三类。</p><p>IP协议(Internet Protocol)又称互联网协议，是支持网间互连的数据报协议，它与TCP协议（传输控制协议）一起构成了TCP/IP协议族的核心。它提供网间连接的完善功能， 包括IP数据报规定互连网络范围内的IP地址格式。</p><p>Internet 上，为了实现连接到互联网上的结点之间的通信，必须为每个结点（入网的计算机）分配一个地址，并且应当保证这个地址是全网唯一的，这便是IP地址。</p><p>目前的IP地址（IPv4：IP第4版本）由32个二进制位表示，每8位二进制数为一个整数，中间由小数点间隔，如159.226.41.98，整个IP地址空间有4组8位二进制数，由表示主机所在的网络的地址（类似部队的编号）以及主机在该网络中的标识（如同士兵在该部队的编号）共同组成。</p><p>为了便于寻址和层次化的构造网络，IP地址被分为A、B、C、D、E五类，商业应用中只用到A、B、C三类。</p><ul><li><p>A类地址：A类地址的网络标识由第一组8位二进制数表示，网络中的主机标识占3组8位二进制数，A类地址的特点是网络标识的第一位二进制数取值必须为 “0”。不难算出，A类地址允许有126个网段，每个网络大约允许有1670万台主机，通常分配给拥有大量主机的网络（如主干网）。</p></li><li><p>B类地址：B类地址的网络标识由前两组8位二进制数表示，网络中的主机标识占两组8位二进制数，B类地址的特点是网络标识的前两位二进制数取值必须为“10”。B类地址允许有16384个网段，每个网络允许有65533台主机，适用于结点比较多的网络（如区域网）。</p></li><li><p>C类地址：C类地址的网络标识由前3组8位二进制数表示，网络中主机标识占1组8位二进制数，C类地址的特点是网络标识的前3位二进制数取值必须为“110”。具有C类地址的网络允许有254台主机，适用于结点比较少的网络（如校园网）。</p></li></ul><p>为了便于记忆，通常习惯采用4个十进制数来表示一个IP地址，十进制数之间采用句点“.”予以分隔。这种IP地址的表示方法也被称为点分十进制法。如以这种方式表示，A类网络的IP地址范围为1.0.0.1－127.255.255.254；B类网络的IP地址范围为：128.1.0.1－191.255.255.254；C类网络的IP地址范围为：192.0.1.1－223.255.255.254。</p><p>由于网络地址紧张、主机地址相对过剩，采取子网掩码的方式来指定网段号。</p><p>TCP/IP协议与低层的数据链路层和物理层无关，这也是TCP/IP的重要特点。正因为如此 ，它能广泛地支持由低两层协议构成的物理网络结构。目前已使用TCP/IP连接成洲际网、全国网与跨地区网。</p><h3 id="TCP连接三次握手、断开四次挥手的过程"><a href="#TCP连接三次握手、断开四次挥手的过程" class="headerlink" title="TCP连接三次握手、断开四次挥手的过程"></a>TCP连接三次握手、断开四次挥手的过程</h3><p>三次握手：客户端发起请求（序列号）-服务器回应ack并给出自己的序列号-客户端回应ack。<br>断开四次挥手：一端发起断开（FIN），另外一端回应ack；这样一端的写就关闭了；另外一端发起断开请求（FIN），本端回应ack。这样双方都关闭了连接。因为一端关闭了写，但是另外一端可能还有数据要发送，所以两端可能不同时关掉连接，就出现了4次挥手的过程。</p><p>还有一些web综合的问题，在另一个前端面试总结中···</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="$操作系统"></a>$操作系统</h2><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>进程是分配资源的基本单位（CPU、内存等），有独立的地址空间。线程是进程中的一个实体，共享进程的地址空间，是轻量级的进程，是CPU调度和分配的基本单位，但是各个线程拥有自己的栈空间。 使用多线程编程的好处：（1）单线程遇到阻塞，会卡死，影响交互；（2）发挥多核CPU的计算能力；（3）简化程序结构，使程序便于维护；（4）与进程相比，线程的创建和切换开销更小。<br>参考<a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程</a></p><h3 id="阻塞、非阻塞，同步、异步的区别"><a href="#阻塞、非阻塞，同步、异步的区别" class="headerlink" title="阻塞、非阻塞，同步、异步的区别"></a>阻塞、非阻塞，同步、异步的区别</h3><p><a href="http://blog.csdn.net/klarclm/article/details/8828486" target="_blank" rel="noopener">http://blog.csdn.net/klarclm/article/details/8828486</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天奔波于各路招聘会以及笔试，我一个应聘前端的各种考计算机基础题和C，感觉整个人都不好了，笔试过后还有面试，导师那边还得偷着跑出去，人生真是如此艰难。。。吐槽完毕开始总结(毕竟我是个前端，还是主要总结一下网络这方面的)：&lt;/p&gt;
    
    </summary>
    
      <category term="整理" scheme="http://blog.locusland.xyz/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="面试" scheme="http://blog.locusland.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://blog.locusland.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://blog.locusland.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="计算机网络" scheme="http://blog.locusland.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="操作系统" scheme="http://blog.locusland.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>360在线笔试编程题</title>
    <link href="http://blog.locusland.xyz/2015/09/15/360-written/"/>
    <id>http://blog.locusland.xyz/2015/09/15/360-written/</id>
    <published>2015-09-15T14:05:56.000Z</published>
    <updated>2017-08-23T06:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近真是感觉心力交瘁，原来走正常校招流程是这么亚历山大的一件事（尤其是今年），之前鹅厂的笔试题已经把我虐的体无完肤了（尼玛应聘前端一道前端题没考），昨天做的360的行测题也真是脑细胞死了一大片（答了整整4个多小时的逻辑题和性格测试），找个工作么，至于这样么。。。索性就来这里吐个槽吧<br><a id="more"></a><br>然后今天是360的在线笔试，好在选择还有一半左右的题是前端的（剩下的C++和算法基本就是凭感觉来了），然后大题是编程题，反正我都是用JS写的，然而那个系统对JS语言的支持程度我也不是很理解，而且这两道题的输出结果也是略显奇葩，不过在算法上来讲还是很简单的。</p><p>######1<br>要求：输入一个正整数，返回该数的素数乘积，并且从小到大排列，数字之间用 <em> 相连<br>例如：输入20，输出 2</em>2*5<br>核心就是将一个整数进行质因数的分解—吧。概念上的东西不是很清楚，但是实现起来很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  function question1(num)&#123;</span><br><span class="line">var k = 2;</span><br><span class="line">var result = &apos;&apos;;</span><br><span class="line">while(num &gt; k)&#123;</span><br><span class="line">if(num % k ==0)&#123;</span><br><span class="line">result = result + k +&apos;*&apos;; </span><br><span class="line">num = num/k</span><br><span class="line">&#125;</span><br><span class="line">if(num % k != 0)&#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result+=k;</span><br><span class="line">console.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>######2<br>一个关于研究生考试的，背景：总分为 政治100，英语100，数学150，专业150。其中，政治、英语不得低于60，数学、专业不得低于90，总分不得低于310，否则考研失败返回‘Fail’<br>310 &lt;= 总分 &lt; 350，自费读研返回‘Zifei’<br>350 &lt;= 总分，公费读研返回‘Gongfei’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  function question2(n1,n2,n3,n4)&#123;//分别为政治，英语，数学，专业课</span><br><span class="line">var sum = n1+n2+n3+n4;</span><br><span class="line">if(n1&lt;60 || n2&lt;60 || n3&lt;90 || n4&lt;90 || sum&lt;310)&#123;</span><br><span class="line">return &apos;Fail\n&apos;;</span><br><span class="line">&#125; else if(sum &gt;= 310 &amp;&amp; sum &lt;350)&#123;</span><br><span class="line">return &apos;Zifei\n&apos;;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">return &apos;Gongfei\n&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单明了，然而在赛码那个平台上写起来真是让人无语，无论是对输入流的读取还是关于输出流的判定。。。反正是各种无语可能我还不熟练吧反正就这么过去了咳咳</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近真是感觉心力交瘁，原来走正常校招流程是这么亚历山大的一件事（尤其是今年），之前鹅厂的笔试题已经把我虐的体无完肤了（尼玛应聘前端一道前端题没考），昨天做的360的行测题也真是脑细胞死了一大片（答了整整4个多小时的逻辑题和性格测试），找个工作么，至于这样么。。。索性就来这里吐个槽吧&lt;br&gt;
    
    </summary>
    
      <category term="整理" scheme="http://blog.locusland.xyz/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一些阿里校招笔试题</title>
    <link href="http://blog.locusland.xyz/2015/08/19/ali-exam/"/>
    <id>http://blog.locusland.xyz/2015/08/19/ali-exam/</id>
    <published>2015-08-19T14:17:20.000Z</published>
    <updated>2017-09-14T07:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天做了阿里的笔试题，总体感觉说来，比之前实习那个简单多了- -我记着那次各种跨度各种大，考了node，canvas，web安全，AMD和CommonJS等balabalabalalalal咳咳咳这次的笔试题更加注重基础了，整体来讲没啥问题，然而有些题也不是很确定。不扯废话了，把记录下来的几个觉得值得记录的题弄上来分析下：<br><a id="more"></a><br>填空和选择都是一些基础题目，大题也没有脱离JS,CSS,HTML的基础。</p><h6 id="1"><a href="#1" class="headerlink" title="1"></a>1</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var matrix = &#123;[1,2],[3,4],[5,6]&#125;;</span><br><span class="line">  var flatten = matrix._____(function(a,b)&#123;</span><br><span class="line">    _______</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(flatten());//[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure><p>这个题第一感觉想到用map，然而仔细一看其实是一个归并操作，将matrix种所有的数组元素合并成一个大数组，所以应该是对数组进行归并然后连接，所以我的答案是：reduce，return a.concat(b)。</p><h6 id="2"><a href="#2" class="headerlink" title="2"></a>2</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func = function() &#123;</span><br><span class="line">   console.log(this.valueOf());</span><br><span class="line"> &#125;</span><br><span class="line"> func._____________</span><br><span class="line"> 期望结果：abc</span><br></pre></td></tr></table></figure><p>这个题挺有意思的感觉，因为func函数中没有abc字符串，而空格中明显是要调用func函数的一个方法（或者属性），然而函数本身的属性没有什么会是abc的，最开始我想到重新定义函数本身的valueOf，然而并不可取，在func内部的this明显是指向window对象，就算你定义func的什么东西，func内部的this就是window，后来想想这就1个空，怎么说也就是一个方法的事情，那函数本身就那么几个方法，而这道题明显是让你自己用abc通过valueOf输出出来，那么只要使用call或者apply就可以搞定了。我的答案：call(“abc”)或者apply(“abc”),这两个函数再只有一个参数的时候没什么区别的。</p><h6 id="3"><a href="#3" class="headerlink" title="3"></a>3</h6><p>实现左右布局，左边固定200px，右边自适应宽度。使用多种方法。</p><p><iframe height="288" scrolling="no" src="//codepen.io/geniuspeng/embed/JdQKyy/?height=268&theme-id=15655&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/geniuspeng/pen/JdQKyy/" target="_blank" rel="noopener">左右布局</a> by Yunpeng Bai (<a href="http://codepen.io/geniuspeng" target="_blank" rel="noopener">@geniuspeng</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><br>我就写了这三种，一种是float的流式布局，一种是绝对定位实现的，一种是flex伸缩盒布局，写到这里不得不感慨一句：FLEX大法好！ 咳咳。</p><h6 id="4"><a href="#4" class="headerlink" title="4"></a>4</h6><p>使用原生JS，写一个getElementsByName（root,class_name）方法，获取指定元素（root）所有包含类（class_name）的子元素，需要兼容IE6，7浏览器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> function getElementByClassName(root,class_name)</span><br><span class="line">&#123;</span><br><span class="line">    if(root)</span><br><span class="line">    &#123;</span><br><span class="line">        root=typeof root==&quot;string&quot;?document.getElementById(root):root;</span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;</span><br><span class="line">        root=document.body;</span><br><span class="line">    &#125;</span><br><span class="line">    //class_name=tag||&quot;*&quot;;</span><br><span class="line">    var els=root.getElementsByTagName(&quot;*&quot;),arr=[];</span><br><span class="line">    for(var i= 0,n=els.length;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(var j= 0,k=els[i].className.split(&quot; &quot;),l= k.length;j&lt;l;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(k[j] ==class_name)</span><br><span class="line">            &#123;</span><br><span class="line">                arr.push(els[i]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="5"><a href="#5" class="headerlink" title="5"></a>5</h6><p>请用JavaScript实现一个输入框，可根据用户的输入，来实时像服务器请求，并给出搜索结果，主要功能点要求，要考虑一些性能优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        // Firefox, Google Chrome, Opera, Safari, Internet Explorer from version 9</span><br><span class="line">        var timeout = null;</span><br><span class="line">        function OnInput (event) &#123;</span><br><span class="line">            if(timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = null;</span><br><span class="line">                timeout = setTimeout(function()&#123;</span><br><span class="line">                    var xhr = createXMLHTTPRequest();</span><br><span class="line">                    alert(&quot;send ajax&quot;);</span><br><span class="line">                &#125;, 200);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                timeout = setTimeout(function()&#123;</span><br><span class="line">                    var xhr = createXMLHTTPRequest();</span><br><span class="line">                    alert(&quot;send ajax&quot;);</span><br><span class="line">                &#125;, 200);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Internet Explorer</span><br><span class="line">        function OnPropChanged (event) &#123;</span><br><span class="line">            if (event.propertyName.toLowerCase () == &quot;value&quot;) &#123;</span><br><span class="line">                if(timeout) &#123;</span><br><span class="line">                    clearTimeout(timeout);</span><br><span class="line">                    timeout = null;</span><br><span class="line">                    timeout = setTimeout(function()&#123;</span><br><span class="line">                        var xhr = createXMLHTTPRequest();</span><br><span class="line">                        alert(&quot;send ajax&quot;);</span><br><span class="line">                    &#125;, 200);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    timeout = setTimeout(function()&#123;</span><br><span class="line">                        var xhr = createXMLHTTPRequest();</span><br><span class="line">                        alert(&quot;send ajax&quot;);</span><br><span class="line">                    &#125;, 200);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // XHR</span><br><span class="line">        function createXMLHTTPRequest() &#123;</span><br><span class="line">            var xmlHttpRequest;</span><br><span class="line">            if (window.XMLHttpRequest) &#123;</span><br><span class="line">                //针对FireFox，Mozillar，Opera，Safari，IE7，IE8</span><br><span class="line">                xmlHttpRequest = new XMLHttpRequest();</span><br><span class="line">                if (xmlHttpRequest.overrideMimeType) &#123;</span><br><span class="line">                    xmlHttpRequest.overrideMimeType(&quot;text/xml&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (window.ActiveXObject) &#123;</span><br><span class="line">                var activexName = [ &quot;MSXML2.XMLHTTP&quot;, &quot;Microsoft.XMLHTTP&quot; ];</span><br><span class="line">                for ( var i = 0; i &lt; activexName.length; i++) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        xmlHttpRequest = new ActiveXObject(activexName[i]);</span><br><span class="line">                        if(xmlHttpRequest)&#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return xmlHttpRequest;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; oninput=&quot;OnInput (event)&quot; onpropertychange=&quot;OnPropChanged (event)&quot;</span><br><span class="line">       value=&quot;Text field&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天做了阿里的笔试题，总体感觉说来，比之前实习那个简单多了- -我记着那次各种跨度各种大，考了node，canvas，web安全，AMD和CommonJS等balabalabalalalal咳咳咳这次的笔试题更加注重基础了，整体来讲没啥问题，然而有些题也不是很确定。不扯废话了，把记录下来的几个觉得值得记录的题弄上来分析下：&lt;br&gt;
    
    </summary>
    
      <category term="整理" scheme="http://blog.locusland.xyz/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="CSS" scheme="http://blog.locusland.xyz/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>深入分析deepclone</title>
    <link href="http://blog.locusland.xyz/2015/08/17/deepclone/"/>
    <id>http://blog.locusland.xyz/2015/08/17/deepclone/</id>
    <published>2015-08-17T11:22:35.000Z</published>
    <updated>2017-08-23T06:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最开始看到深度克隆（DeepClone）这个词，完全不理解是什么意思。复制就复制嘛，干嘛还搞写什么深浅的？后来随着对JS理解的深入，也就慢慢理解了这个词的含义~这个问题，其实说来也很简单，但看似又不那么简单。<br><a id="more"></a><br>说到DeepClone，还要从JS那个“一切皆为对象”说起，JS的数据类型有6种，其中5中基本类型（string，boolean，number，null，undefined）和1中引用类型（Object），而这种引用类型又生了很多“儿子”，除了String，Boolean，Number这些包装类型，还有Array，Function，RegExp，Date等等。<br>那么，所谓克隆（复制），大家都理解，就是弄一个跟原来的东东一模一样的东东- -所以说，既然是这样，直接赋值不就搞定了么，我最开始就是这么想的，弄这么复杂搞了个什么“深度复制”和直接赋值有什么区别？例如现在有个基本类型a，我想把它复制到b上面去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = a;</span><br><span class="line">a = 10;</span><br><span class="line">console.log(b); // 1</span><br><span class="line"></span><br><span class="line">var a = &apos;hello&apos;;</span><br><span class="line">var b = a;</span><br><span class="line">a = &apos;world&apos;;</span><br><span class="line">console.log(b); // hello</span><br><span class="line"></span><br><span class="line">var a = true;</span><br><span class="line">var b = a;</span><br><span class="line">a = false;</span><br><span class="line">console.log(b); // true</span><br></pre></td></tr></table></figure><p>从代码中可以看出，对于数字，字符串，和布尔类型的基本类型变量，直接赋值即可完成复制。那么对于引用类型呢？这里首先想到Function类型，它虽然继承自Object，然而在JS中函数总是感觉有一些特殊性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = function() &#123;console.log(1);&#125;;</span><br><span class="line">var b = a;</span><br><span class="line">a = function() &#123;console.log(2);&#125;;</span><br><span class="line">b(); // 1</span><br></pre></td></tr></table></figure><p>因为JS中函数是可以赋值给一个变量的，将这个变量直接复制给另一个变量，这样看来a的函数似乎直接被赋值给了b，可以完成复制，而实际上确实如此，如果单独说复制一个函数是可以像基本类型那样直接赋值来搞定的。然而如果根据JS的存储机制，引用类型（对象）所谓的复制并不像基本类型那样简单，实际上只是复制了当前对象的指针而已，即让新的变量的指针指向被复制对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = function() &#123;console.log(1);&#125;;</span><br><span class="line">a.tmp = 10;</span><br><span class="line">var b = a;</span><br><span class="line">a.tmp = 20;</span><br><span class="line">console.log(b.tmp); // 20</span><br></pre></td></tr></table></figure><p>这样就很容易看出来问题了，如果说给这个变量一个额外的属性tmp，它们共同指向内存中一片区域，赋值之后改变这个属性的值那么，复制对象b的tmp属性也会随之改变。对于其他引用类型来说，这个问题将更加直观：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [0, 1, 2, 3];</span><br><span class="line">var b = a;</span><br><span class="line">a.push(4);</span><br><span class="line">console.log(b); // [0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>咳咳咳，一目了然，就是说，直接赋值顶多可以称得上是一种“浅复制”，对于基本类型来说没有问题，如果是引用类型，只是复制了指向这个对象的指针，而并没有完全复制其内容。所以DeepClone就出来了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function deepClone(obj) &#123;</span><br><span class="line">    var _toString = Object.prototype.toString;</span><br><span class="line">    </span><br><span class="line">    // null, undefined, non-object, function</span><br><span class="line">    if (!obj || typeof obj !== &apos;object&apos;) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    var result = Array.isArray(obj) ? [] : </span><br><span class="line">        obj.constructor ? new obj.constructor() : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    for (var key in obj ) &#123;</span><br><span class="line">        result[key] = deepClone(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个比较通用的deepclone函数了，主要思路就是先把5中基本类型处理掉（直接赋值），然后根据引用类型的类别（数组还是对象）进行递归调用，然而还有一些特殊的引用类型，这个函数是无法解决的，但大家似乎任务这并不是深度克隆需要注意的地方。我曾经看到过一些对特殊引用类型deepclone处理方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// DOM Node</span><br><span class="line">if (obj.nodeType &amp;&amp; &apos;cloneNode&apos; in obj) &#123;</span><br><span class="line">    return obj.cloneNode(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Date</span><br><span class="line">if (_toString.call(obj) === &apos;[object Date]&apos;) &#123;</span><br><span class="line">    return new Date(obj.getTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RegExp</span><br><span class="line">if (_toString.call(obj) === &apos;[object RegExp]&apos;) &#123;</span><br><span class="line">    var flags = [];</span><br><span class="line">    if (obj.global) &#123; flags.push(&apos;g&apos;); &#125;</span><br><span class="line">    if (obj.multiline) &#123; flags.push(&apos;m&apos;); &#125;</span><br><span class="line">    if (obj.ignoreCase) &#123; flags.push(&apos;i&apos;); &#125;</span><br><span class="line"></span><br><span class="line">    return new RegExp(obj.source, flags.join(&apos;&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯就酱~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最开始看到深度克隆（DeepClone）这个词，完全不理解是什么意思。复制就复制嘛，干嘛还搞写什么深浅的？后来随着对JS理解的深入，也就慢慢理解了这个词的含义~这个问题，其实说来也很简单，但看似又不那么简单。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>那些年我们用CSS画的图形2</title>
    <link href="http://blog.locusland.xyz/2015/08/12/css-shape2/"/>
    <id>http://blog.locusland.xyz/2015/08/12/css-shape2/</id>
    <published>2015-08-12T11:37:03.000Z</published>
    <updated>2017-09-14T07:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>休了个半个月的“长假”，我觉得这算是我在最近几年的夏天能休的最长的假了。放假前那个关于图形的只写了一半- -赶紧补上。之前都是一些简单的图形，现在的CSS3结合：before和：after伪类只用少量代码就可以完成一些更复杂的图形：<br><a id="more"></a></p><h3 id="梯形-平行四边形"><a href="#梯形-平行四边形" class="headerlink" title="梯形/平行四边形"></a>梯形/平行四边形</h3><p>先说说梯形吧，其实跟画三角形的原理类似，利用border的厚度来实现的，我们可以想象，一个div他的上下border和左右border分别占据它height和width的一半的时候，这四个border就会展现成四个三角形占据了整个div，当然，如果这个border的厚度没有达到那么多，那四个border会展示成4个等腰梯形。<br>平行四边形的话，是利用css3的transform属性来实现的，transform有一个skew的值，定义图形沿着 X 和 Y 轴的 2D 倾斜转换，也可以指定skewX或者skewY来指定是X轴还是Y轴，不管怎么做，利用这一个属性即可实现平行四边形。</p><iframe height="268" scrolling="no" src="//codepen.io/geniuspeng/embed/gpyaQp/?height=268&theme-id=15655&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/geniuspeng/pen/gpyaQp/" target="_blank" rel="noopener">CSS3梯形/平行四边形</a> by Yunpeng Bai (<a href="http://codepen.io/geniuspeng" target="_blank" rel="noopener">@geniuspeng</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h3 id="五角星-六角星"><a href="#五角星-六角星" class="headerlink" title="五角星/六角星"></a>五角星/六角星</h3><p>这个五角星相比之前的图形略显复杂，至少对我我现在的CSS水平独立画出来应该是有一些费劲~~~然而只要知道原理，还是很好实现的，这个五角星实际上是用三个三角形拼出来的图形，这三个图形则通过before和after伪类来实现，三角形仍然是利用border方法，两个分别向两边旋转35度的矩形，加上一个竖直的矩形分离出来的三个三角形即可实现，然而要设计一下矩形的长宽来确保组成五角星的三角形所需要的角度。<br>六角星的话相对来说就简单些了，实际上是用两个等边三角形组成的，一个正立的一个倒立的，再进行适当的移位即可完成，如果话正六边形，那等边三角形的设计需要注意div矩形的长宽以及border的厚度。</p><iframe height="268" scrolling="no" src="//codepen.io/geniuspeng/embed/QbPjov/?height=268&theme-id=15655&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/geniuspeng/pen/QbPjov/" target="_blank" rel="noopener">CSS五角星/六角星</a> by Yunpeng Bai (<a href="http://codepen.io/geniuspeng" target="_blank" rel="noopener">@geniuspeng</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h3 id="正五边形-正六边形-正八边形"><a href="#正五边形-正六边形-正八边形" class="headerlink" title="正五边形/正六边形/正八边形"></a>正五边形/正六边形/正八边形</h3><p>其实只要有三角形和梯形，这些形状都可以说是轻而易举，最主要的问题是找好三角形或者梯形的角度。正五边形，一个三角形加一个倒梯形，正六边形，则是上下两个三角形和中间一个矩形组成的，而正八边形则是上下两个梯形加上中间一个矩形组成。</p><iframe height="268" scrolling="no" src="//codepen.io/geniuspeng/embed/LVvGYo/?height=268&theme-id=15655&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/geniuspeng/pen/LVvGYo/" target="_blank" rel="noopener">CSS正五边形/正六边形/正八边形</a> by Yunpeng Bai (<a href="http://codepen.io/geniuspeng" target="_blank" rel="noopener">@geniuspeng</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;休了个半个月的“长假”，我觉得这算是我在最近几年的夏天能休的最长的假了。放假前那个关于图形的只写了一半- -赶紧补上。之前都是一些简单的图形，现在的CSS3结合：before和：after伪类只用少量代码就可以完成一些更复杂的图形：&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://blog.locusland.xyz/categories/css/"/>
    
    
      <category term="css" scheme="http://blog.locusland.xyz/tags/css/"/>
    
      <category term="css3" scheme="http://blog.locusland.xyz/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>那些年我们用CSS画的图形</title>
    <link href="http://blog.locusland.xyz/2015/07/19/css-shape/"/>
    <id>http://blog.locusland.xyz/2015/07/19/css-shape/</id>
    <published>2015-07-19T08:46:48.000Z</published>
    <updated>2017-09-14T07:36:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>想当年，CSS刚出生的时候还无法得到大家的认可，那时候这货还是一个不符合标准的东东。。。然而从1996年W3C正式推出了CSS1开始到现在还在发展的CSS3，这货的强大功能可谓家喻户晓，包括之前只能用JS实现的动画效果，现在可以用纯CSS来搞定。最近记录了些CSS的图形实现，前一阵子面试还被问到如何用CSS实现三角形的问题。。。之前在css-trick上看多过很多图形，在此记录下<br><a id="more"></a></p><h3 id="正方形-矩形"><a href="#正方形-矩形" class="headerlink" title="正方形/矩形"></a>正方形/矩形</h3><p>这个没啥好说的，设置宽高即可。</p><iframe height="268" scrolling="no" src="//codepen.io/geniuspeng/embed/NqBONa/?height=268&theme-id=15655&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/geniuspeng/pen/NqBONa/" target="_blank" rel="noopener">NqBONa</a> by Yunpeng Bai (<a href="http://codepen.io/geniuspeng" target="_blank" rel="noopener">@geniuspeng</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h3 id="圆形-椭圆"><a href="#圆形-椭圆" class="headerlink" title="圆形/椭圆"></a>圆形/椭圆</h3><p>这个也没啥好说的，CSS3的圆角属性搞定。。。这里属性值可以用百分比来表示，50%即为一个圆形。</p><iframe height="268" scrolling="no" src="//codepen.io/geniuspeng/embed/ZGjqLq/?height=268&theme-id=15655&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/geniuspeng/pen/ZGjqLq/" target="_blank" rel="noopener">CSS圆形/椭圆</a> by Yunpeng Bai (<a href="http://codepen.io/geniuspeng" target="_blank" rel="noopener">@geniuspeng</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h3 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h3><p>三角形最普遍的方法就是用border来实现的，当一个div内容的宽高为0时，它的border就会呈现一个三角形的形状。通过设置border的大小和有无可以控制三角形的形状。</p><iframe height="268" scrolling="no" src="//codepen.io/geniuspeng/embed/PqByjm/?height=268&theme-id=15655&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/geniuspeng/pen/PqByjm/" target="_blank" rel="noopener">CSS三角形</a> by Yunpeng Bai (<a href="http://codepen.io/geniuspeng" target="_blank" rel="noopener">@geniuspeng</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想当年，CSS刚出生的时候还无法得到大家的认可，那时候这货还是一个不符合标准的东东。。。然而从1996年W3C正式推出了CSS1开始到现在还在发展的CSS3，这货的强大功能可谓家喻户晓，包括之前只能用JS实现的动画效果，现在可以用纯CSS来搞定。最近记录了些CSS的图形实现，前一阵子面试还被问到如何用CSS实现三角形的问题。。。之前在css-trick上看多过很多图形，在此记录下&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://blog.locusland.xyz/categories/css/"/>
    
    
      <category term="css" scheme="http://blog.locusland.xyz/tags/css/"/>
    
      <category term="css3" scheme="http://blog.locusland.xyz/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>一个JS俄罗斯方块</title>
    <link href="http://blog.locusland.xyz/2015/07/16/tetris/"/>
    <id>http://blog.locusland.xyz/2015/07/16/tetris/</id>
    <published>2015-07-16T15:58:11.000Z</published>
    <updated>2017-09-14T08:10:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近真是忙成孙子热成狗的节奏，不过好在这两天下了点小雨。。。白天当然继续还是做好自己的本分工作——导师的廉价劳动力，晚上在搞一个传说中的一个叫‘俄罗斯方块’的游戏。当我开始想用这个练练手的时候，感觉这个也忒简单了吧，小学就能玩得很6的东西，然而如果书做起来对于我这种前端菜鸟来说，使用JS完成一个俄罗斯方块并不是太顺利。我现在突然有点佩服当年闲得蛋疼想出了这个游戏的那个俄罗斯人<a href="http://baike.baidu.com/view/2154504.htm" target="_blank" rel="noopener">阿列克谢·帕基特诺夫</a><br>扯远了，今天也算是初步完成，姑且整理一下思路。<a href="http://blog.locusland.xyz/tetris/">链接戳我</a><br><a id="more"></a></p><p>#####################</p><h1 id="Board类"><a href="#Board类" class="headerlink" title="Board类"></a>Board类</h1><p>首先，要有个板子，关于板子的大小，可以自己来定。我这里用的是21*11的板子。板子是通过js动态生成的，当然也可以直接在HTML页面里画，不过动态生成你可以直接改变板子的大小。。。具体生成方法就是在一个指定的div里，通过两个for循环分别添加行和列。外层for循环添加行row，内层for循环添加列单元cell，然后push到一个数组中，这样这个数组就可以通过类似二维数组的两个下标来访问板子的特定格子。<br>板子Borad类还有几个方法，不过这些都是关于消除行的时候使用的，后面再说。</p><p>#####################</p><p>#Block类/Chunk类<br>Block类这个就是方块类了，关于方块这种东西，无非就是几个小块的组合，而小块则可以通过坐标来进行建模。比如，一条横线的那个方块，我在这里叫它blockI，[ 0, -1 ], [ 0, 0 ], [ 0, 1 ], [ 0, 2 ] 这四个点可以表达出来，也就是说一个方块由四个这种坐标点来组成，而这个坐标点的选取，对于每种方块我都选用经过或者尽量靠近[0,0]的点，而且所有的坐标保证不小于-1。这样建模的原因主要考虑以下两点：</p><ol><li>这只是方块的初始坐标，并不是实际坐标，方块的实际坐标需要加上一个定义出来的初始位置（location），从而才能放到建好的板子那个数组里（那个数组第一个下标代表行，第二个下标代表列，都是从0开始），而为了保证能放进去，这个方块的初始坐标不大于-1，这样就可以定义location的xy两个值仅仅大于等于1即可放到板子中。</li><li>离坐标原点[0,0]尽量近是为了更好的控制旋转，对于一个点(x,y),在坐标轴上相对于原点右旋90度的坐标为（-y,x），而离原点越近则旋转过程中方块的偏移位置就越小。<br>这样方块在板子中就可以有个位置了，而下移，左移，右移都仅仅是把这个方块的四个点的坐标分别x-1,x+1和y+1即可。<br>而Chunk类则表示上述的一个小方块，并且带有自己的坐标。就是说，一个Block是由4个Chunk构成的。而Block的显示，隐藏，移动，旋转都是通过对该Block的每一个Chunk进行的操作。每一个Chuck都会带有一个基础坐标x,y和location(x,y)，这两个加起来就是该Chunk的实际坐标。而方块的移动则是修改location的值，方块的旋转则需要在基础坐标上进行处理。<br>方块的下落便是通过将一个方块隐藏，y坐标+1，再显示来实现的。关于方块的显示和隐藏，由于整个板子是有若干个cell元素组成的，只需要将相应chunk在与板子上的坐标对应的位置设置上一个block样式即可显示，在这里针对不同的block形状设置了不同的颜色。相反隐藏就是移除这个block的样式。</li></ol><p>#####################</p><h1 id="Input类"><a href="#Input类" class="headerlink" title="Input类"></a>Input类</h1><p>这个方法是以前在网上学的，感觉基本上如果写一个需要按键进行操作的程序，使用一个Input类可以更好的进行代码的组织以及维护。这个方法没什么可说的，进入页面后通过codeKey进行判断，对相应的按键进行处理，当然这里需要与后面的Game类进行关联。</p><p>#####################</p><h1 id="Game类"><a href="#Game类" class="headerlink" title="Game类"></a>Game类</h1><p>这个Game当然就是指俄罗斯方块了。是核心类。因为一个Game会包括板子Board和Input，而板子又包括小方块Chunk，方块集合Block，所以说这个Game是关联了先前的所有类的。这个类的方法都是游戏的控制相关。如游戏的开始，暂停，记分板，等级和速度控制，以及游戏结束，我最后又加了两个功能：改变方块样式和改变背景图片。<br>先写到这吧。。。困死了==</p><p>###########<br>建模思路大体就是这样了，然后是游戏核心设计思路。俄罗斯方块的规则很简单（规则就不介绍了），下面将整体的设计按照游戏流程来解释：</p><h2 id="Game主要方法"><a href="#Game主要方法" class="headerlink" title="Game主要方法"></a>Game主要方法</h2><p>首先，Game类的构造函数对游戏整体进行初始化，创建一个游戏主面板和一个显示下一个方块的面板，并调用Game的start方法。</p><h3 id="start方法"><a href="#start方法" class="headerlink" title="start方法"></a>start方法</h3><p>在游戏开始的时候通过genernateBlock方法生成一个Block，这个Block在生成后立即通过一个makeActive方法使其进入活动状态，就是进入游戏的主面板。接下来通过一个Game的核心方法tick，使游戏持续运行。</p><h3 id="genernateBlock方法"><a href="#genernateBlock方法" class="headerlink" title="genernateBlock方法"></a>genernateBlock方法</h3><p>生成一个Block，并赋予一个初始的location。</p><h3 id="makeActive方法"><a href="#makeActive方法" class="headerlink" title="makeActive方法"></a>makeActive方法</h3><p>使一个生成的Block进入活动状态，进入游戏主面板中。在进入主面板的时候对齐进行校验，如果location不符合要求，则说明方块已经堆叠到最上方，游戏结束，如果location符合要求，则说明游戏正常运行，再生成一个新的Block放在下一个方块的面板中（nextBoard）进行显示。</p><h3 id="tick方法"><a href="#tick方法" class="headerlink" title="tick方法"></a>tick方法</h3><p>方法内部，通过定时器持续执行tick方法，执行间隔即方块的下落速度来控制，使方块在固定时间间隔下落一次，并进行触底判断，直至方块触底，如果触底进行消行判断，并将已经生成的在nextBoard中的方块通过makeAction使其进入活动状态，再持续通过tick实现方块定时下落。</p><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>键盘输入控制函数，没什么可介绍的-。-</p><h3 id="getSpeed-getLevel，cal-score方法"><a href="#getSpeed-getLevel，cal-score方法" class="headerlink" title="getSpeed,getLevel，cal_score方法"></a>getSpeed,getLevel，cal_score方法</h3><p>获取方块的下落间隔，和当前游戏级别，游戏级别越高，方块下落速度越快。cal_score方法带有一个参数，即消掉的行数n，根据n来进行计算此次消行获得多少分，并记录总共削掉了多少行，每消掉10行级别+1，下落间隔初始1000ms，每升一级减掉100ms，直到50ms。</p><h3 id="gameover方法"><a href="#gameover方法" class="headerlink" title="gameover方法"></a>gameover方法</h3><p>游戏结束时调用的方法，通过一个run标志来控制，游戏开始的时候此标志为true，结束时置为false直到下次开始。</p><h3 id="pause，changeBlockStyle，changeBackGround方法"><a href="#pause，changeBlockStyle，changeBackGround方法" class="headerlink" title="pause，changeBlockStyle，changeBackGround方法"></a>pause，changeBlockStyle，changeBackGround方法</h3><p>这几个方法与游戏核心方法关系并不大，控制游戏的暂停（同run标记一样，设置一个paused标记），改变方块的样式已经改变游戏背景。。。这里就不多废话了。</p><h2 id="Board主要方法"><a href="#Board主要方法" class="headerlink" title="Board主要方法"></a>Board主要方法</h2><p>Board的build方法上文已经介绍思路，下面的方法是专门针对消行来进行设计的，也是Game方法写出来之后加上去的。关于消行，就是看某一行是否所有的chunk都已经有方块占用，如果占满，删掉，然后让这一行上边所有的方块向下落（消掉n行就下落n行）。基于此原理，需要在board类中定义一个static_blocks属性，作为一个数组存储已经下落触底的方块。<br>在这里需要乱入一个Game的方法makeStaticBlock，此方法负责在一个方块触底的时候，将这个Block添加到板子的static_blocks中（同样是在tick方法中执行）。</p><h3 id="isFull方法"><a href="#isFull方法" class="headerlink" title="isFull方法"></a>isFull方法</h3><p>带有一个参数i，判断游戏面板的第i行是否全占满，同样，判断方法便是看所有static_blocks中的Block在第i行的部分是否全部显示，如果全部显示，则说明这一行已经堆满。</p><h3 id="clearStatic，unClearStatic方法"><a href="#clearStatic，unClearStatic方法" class="headerlink" title="clearStatic，unClearStatic方法"></a>clearStatic，unClearStatic方法</h3><p>清除与添加static_blocks中所有的方块的样式。</p><h3 id="shiftDown"><a href="#shiftDown" class="headerlink" title="shiftDown"></a>shiftDown</h3><p>带有参数i，将第i行上方所有的static_blocks中的Chunk集体下移一行。在这里乱入一个Block的crashLine方法，这个方法将消除一个Block在第i行的方块的样式，并把在这一行的所有Chunk加上一个销毁标记。</p><h3 id="checkFullLines"><a href="#checkFullLines" class="headerlink" title="checkFullLines"></a>checkFullLines</h3><p>消行操作核心方法。首先检测需要消除的行，并直接调用crashLine方法进行消除，将行数存入一个数组craseLines中，然后调用clearStatic清除static_blocks所有的方块，然后从上到下一行一行进行shiftDown，消除了N行，shiftDown了N次后，调用unClearStatic显示剩下的方块。这里在显示方块的函数draw中有一个小细节：带有销毁标记的Chunk不去显示，这样就可以保证消掉的行不会再在主面板中出现。</p><p>###########<br>再后来就是一些游戏设置或者方块样式上的问题了，方块Block的样式是参考网络上的方法，通过border和box-shadow可以设置出一个很有立体感的方块模型，再加上圆角属性border-radius可以做出更加有意思的方块模型（border-radius设置为50%即为圆形）。然后就是加了一个切换背景的按钮和一个audio标签。<br>目前也就做到这个程度，先记这么多吧。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近真是忙成孙子热成狗的节奏，不过好在这两天下了点小雨。。。白天当然继续还是做好自己的本分工作——导师的廉价劳动力，晚上在搞一个传说中的一个叫‘俄罗斯方块’的游戏。当我开始想用这个练练手的时候，感觉这个也忒简单了吧，小学就能玩得很6的东西，然而如果书做起来对于我这种前端菜鸟来说，使用JS完成一个俄罗斯方块并不是太顺利。我现在突然有点佩服当年闲得蛋疼想出了这个游戏的那个俄罗斯人&lt;a href=&quot;http://baike.baidu.com/view/2154504.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿列克谢·帕基特诺夫&lt;/a&gt;&lt;br&gt;扯远了，今天也算是初步完成，姑且整理一下思路。&lt;a href=&quot;http://blog.locusland.xyz/tetris/&quot;&gt;链接戳我&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="CSS" scheme="http://blog.locusland.xyz/tags/CSS/"/>
    
      <category term="HTML" scheme="http://blog.locusland.xyz/tags/HTML/"/>
    
      <category term="游戏" scheme="http://blog.locusland.xyz/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>yahoo优化35条</title>
    <link href="http://blog.locusland.xyz/2015/07/04/yahoo-35/"/>
    <id>http://blog.locusland.xyz/2015/07/04/yahoo-35/</id>
    <published>2015-07-04T12:55:59.000Z</published>
    <updated>2017-08-23T06:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Yahoo!的 Exceptional Performance团队为改善 Web性能带来最佳实践。他们为此进行了一系列的实验、开发了各种工具、写了大量的文章和博客并在各种会议上参与探讨。最佳实践的核心就是旨在提高网站性能。原版猛戳：Best Practices for Speeding Up Your Web Site，</p><p>Excetional Performance 团队总结出了一系列可以提高网站速度的方法。可以分为 7大类 35条。<br>包括内容 、服务器 、 CSS 、 JavaScript 、Cookie 、图片 、移动应用 ，七部分。 </p><a id="more"></a><p>一、内容部分</p><p>尽量减少 HTTP请求<br>减少 DNS查找<br>避免跳转<br>缓存 Ajxa<br>推迟加载<br>提前加载<br>减少 DOM元素数量<br>用域名划分页面内容<br>使 frame数量最少<br>避免 404错误</p><p>1、尽量减少 HTTP请求次数</p><p>   终端用户响应的时间中，有 80%用于下载各项内容。这部分时间包括下载页面中的图像、样式表、脚本、 Flash等。通过减少页面中的元素可以减少 HTTP请求的次数。这是提高网页速度的关键步骤。</p><p>  减少页面组件的方法其实就是简化页面设计。那么有没有一种方法既能保持页面内容的丰富性又能达到加快响应时间的目的呢？这里有几条减少HTTP请求次数同时又可能保持页面内容丰富的技术。</p><p>合并文件是通过把所有的脚本放到一个文件中来减少 HTTP请求的方法，如可以简单地把所有的 CSS文件都放入一个样式表中。当脚本或者样式表在不同页面中使用时需要做不同的修 改，这可能会相对麻烦点，但即便如此也要把这个方法作为改善页面性能的重要一步。</p><p>CSS Sprites是减少图像请求的有效方法。把所有的背景图像都放到一个图片文件中，然后通过 CSS的 background-image和 background-position属性来显示图片的不同部分；</p><p>图片地图是把多张图片整合到一张图片中。虽然文件的总体大小不会改变，但是可 以减少 HTTP请求次数。图片地图只有在图片的所有组成部分在页面中是紧挨在一起的时候才能 使用，如导航栏。确定图片的坐标和可能会比较繁琐且容易出错，同时使用图片地图导航也不具有可读性，因此不推荐这种方法；</p><p>内联图像是使用 data:URL scheme的方法把图像数据加载页面中。这可能会增加页面的大 小。把内联图像放到样式表（可缓存）中可以减少 HTTP请求同时又避免增加页面文件的大小。但是内联图像现在还没有得到主流浏览器的 支持。</p><p>  减少页面的 HTTP请求次数是你首先要做的一步。这是改进首次访问用户等待时间的最重要的方法。 如同 Tenni Theurer的他的博客 Browser Cahe Usage - Exposed!中所说， HTTP请求在无缓存情况下占去了 40%到 60%的响应时间。让那些初次访问你网站的人获得更加快速的体验吧！</p><p>2、减少 DNS查找次数</p><p>  域名系统（ DNS）提供了域名和 IP的对应关系，就像电话本中人名和他们的电话号码的关系一样。当你在浏览器地址栏中 输入 www.yahoo.com 时， DNS解析服务器就会返回这个域名对应的 IP地址。 DNS解析的过程同样也是需要时间的。一般情况下返回给定域名对应的 IP地址会花费 20到 120毫秒的时间。而且在这个过程中浏览器什么都不会做直到 DNS查找完毕。</p><p>   缓存 DNS查找可以改善页面性能。这种缓存需要一个特定的缓存服务器，这种服务器一般属于用户的 ISP提供商或者本地局域网控制，但是它同样会在用户使用的计算机上产生缓存。 DNS信息会保留在操作系统的 DNS缓存中（微软 Windows系统中 DNS Client Service）。大多数浏览器有独立于操作系统以外的自己的缓存。由于浏览器有自己的缓存记录，因此在一次请求中它不会受到操作系统的影响。</p><p>  Internet Explorer 默认情况下对 DNS查找记录的缓存时间为 30分钟，它在注册表中的键值为 DnsCacheTimeout。 Firefox对 DNS的查找记录缓存时间为 1分钟，它在配置文件中的选项为 network.dnsCacheExpiration（ Fasterfox把这个选项改为了 1小时）。</p><p>  当客户端中的 DNS缓存都为空时（浏览器和操作系统都为空）， DNS查找的次数和页面中主机名的数量相同。这其中包括页面中 URL、图片、脚本文件、样式表、Flash对象等包含的主机名。减少主机名的数量可以减少DNS查找次数。</p><p>  减少主机名的数量还可以减少页面中并行下载的数量。减少 DNS查找次数可以节省响应时间，但是减少并行下载却会增加响应时间。我的指导原则是 把这些页面中的内容分割成至少两部分但不超过四部分。这种结果就是在减少 DNS查找次数和保持较高程度并行下载两者之间的权衡了。</p><p>3、避免跳转</p><p>跳转是使用 301和 302代码实现的。下面是一个响应代码为 301的 HTTP头：</p><ul><li><p>HTTP/1.1 301 Moved Permanently</p></li><li><p>Location: <a href="http://example.com/newuri" target="_blank" rel="noopener">http://example.com/newuri</a></p></li><li><p>Content-Type: text/html</p><p>浏览器会把用户指向到 Location中指定的 URL。头文件中的所有信息在一次跳转中都是必需的，内容部分可以为空。不管他们的名 称， 301和 302响应都不会被缓存除非增加一个额外的头选项，如 Expires或者 Cache-Control来指定它缓存。 <meat>元素的刷新标签和JavaScript也可以实现 URL的跳转，但是如果你必须要跳转的时候，最好的方法就是使用标准的 3XXHTTP状态代码，这主要是为了确保“后退”按钮可以正确地使用。</meat></p></li></ul><p>  但是要记住跳转会降低用户体验。在用户和 HTML文档中间增加一个跳转，会拖延页面中所有元素的显示，因为在 HTML文件被加载前任何文件（图像、 Flash等）都不会被下载。</p><p>  有一种经常被网页开发者忽略却往往十分浪费响应时间的跳转现象。 这种现象发生在当 URL本该有斜杠（ /）却被忽略掉时。例如，当我们要访问 <a href="http://astrology.yahoo.com/astrology" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology</a> 时，实际上返回的是一个包含 301代码的跳转，它指向的是 <a href="http://astrology.yahoo.com/astrology/" target="_blank" rel="noopener">http://astrology.yahoo.com/astrology/</a>  （注意末尾的斜杠）。在 Apache服务器中可以使用 Alias 或者 mod_rewrite或者 the DirectorySlash来避免。</p><p>  连接新网站和旧网站是跳转功能经常被用到的另一种情况。这种情况 下往往要连接网站的不同内容然后根据用户的不同类型（如浏览器类型、用户账号所属类型）来进行跳转。使用跳转来实现两个网站的切换十分简单，需要的代码量 也不多。尽管使用这种方法对于开发者来说可以降低复杂程度，但是它同样降低用户体验。一个可替代方法就是如果两者在同一台服务器上时使用 Alias和 mod_rewrite和实现。如果是因为域名的不同而采用跳转，那么可以通过使用 Alias或者 mod_rewirte建立 CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。</p><p>4、可缓存的 AJAX</p><p>  Ajax 经常被提及的一个好处就是由于其从后台服务器传输信息 的异步性而为用户带来的反馈的即时性。但是，使用 Ajax并不能保证用户不会在等待异步的 JavaScript和 XML响应上花费时间。在很多应用中，用户是否需要等待响应取决于 Ajax如何来使用。例如，在一个基于 Web的 Email客户端中，用户必须等待 Ajax返回符合他们条件的邮件查询结果。记住一点，“异步”并不异味着“即时”，这 很重要。</p><p>  为了提高性能，优化 Ajax响应是很重要的。提高 Ajxa性能的措施中最重要的方法就是使响应具有可缓存性，具体的讨论可以查看 Add an Expires or a Cache-Control Header。 其它的几条规则也同样适用于Ajax：</p><ul><li><p>Gizp 压缩文件</p></li><li><p>减少 DNS查找次数</p></li><li><p>精简 JavaScript</p></li><li><p>避免跳转</p></li><li><p>配置 ETags</p></li></ul><p>  让我们来看一个例子：一个 Web2.0的 Email客户端会使用 Ajax来自动完成对用户地址薄的下载。如果用户在上次使用过 Email web应用程序后没有对地址薄作任何的修改，而且 Ajax响应通过 Expire或者 Cacke-Control头来实现缓存，那么就可以直接从上一次的缓存中读取地址薄 了。必须告知浏览器是使用缓存中的地址薄还是发送一个新的请求。这可以通过为读取地址薄的 Ajax URL增加一个含有上次编辑时间的时间戳来实现，例如， &amp;t=11900241612等。如果地址薄在上次下载后没有被编辑过，时间 戳就不变，则从浏览器的缓存中加载从而减少了一次 HTTP请求过程。如果用户修改过地址薄，时间戳就会用来确定新的 URL和缓存响应并不匹配，浏览器就会重要请求更新地址薄。</p><p>  即使你的 Ajxa响应是动态生成的，哪怕它只适用于一个用户，那么它也应该被缓存起来。这样做 可以使你的 Web2.0应用程序更加快捷。</p><p>5、推迟加载内容</p><p>  你可以仔细看一下你的网页，问问自己“哪些内容是页面呈现时 所必需首先加载的？哪些内容和结构可以稍后再加载？</p><p>  把整个过程按照 onload事件分隔成两部分， JavaScript是一个理想的选择。例如，如果你有用于实现拖放和动画的 JavaScript，那么它就以等待稍后加载，因为页面上的拖放元素是在初始化呈现 之后才发生的。其它的例如隐藏部分的内容（用户操作之后才显现的内容）和处于折叠部分的图像也可以推迟加载</p><p>  工具可以节省你的工作量： YUI Image Loader可以帮你推迟加载折叠部分的图片， YUI Get utility是包含 JS和 CSS的便捷方法。比如你可以打开 Firebug的 Net选项卡看一下 Yahoo的首页。</p><p>  当性能目标和其它网站开发实践一致时就会相得益彰。这种情况 下，通过程序提高网站性能的方法告诉我们，在支持 JavaScript的情况下，可以先去除用户体验，不过这要保证你的网站在没有 JavaScript也可以正常运行。在确定页面运行正常后，再加载脚本来实现如拖放和动画等更加花哨的效果。</p><p>6、预加载</p><p>  预加载和后加载看起来似乎恰恰相反，但实际上预加载是为了实 现另外一种目标。预加载是在浏览器空闲时请求将来可能会用到的页面内容（如图像、样式表和脚本）。使用这种方法，当用户要访问下一个页面时，页面中的内容 大部分已经加载到缓存中了，因此可以大大改善访问速度。</p><p>下面提供了几种预加载方法：</p><p>  无条件加载：触发 onload事件时，直接加载额外的页面内容。以 Google.com为例，你可以看一下它的 spirit image图像是怎样在 onload中加载的。这个 spirit image图像在 google.com主页中是不需要的，但是却可以在搜索结果页面中用到它。</p><p>有条件加载：根据用户的操作来有根据地判断用户下面可能去往的页面并相应的预 加载页面内容。在 search.yahoo.com中你可以看到如何在你输入内容时加载额外的页面内容。</p><p>  有预期的加载：载入重新设计过的页面时使用预加载。这种情况经常出现在页面经过重新设计后用户抱怨“新的页面看起来很酷，但是却比以前慢”。问题可能出在 用户对于你的旧站点建立了完整的缓存，而对于新站点却没有任何缓存内容。因此你可以在访问新站之前就加载一部内容来避免这种结果的出现。在你的旧站中利用 浏览器的空余时间加载新站中用到的图像的和脚本来提高访问速度。</p><p>7、减少 DOM元素数量</p><p>  一个复杂的页面意味着需要下载更多数据，同时也意味着 JavaScript遍历 DOM的效率越慢。比如当你增加一个事件句柄时在 500和 5000个 DOM元素中循环效果肯定是不一样的。</p><p>  大量的 DOM元素的存在意味着页面中有可以不用移除内容只需要替换元素标签就可以精简的部分。你在页面布局中使用表格了吗？你有没有仅仅为了布局而引入更多的 <div>元素呢？也许会存在一个适合或者在语意是更贴切的标签可以供你使用。</div></p><p>  YUI CSS utilities 可以给你的布局带来巨大帮助： grids.css可以帮你实现整体布局， font.css和 reset.css可以帮助你移除浏览器默认格式。它提供了一个重新审视你页面中标签 的机会，比如只有在语意上有意义时才使用 <div>，而不是因为它具有换行效果才使用它。</div></p><p>  DOM 元素数量很容易计算出来，只需要在 Firebug的控制台内输入：</p><p>document.getElementsByTagName(‘*’).length</p><p>  那么多少个 DOM元素算是多呢？这可以对照有很好标记使用的类似页面。比如 Yahoo!主页是一个内容非常多的页面，但是它只使用了 700个元素（ HTML标签）。</p><p>8、根据域名划分页面内容</p><p>  把页面内容划分成若干部分可以使你最大限度地实现平行下载。由于 DNS查找带来的影响你首先要确保你使用的域名数量在 2个到 4个之间。例如，你可以把用到的 HTML内容和动态内容放在 <a href="http://www.example.org/" target="_blank" rel="noopener">http://www.example.org/</a> 上，而把页面各种组件（图片、脚本、 CSS)分别存放在 statics1.example.org和 statics.example.org上。</p><p>你可在 Tenni Theurer和 Patty Chi合写的文章 Maximizing Parallel Downloads in the Carpool Lane找到更多相关信息。</p><p>9、使 iframe的数量最小</p><p>  ifrmae 元素可以在父文档中插入一个新的 HTML文档。了解 iframe的工作理然后才能更加有效地使用它，这一点很重要。</p><p><iframe>优点：</iframe></p><p>解决加载缓慢的第三方内容如图标和广告等的加载问题</p><p>Security sandbox</p><p>并行加载脚本</p><p><iframe>的缺点：</iframe></p><p>即时内容为空，加载也需要时间</p><p>会阻止页面加载</p><p>没有语意</p><p>10、不要出现 404错误</p><p>   HTTP 请求时间消耗是很大的，因此使用 HTTP请求来获得一个没有用处的响应（例如 404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。</p><p>  有些站点把 404错误响应页面改为“你是不是要找 <em>*</em>”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的 情况是指向外部 JavaScript的链接出现问题并返回 404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作 JavaScript代码来执行。</p><p>二、服务器部分</p><p>使用内容分发网络<br>为文件头指定Expires或Cache-Control<br>Gzip压缩文件内容<br>配置ETag<br>尽早刷新输出缓冲<br>使用GET来完成AJAX请求<br>避免空的图像来源</p><p>11、使用内容分发网络<br>  用户与你网站服务器的接近程度会影响响应时间的长短。把你的网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。但是首先我们应该做些什么呢？<br>  按地域布置网站内容的第一步并不是要尝试重新架构你的网站让他们在分发服务器上正常运行。根据应用的需求来改变网站结构，这可能会包括一些比较复杂的任 务，如在服务器间同步Session状态和合并数据库更新等。要想缩短用户和内容服务器的距离，这些架构步骤可能是不可避免的。<br>  要记住，在终端用户的响应时间中有80%到90%的响应时间用于下载图像、样式表、脚本、Flash等页面内容。这就是网站性能黄金守则。和重新设计你的 应用程序架构这样比较困难的任务相比，首先来分布静态内容会更好一点。这不仅会缩短响应时间，而且对于内容分发网络来说它更容易实现。<br>  内容分发网络（Content Delivery Network，CDN）是由一系列分散到各个不同地理位置上的Web服务器组成的，它提高了网站内容的传输速度。用于向用户传输内容的服务器主要是根据 和用户在网络上的靠近程度来指定的。例如，拥有最少网络跳数（network hops）和响应速度最快的服务器会被选定。<br>  一些大型的网络公司拥有自己的CDN，但是使用像Akamai Technologies，Mirror Image Internet，或者Limelight Networks这样的CDN服务成本却非常高。对于刚刚起步的企业和个人网站来说，可能没有使用CDN的成本预算，但是随着目标用户群的不断扩大和更加 全球化，CDN就是实现快速响应所必需的了。以Yahoo来说，他们转移到CDN上的网站程序静态内容节省了终端用户20%以上的响应时间。使用CDN是一个只需要相对简单地修改代码实现显著改善网站访问速度的方法。</p><p>12、为文件头指定Expires或Cache-Control<br>  这条守则包括两方面的内容：<br>对于静态内容：设置文件头过期时间Expires的值为“Never expire”（永不过期）<br>对于动态内容：使用恰当的Cache-Control文件头来帮助浏览器进行有条件的请求<br>  网页内容设计现在越来越丰富，这就意味着页面中要包含更多的脚本、样式表、图片和Flash。第一次访问你页面的用户就意味着进行多次的HTTP请求，但 是通过使用Expires文件头就可以使这样内容具有缓存性。它避免了接下来的页面访问中不必要的HTTP请求。Expires文件头经常用于图像文件， 但是应该在所有的内容都使用他，包括脚本、样式表和Flash等。<br>  浏览器（和代理）使用缓存来减少HTTP请求的大小和次数以加快页面访问速度。Web服务器在HTTP响应中使用Expires文件头来告诉客户端内容需 要缓存多长时间。下面这个例子是一个较长时间的Expires文件头，它告诉浏览器这个响应直到2010年4月15日才过期。<br>      Expires: Thu, 15 Apr 2010 20:00:00 GMT<br>  如果你使用的是Apache服务器，可以使用ExpiresDefault来设定相对当前日期的过期时间。下面这个例子是使用 ExpiresDefault来设定请求时间后10年过期的文件头：<br>      ExpiresDefault “access plus 10 years”<br>  要切记，如果使用了Expires文件头，当页面内容改变时就必须改变内容的文件名。依Yahoo!来说我们经常使用这样的步骤：在内容的文件名中加上版 本号，如yahoo_2.0.6.js。<br>  使用Expires文件头只有会在用户已经访问过你的网站后才会起作用。当用户首次访问你的网站时这对减少HTTP请求次数来说是无效的，因为浏览器的缓 存是空的。因此这种方法对于你网站性能的改进情况要依据他们“预缓存”存在时对你页面的点击频率（“预缓存”中已经包含了页面中的所有内容）。 Yahoo!建立了一套测量方法，我们发现所有的页面浏览量中有75~85%都有“预缓存”。通过使用Expires文件头，增加了缓存在浏览器中内容的 数量，并且可以在用户接下来的请求中再次使用这些内容，这甚至都不需要通过用户发送一个字节的请求。</p><p>13、Gzip压缩文件内容<br>  网络传输中的HTTP请求和应答时间可以通过前端机制得到显著改善。的确，终端用户的带宽、互联网提供者、与对等交换点的靠近程度等都不是网站开发者所能 决定的。但是还有其他因素影响着响应时间。通过减小HTTP响应的大小可以节省HTTP响应时间。<br>  从HTTP/1.1开始，web客户端都默认支持HTTP请求中有Accept-Encoding文件头的压缩格式：<br>      Accept-Encoding: gzip, deflate<br>  如果web服务器在请求的文件头中检测到上面的代码，就会以客户端列出的方式压缩响应内容。Web服务器把压缩方式通过响应文件头中的Content- Encoding来返回给浏览器。<br>      Content-Encoding: gzip<br>  Gzip是目前最流行也是最有效的压缩方式。这是由GNU项目开发并通过RFC 1952来标准化的。另外仅有的一个压缩格式是deflate，但是它的使用范围有限效果也稍稍逊色。<br>  Gzip大概可以减少70%的响应规模。目前大约有90%通过浏览器传输的互联网交换支持gzip格式。如果你使用的是Apache，gzip模块配置和 你的版本有关：Apache 1.3使用mod_zip，而Apache 2.x使用moflate。<br>  浏览器和代理都会存在这样的问题：浏览器期望收到的和实际接收到的内容会存在不匹配的现象。幸好，这种特殊情况随着旧式浏览器使用量的减少在减少。 Apache模块会通过自动添加适当的Vary响应文件头来避免这种状况的出现。<br>  服务器根据文件类型来选择需要进行gzip压缩的文件，但是这过于限制了可压缩的文件。大多数web服务器会压缩HTML文档。对脚本和样式表进行压缩同 样也是值得做的事情，但是很多web服务器都没有这个功能。实际上，压缩任何一个文本类型的响应，包括XML和JSON，都值得的。图像和PDF文件由于 已经压缩过了所以不能再进行gzip压缩。如果试图gizp压缩这些文件的话不但会浪费CPU资源还会增加文件的大小。<br>   Gzip压缩所有可能的文件类型是减少文件体积增加用户体验的简单方法。</p><p>14、配置ETag<br>  Entity tags（ETags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内 容”，包括图片、脚本、样式表等）。增加ETag为实体的验证提供了一个比使用“last-modified date（上次编辑时间）”更加灵活的机制。Etag是一个识别内容版本号的唯一字符串。唯一的格式限制就是它必须包含在双引号内。原始服务器通过含有 ETag文件头的响应指定页面内容的ETag。<br>      HTTP/1.1 200 OK<br>      Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT<br>      ETag: “10c24bc-4ab-457e1c1f”<br>      Content-Length: 12195<br>  稍后，如果浏览器要验证一个文件，它会使用If-None-Match文件头来把ETag传回给原始服务器。在这个例子中，如果ETag匹配，就会返回一 个304状态码，这就节省了12195字节的响应。      GET /i/yahoo.gif HTTP/1.1<br>      Host: us.yimg.com<br>      If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT<br>      If-None-Match: “10c24bc-4ab-457e1c1f”<br>      HTTP/1.1 304 Not Modified<br>  ETag的问题在于，它是根据可以辨别网站所在的服务器的具有唯一性的属性来生成的。当浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时 ETag就会不匹配，这种情况对于使用服务器组和处理请求的网站来说是非常常见的。默认情况下，Apache和IIS都会把数据嵌入ETag中，这会显著 减少多服务器间的文件验证冲突。<br>   Apache 1.3和2.x中的ETag格式为inode-size-timestamp。即使某个文件在不同的服务器上会处于相同的目录下，文件大小、权限、时间戳 等都完全相同，但是在不同服务器上他们的内码也是不同的。<br>  IIS 5.0和IIS 6.0处理ETag的机制相似。IIS中的ETag格式为Filetimestamp:ChangeNumber。用ChangeNumber来跟踪 IIS配置的改变。网站所用的不同IIS服务器间ChangeNumber也不相同。不同的服务器上的Apache和IIS即使对于完全相同的内容产生的 ETag在也不相同，用户并不会接收到一个小而快的304响应；相反他们会接收一个正常的200响应并下载全部内容。如果你的网站只放在一台服务器上，就 不会存在这个问题。但是如果你的网站是架设在多个服务器上，并且使用Apache和 IIS产生默认的ETag配置，你的用户获得页面就会相对慢一点，服务器会传输更多的内容，占用更多的带宽，代理也不会有效地缓存你的网站内容。即使你的 内容拥有Expires文件头，无论用户什么时候点击“刷新”或者“重载”按钮都会发送相应的GET请求。<br>   如果你没有使用ETag提供的灵活的验证模式，那么干脆把所有的ETag都去掉会更好。Last-Modified文件头验证是基于内容的时间戳的。去掉 ETag文件头会减少响应和下次请求中文件的大小。微软的这篇支持文稿讲述了如何去掉ETag。在Apache中，只需要在配置文件中简单添加下面一行代 码就可以了：<br>      FileETag none</p><p>15、尽早刷新输出缓冲<br>  当用户请求一个页面时，无论如何都会花费200到500毫秒用于后台组织HTML文件。在这期间，浏览器会一直空闲等待数据返回。在PHP中，你可以使用 flush()方法，它允许你把已经编译的好的部分HTML响应文件先发送给浏览器，这时浏览器就会可以下载文件中的内容（脚本等）而后台同时处理剩余的 HTML页面。这样做的效果会在后台烦恼或者前台较空闲时更加明显。<br>  输出缓冲应用最好的一个地方就是紧跟在<head>之后，因为HTML的头部分容易生成而且头部往往包含CSS和JavaScript文件，这样浏览器就可以在后台编译剩余HTML的同时并行下 载它们。 例子：</head></p><pre><code>... &lt;!-- css, js --&gt;    &lt;/head&gt;    &lt;?php flush(); ?&gt;    &lt;body&gt;... &lt;!-- content --&gt;</code></pre><p>为了证明使用这项技术的好处，Yahoo!搜索率先研究并完成了用户测试。</p><p>16、使用GET来完成AJAX请求<br>  Yahoo!Mail团队发现，当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数 据。因此使用GET最为恰当，因为它只需发送一个TCP包（除非你有很多cookie）。IE中URL的最大长度为2K，因此如果你要发送一个超过2K的 数据时就不能使用GET了。<br>  一个有趣的不同就是POST并不像GET那样实际发送数据。根据HTTP规范，GET意味着“获取”数据，因此当你仅仅获取数据时使用GET更加有意义 （从语意上讲也是如此），相反，发送并在服务端保存数据时使用POST。</p><p>除此之外，JavaScript和CSS也是我们页面中经常用到的内容，对它们的优化也提高网站性能的重要方面：</p><p>35、避免空的图像来源</p><p>一个src属性为空串的图像有两种情况：</p><p>1． 直接的HTML</p><p><img src=""></p><p>2． JavaScript</p><p>var img = new Image();<br>img.src = “”;</p><p>这两种情况都会引起同样的效果：浏览器会再次向你的服务器发出请求。</p><p>Internet Explorer 将向这个页面所在的目录发出一个请求<br>Safari and Chrome 将发出对这个页面的一个请求。<br>Firefox 3 和更早的版本所采取的动作和Safari and Chrome一样，但是 3.5版本 addressed this issue[bug 444931] and no longer sends a request.<br>Opera 不进行任何操作。<br>这个行为为何是不好的？</p><p>1、 发送大量突然的请求将使你的服务器宕机（Cripple your servers），尤其是每天有数百万访问量的页面。</p><p>2、 产生一个从未浏览过的页面将浪费服务器的计算周期（computing cycles）</p><p>3、 损坏用户数据。如果你在请求中追踪状态（以cookie或是其他的方式），你可能会损坏数据。即使这个图像请求并没有返回一个图像，所有的头被浏览器读取并接受，包括所有cookie。While the rest of the response is thrown away, the damage may already be done.</p><p>引起这种行为的根源在于浏览器中URI的解析方式。这种行为定义在RFC 3986 - Uniform Resource Identifiers.当一个空串作为一个URI时，它被认为一个相对URI（relative URI）并通过定义在section 5.2中的算法被解析。这个特例，一个空串，列在section 5.4当中。Firefox, Safari, and Chrome都是依据这一规格来解析空串，而Internet Explorer则不正确的解析这个串，符合更早的一个规范，RFC 2396 - Uniform Resource Identifiers (this was obsoleted by RFC 3986).所以技术上，浏览器都在做它们被期望所做的事情来解析relative URIs，问题是在这个范围，空串不是故意造成的。</p><p>HTML5 adds to the description of the tag’s src attribute to instruct browsers not to make an additional request in section 4.8.2:</p><p> The src attribute must be present, and must contain a valid URL referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted. If the base URI of the element is the same as the document’s address, then the src attribute’s value must not be the empty string.</p><p>非常希望浏览器在将来不会有这样的问题。不幸的是，没有为<script src=""> and <link href="">的条款。或许仍需要时间来做出调整以保证浏览器不会意外的实现这一行为。</p><p>这一规则是受雅虎JavaScript导师Nicolas C. Zakas启发。更新信息请参见Empty image src can destroy your site..</p><p>三、CSS部分</p><p>把样式表置于顶部<br>避免使用CSS表达式（Expression）<br>用<link>代替@import<br>避免使用滤镜</p><p>17、把样式表置于顶部<br>  在研究Yahoo!的性能表现时，我们发现把样式表放到文档的<head />内部似乎会加快页面的下载速度。这是因为把样式表放到<head />内会使页面有步骤的加载显示。<br>  注重性能的前端服务器往往希望页面有秩序地加载。同时，我们也希望浏览器把已经接收到内容尽可能显示出来。这对于拥有较多内容的页面和网速较慢的用户来说 特别重要。向用户返回可视化的反馈，比如进程指针，已经有了较好的研究并形成了正式文档。在我们的研究中HTML页面就是进程指针。当浏览器有序地加载文 件头、导航栏、顶部的logo等对于等待页面加载的用户来说都可以作为可视化的反馈。这从整体上改善了用户体验。<br>  把样式表放在文档底部的问题是在包括Internet Explorer在内的很多浏览器中这会中止内容的有序呈现。浏览器中止呈现是为了避免样式改变引起的页面元素重绘。用户不得不面对一个空白页面。<br>   HTML规范清楚指出样式表要放包含在页面的<head />区域内：“和<a />不同，<link />只能出现在文档的<head />区域内，尽管它可以多次使用它”。无论是引起白屏还是出现没有样式化的内容都不值得去尝试。最好的方案就是按照HTML规范在文 档<head />内加载你的样式表。</p><p>18、避免使用CSS表达式（Expression）<br>  CSS表达式是动态设置CSS属性的强大（但危险）方法。Internet Explorer从第5个版本开始支持CSS表达式。下面的例子中，使用CSS表达式可以实现隔一个小时切换一次背景颜色：<br>      background-color: expression( (new Date()).getHours()%2 ? “#B8D4FF” : “#F08A00” );<br>如上所示，expression中使用了JavaScript表达式。CSS属性根据JavaScript表达式的计算结果来设置。expression 方法在其它浏览器中不起作用，因此在跨浏览器的设计中单独针对Internet Explorer设置时会比较有用。<br>  表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给CSS表达式增加 一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到10000次以上的计算量。<br>  一个减少CSS表达式计算次数的方法就是使用一次性的表达式，它在第一次运行时将结果赋给指定的样式属性，并用这个属性来代替CSS表达式。如果样式属性 必须在页面周期内动态地改变，使用事件句柄来代替CSS表达式是一个可行办法。如果必须使用CSS表达式，一定要记住它们要计算成千上万次并且可能会对你 页面的性能产生影响。</p><p>19、用<link>代替@import<br>  前面的最佳实现中提到CSS应该放置在顶端以利于有序加载呈现。<br>  在IE中，页面底部@import和使用<link>作用是一样的，因此最好不要使用它。</p><p>20、避免使用滤镜<br>  IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的 呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。<br>  完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用 AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。</p><p>四、 JavaScript部分</p><p>把脚本置于页面底部<br>使用外部JavaScript和CSS<br>削减JavaScript和CSS<br>剔除重复脚本<br>减少DOM访问<br>开发智能事件处理程序</p><p>21、把脚本置于页面底部<br>  脚本带来的问题就是它阻止了页面的平行下载。HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个。如果你的图片放在多个主机名上，你可以在每个并行下载中同时下载2个以上的文件。但是当下载脚本 时，浏览器就不会同时下载其它文件了，即便是主机名不相同。<br>  在某些情况下把脚本移到页面底部可能不太容易。比如说，如果脚本中使用了document.write来插入页面内容，它就不能被往下移动了。这里可能还 会有作用域的问题。很多情况下，都会遇到这方面的问题。<br>  一个经常用到的替代方法就是使用延迟脚本。DEFER属性表明脚本中没有包含document.write，它告诉浏览器继续显示。不幸的 是，Firefox并不支持DEFER属性。在Internet Explorer中，脚本可能会被延迟但效果也不会像我们所期望的那样。如果脚本可以被延迟，那么它就可以移到页面的底部。这会让你的页面加载的快一点。</p><p>22、使用外部JavaScript和CSS<br>  很多性能规则都是关于如何处理外部文件的。但是，在你采取这些措施前你可能会问到一个更基本的问题：JavaScript和CSS是应该放在外部文件中呢 还是把它们放在页面本身之内呢？<br>  在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。内置在HTML文档中的JavaScript 和CSS则会在每次请求中随HTML文档重新下载。这虽然减少了HTTP请求的次数，却增加了HTML文档的大小。从另一方面来说，如果外部文件中的 JavaScript和CSS被浏览器缓存，在没有增加HTTP请求次数的同时可以减少HTML文档的大小。<br>  关键问题是，外部JavaScript和CSS文件缓存的频率和请求HTML文档的次数有关。虽然有一定的难度，但是仍然有一些指标可以一测量它。如果一 个会话中用户会浏览你网站中的多个页面，并且这些页面中会重复使用相同的脚本和样式表，缓存外部文件就会带来更大的益处。<br>  许多网站没有功能建立这些指标。对于这些网站来说，最好的坚决方法就是把JavaScript和CSS作为外部文件引用。比较适合使用内置代码的例外就是 网站的主页，如Yahoo!主页和My Yahoo!。主页在一次会话中拥有较少（可能只有一次）的浏览量，你可以发现内置JavaScript和CSS对于终端用户来说会加快响应时 间。<br>  对于拥有较大浏览量的首页来说，有一种技术可以平衡内置代码带来的HTTP请求减少与通过使用外部文件进行缓存带来的好处。其中一个就是在首页中内置 JavaScript和CSS，但是在页面下载完成后动态下载外部文件，在子页面中使用到这些文件时，它们已经缓存到浏览器了。</p><p>23、削减JavaScript和CSS<br>  精简是指从去除代码不必要的字符减少文件大小从而节省下载时间。消减代码时，所有的注释、不需要的空白字符（空格、换行、tab缩进）等都要去掉。在 JavaScript中，由于需要下载的文件体积变小了从而节省了响应时间。精简JavaScript中目前用到的最广泛的两个工具是JSMin和YUI Compressor。YUI Compressor还可用于精简CSS。<br>  混淆是另外一种可用于源代码优化的方法。这种方法要比精简复杂一些并且在混淆的过程更易产生问题。在对美国前10大网站的调查中发现，精简也可以缩小原来 代码体积的21%，而混淆可以达到25%。尽管混淆法可以更好地缩减代码，但是对于JavaScript来说精简的风险更小。<br>  除消减外部的脚本和样式表文件外，<script>和<style>代码块也可以并且应该进行消减。即使你用Gzip压缩过脚本 和样式表，精简这些文件仍然可以节省5%以上的空间。由于JavaScript和CSS的功能和体积的增加，消减代码将会获得益处。</p><p>24、剔除重复脚本<br>  在同一个页面中重复引用JavaScript文件会影响页面的性能。你可能会认为这种情况并不多见。对于美国前10大网站的调查显示其中有两家存在重复引 用脚本的情况。有两种主要因素导致一个脚本被重复引用的奇怪现象发生：团队规模和脚本数量。如果真的存在这种情况，重复脚本会引起不必要的HTTP请求和 无用的JavaScript运算，这降低了网站性能。<br>  在Internet Explorer中会产生不必要的HTTP请求，而在Firefox却不会。在Internet Explorer中，如果一个脚本被引用两次而且它又不可缓存，它就会在页面加载过程中产生两次HTTP请求。即时脚本可以缓存，当用户重载页面时也会产 生额外的HTTP请求。<br>  除增加额外的HTTP请求外，多次运算脚本也会浪费时间。在Internet Explorer和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。<br>  一个避免偶尔发生的两次引用同一脚本的方法是在模板中使用脚本管理模块引用脚本。在HTML页面中使用<script />标签引用脚本的最常见方法就是：<br>    <script type="text/javascript" src="menu_1.0.17.js"></script><br>在PHP中可以通过创建名为insertScript的方法来替代：<br>     &lt;?php insertScript(“menu.js”) ?&gt;<br>为了防止多次重复引用脚本，这个方法中还应该使用其它机制来处理脚本，如检查所属目录和为脚本文件名中增加版本号以用于Expire文件头等。</p><p>25、减少DOM访问<br>  使用JavaScript访问DOM元素比较慢，因此为了获得更多的应该页面，应该做到：<br>缓存已经访问过的有关元素<br>线下更新完节点之后再将它们添加到文档树中<br>避免使用JavaScript来修改页面布局<br>  有关此方面的更多信息请查看Julien Lecomte在YUI专题中的文章“高性能Ajax应该程序”。</p><p>26、开发智能事件处理程序<br>  有时候我们会感觉到页面反应迟钝，这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation（事件代理）是一种好方法了。如果你在一个div中有10个按钮，你只需要在div上附加一次事件句柄就可以了，而不用去为每一个按 钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。<br>  你同样也不用为了操作DOM树而等待onload事件的发生。你需要做的就是等待树结构中你要访问的元素出现。你也不用等待所有图像都加载完毕。<br>  你可能会希望用DOMContentLoaded事件来代替 事件应用程序中的onAvailable方法。<br>  有关此方面的更多信息请查看Julien Lecomte在YUI专题中的文章“高性能Ajax应该程序”。</p><p>图片和Coockie也是我们网站中几乎不可缺少组成部分，此外随着移动设备的流行，对于移动应用的优化也十分重要。这主要包括：</p><p>五、Coockie部分</p><p>减小Cookie体积<br>对于页面内容使用无coockie域名</p><p>27、减小Cookie体积<br>  HTTP coockie可以用于权限验证和个性化身份等多种用途。coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。因此 保持coockie尽可能的小以减少用户的响应时间十分重要。<br>有关更多信息可以查看Tenni Theurer和Patty Chi的文章“When the Cookie Crumbles”。这们研究中主要包括：<br>去除不必要的coockie</p><p>使coockie体积尽量小以减少对用户响应的影响<br>注意在适应级别的域名上设置coockie以便使子域名不受影响<br>设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。</p><p>28、对于页面内容使用无coockie域名<br>  当浏览器在请求中同时请求一张静态的图片和发送coockie时，服务器对于这些coockie不会做任何地使用。因此他们只是因为某些负面因素而创建的 网络传输。所有你应该确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容。<br>   如果你的域名是http://www.example.org/ ，你可以在static.example.org上存在静态内容。但是，如果你不是在http://www.example.org/ 上而是在顶级域名example.org设置了coockie，那么所有对于static.example.org的请求都包含coockie。在这种情 况下，你可以再重新购买一个新的域名来存在静态内容，并且要保持这个域名是无coockie的。Yahoo!使用的是ymig.com，YouTube使 用的是ytimg.com，Amazon使用的是images-anazon.com等等。<br>  使用无coockie域名存在静态内容的另外一个好处就是一些代理（服务器）可能会拒绝对coockie的内容请求进行缓存。一个相关的建议就是，如果你 想确定应该使用example.org还是http://www.example.org/ 作为你的一主页，你要考虑到coockie带来的影响。忽略掉www会使你除了把coockie设置到<em>.example.org（</em>是泛域名解析，代表 了所有子域名译者dudo注）外没有其它选择，因此出于性能方面的考虑最好是使用带有www的子域名并且在它上面设置coockie。</p><p>六、Image 部分</p><p>优化图像<br>优化CSS Spirite<br>不要在HTML中缩放图像<br>favicon.ico要小而且可缓存</p><p>29、优化图像<br>  设计人员完成对页面的设计之后，不要急于将它们上传到web服务器，这里还需要做几件事：<br>你可以检查一下你的GIF图片中图像颜色的数量是否和调色板规格一致。 使用imagemagick中下面的命令行很容易检查：<br>      identify -verbose image.gif<br>如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。<br>  尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。由于浏览器支持有限，设计者们往往不太乐意使用PNG格式的图片，不过 这都是过去的事情了。现在只有一个问题就是在真彩PNG格式中的alpha通道半透明问题，不过同样的，GIF也不是真彩格式也不支持半透明。因此GIF 能做到的，PNG（PNG8）同样也能做到（除了动画）。下面这条简单的命令可以 安全地把GIF格式转换为PNG格式：</p><pre><code>convert image.gif image.png</code></pre><p>“我们要说的是：给PNG一个施展身手的机会吧！”<br>在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如：<br>      pngcrush image.png -rem alla -reduce -brute result.png<br>在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息 （如EXIF信息）：<br>      jpegtran -copy none -optimize -perfect src.jpg dest.jpg</p><p>30、优化CSS Spirite<br>  在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小；<br>Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；<br>  便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。 100x100的图片为1万像素，而1000x1000就是100万像素。</p><p>31、不要在HTML中缩放图像<br>  不要为了在HTML中设置长宽而使用比实际需要大的图片。如果你需要：<br><img width="100" height="100" src="mycat.jpg" alt="My Cat"><br>那么你的图片（mycat.jpg）就应该是100x100像素而不是把一个500x500像素的图片缩小使用。</p><p>32、favicon.ico要小而且可缓存<br>  favicon.ico是位于服务器根目录下的一个图片文件。它是必定存在的，因为即使你不关心它是否有用，浏览器也会对它发出请求，因此最好不要返回一 个404 Not Found的响应。由于是在同一台服务器上，它每被请求一次coockie就会被发送一次。这个图片文件还会影响下载顺序，例如在IE中当你在 onload中请求额外的文件时，favicon会在这些额外内容被加载前下载。<br>  因此，为了减少favicon.ico带来的弊端，要做到：<br>文件尽量地小，最好小于1K<br>在适当的时候（也就是你不要打算再换favicon.ico的时候，因为更换新文件时不能对它进行重命名）为它设置Expires文件头。你可以很安全地 把Expires文件头设置为未来的几个月。你可以通过核对当前favicon.ico的上次编辑时间来作出判断。<br>Imagemagick可以帮你创建小巧的favicon。</p><p>七、 Mobile部分</p><p>保持单个内容小于25K<br>打包组件成复合文本</p><p>33、保持单个内容小于25K<br>  这条限制主要是因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重 要。<br>  查看更多信息，请参阅Wayne Shea和Tenni Theurer的文件“Performance Research, Part 5: iPhone Cacheability - Making it Stick”。</p><p>34、打包组件成复合文本<br>  把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组件（切记：HTTP请求是很奢侈的）。当你使用这条规 则时，首先要确定用户代理是否支持（iPhone就不支持）。</p><p>……（35、避免空的图像来源 在 二、服务器部分），</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Yahoo!的 Exceptional Performance团队为改善 Web性能带来最佳实践。他们为此进行了一系列的实验、开发了各种工具、写了大量的文章和博客并在各种会议上参与探讨。最佳实践的核心就是旨在提高网站性能。原版猛戳：Best Practices for Speeding Up Your Web Site，&lt;/p&gt;
&lt;p&gt;Excetional Performance 团队总结出了一系列可以提高网站速度的方法。可以分为 7大类 35条。&lt;br&gt;包括内容 、服务器 、 CSS 、 JavaScript 、Cookie 、图片 、移动应用 ，七部分。 &lt;/p&gt;
    
    </summary>
    
      <category term="综合" scheme="http://blog.locusland.xyz/categories/%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="CSS" scheme="http://blog.locusland.xyz/tags/CSS/"/>
    
      <category term="HTML" scheme="http://blog.locusland.xyz/tags/HTML/"/>
    
      <category term="web优化" scheme="http://blog.locusland.xyz/tags/web%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>String对象扩展</title>
    <link href="http://blog.locusland.xyz/2015/07/01/string-extend/"/>
    <id>http://blog.locusland.xyz/2015/07/01/string-extend/</id>
    <published>2015-07-01T11:39:06.000Z</published>
    <updated>2017-08-23T06:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS String对象的一些扩展：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">******************************************</span><br><span class="line">字符串函数扩充                                </span><br><span class="line">******************************************</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//去除左边的空格</span><br><span class="line">===========================================</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">String.prototype.LTrim = function()</span><br><span class="line">&#123;</span><br><span class="line">return this.replace(/(^\s*)/g, &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//去除右边的空格</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.Rtrim = function()</span><br><span class="line">&#123;</span><br><span class="line">return this.replace(/(\s*$)/g, &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//去除前后空格</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.Trim = function()</span><br><span class="line">&#123;</span><br><span class="line">return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//得到左边的字符串</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.Left = function(len)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(isNaN(len)||len==null)</span><br><span class="line">&#123;</span><br><span class="line">len = this.length;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(parseInt(len)&lt;0||parseInt(len)&gt;this.length)</span><br><span class="line">&#123;</span><br><span class="line">len = this.length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return this.substr(0,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//得到右边的字符串</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.Right = function(len)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(isNaN(len)||len==null)</span><br><span class="line">&#123;</span><br><span class="line">len = this.length;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(parseInt(len)&lt;0||parseInt(len)&gt;this.length)</span><br><span class="line">&#123;</span><br><span class="line">len = this.length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return this.substring(this.length-len,this.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//得到中间的字符串,注意从0开始</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.Mid = function(start,len)</span><br><span class="line">&#123;</span><br><span class="line">return this.substr(start,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//在字符串里查找另一字符串:位置从0开始</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.InStr = function(str)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(str==null)</span><br><span class="line">&#123;</span><br><span class="line">str = &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return this.indexOf(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//在字符串里反向查找另一字符串:位置0开始</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.InStrRev = function(str)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(str==null)</span><br><span class="line">&#123;</span><br><span class="line">str = &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return this.lastIndexOf(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//计算字符串打印长度</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.LengthW = function()</span><br><span class="line">&#123;</span><br><span class="line">return this.replace(/[^\x00-\xff]/g,&quot;**&quot;).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是正确的IP地址</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.isIP = function()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">var reSpaceCheck = /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/;</span><br><span class="line"></span><br><span class="line">if (reSpaceCheck.test(this))</span><br><span class="line">&#123;</span><br><span class="line">this.match(reSpaceCheck);</span><br><span class="line">if (RegExp.$1 &lt;= 255 &amp;&amp; RegExp.$1 &gt;= 0</span><br><span class="line">&amp;&amp; RegExp.$2 &lt;= 255 &amp;&amp; RegExp.$2 &gt;= 0</span><br><span class="line">&amp;&amp; RegExp.$3 &lt;= 255 &amp;&amp; RegExp.$3 &gt;= 0</span><br><span class="line">&amp;&amp; RegExp.$4 &lt;= 255 &amp;&amp; RegExp.$4 &gt;= 0)</span><br><span class="line">&#123;</span><br><span class="line">return true;    </span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是正确的长日期</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.isLongDate = function()</span><br><span class="line">&#123;</span><br><span class="line">var r = this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;).match(/^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;) (\d&#123;1,2&#125;):(\d&#123;1,2&#125;):(\d&#123;1,2&#125;)$/);</span><br><span class="line">if(r==null)</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">var d = new Date(r[1], r[3]-1,r[4],r[5],r[6],r[7]);</span><br><span class="line">return (d.getFullYear()==r[1]&amp;&amp;(d.getMonth()+1)==r[3]&amp;&amp;d.getDate()==r[4]&amp;&amp;d.getHours()==r[5]&amp;&amp;d.getMinutes()==r[6]&amp;&amp;d.getSeconds()==r[7]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是正确的短日期</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.isShortDate = function()</span><br><span class="line">&#123;</span><br><span class="line">var r = this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;).match(/^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;)$/);</span><br><span class="line">if(r==null)</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">var d = new Date(r[1], r[3]-1, r[4]);</span><br><span class="line">return (d.getFullYear()==r[1]&amp;&amp;(d.getMonth()+1)==r[3]&amp;&amp;d.getDate()==r[4]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是正确的日期</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.isDate = function()</span><br><span class="line">&#123;</span><br><span class="line">return this.isLongDate()||this.isShortDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是手机</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.isMobile = function()</span><br><span class="line">&#123;</span><br><span class="line">return /^0&#123;0,1&#125;13[0-9]&#123;9&#125;$/.test(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是邮件</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.isEmail = function()</span><br><span class="line">&#123;</span><br><span class="line">return /^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/.test(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是邮编(中国)</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">String.prototype.isZipCode = function()</span><br><span class="line">&#123;</span><br><span class="line">return /^[\\d]&#123;6&#125;$/.test(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是有汉字</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.existChinese = function()</span><br><span class="line">&#123;</span><br><span class="line">//[\u4E00-\u9FA5]為漢字﹐[\uFE30-\uFFA0]為全角符號</span><br><span class="line">return /^[\x00-\xff]*$/.test(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是合法的文件名/目录名</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.isFileName = function()</span><br><span class="line">&#123;</span><br><span class="line">return !/[\\\/\*\?\|:&quot;&lt;&gt;]/g.test(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是有效链接</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.isUrl = function()</span><br><span class="line">&#123;</span><br><span class="line">return /^http[s]?:\/\/([\w-]+\.)+[\w-]+([\w-./?%&amp;=]*)?$/i.test(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是有效的身份证(中国)</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.isIDCard = function()</span><br><span class="line">&#123;</span><br><span class="line">var iSum=0;</span><br><span class="line">var info=&quot;&quot;;</span><br><span class="line">var sId = this;</span><br><span class="line"></span><br><span class="line"> var aCity=&#123;11:&quot;北京&quot;,12:&quot;天津&quot;,13:&quot;河北&quot;,14:&quot;山西&quot;,15:&quot;内蒙古&quot;,21:&quot;辽宁&quot;,22:&quot;吉林&quot;,23:&quot;黑龙 江&quot;,31:&quot;上海&quot;,32:&quot;江苏&quot;,33:&quot;浙江&quot;,34:&quot;安徽&quot;,35:&quot;福建&quot;,36:&quot;江西&quot;,37:&quot;山东&quot;,41:&quot;河南&quot;,42:&quot;湖 北&quot;,43:&quot;湖南&quot;,44:&quot;广东&quot;,45:&quot;广西&quot;,46:&quot;海南&quot;,50:&quot;重庆&quot;,51:&quot;四川&quot;,52:&quot;贵州&quot;,53:&quot;云南&quot;,54:&quot;西藏&quot;,61:&quot;陕西&quot;,62:&quot;甘肃&quot;,63:&quot;青海&quot;,64:&quot;宁夏&quot;,65:&quot;新疆&quot;,71:&quot;台湾&quot;,81:&quot;香港&quot;,82:&quot;澳门&quot;,91:&quot;国外&quot;&#125;;</span><br><span class="line"></span><br><span class="line">if(!/^\d&#123;17&#125;(\d|x)$/i.test(sId))</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">sId=sId.replace(/x$/i,&quot;a&quot;);</span><br><span class="line">//非法地区</span><br><span class="line">if(aCity[parseInt(sId.substr(0,2))]==null)</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sBirthday=sId.substr(6,4)+&quot;-&quot;+Number(sId.substr(10,2))+&quot;-&quot;+Number(sId.substr(12,2));</span><br><span class="line"></span><br><span class="line">var d=new Date(sBirthday.replace(/-/g,&quot;/&quot;))</span><br><span class="line"></span><br><span class="line">//非法生日</span><br><span class="line">if(sBirthday!=(d.getFullYear()+&quot;-&quot;+ (d.getMonth()+1) + &quot;-&quot; + d.getDate()))</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">for(var i = 17;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">iSum += (Math.pow(2,i) % 11) * parseInt(sId.charAt(17 - i),11);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(iSum%11!=1)</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是有效的电话号码(中国)</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.isPhoneCall = function()</span><br><span class="line">&#123;</span><br><span class="line">return /(^[0-9]&#123;3,4&#125;\-[0-9]&#123;3,8&#125;$)|(^[0-9]&#123;3,8&#125;$)|(^\([0-9]&#123;3,4&#125;\)[0-9]&#123;3,8&#125;$)|(^0&#123;0,1&#125;13[0-9]&#123;9&#125;$)/.test(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是数字</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.isNumeric = function(flag)</span><br><span class="line">&#123;</span><br><span class="line">//验证是否是数字</span><br><span class="line">if(isNaN(this))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch(flag)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">case null:        //数字</span><br><span class="line">case &quot;&quot;:</span><br><span class="line">return true;</span><br><span class="line">case &quot;+&quot;:        //正数</span><br><span class="line">return                /(^\+?|^\d?)\d*\.?\d+$/.test(this);</span><br><span class="line">case &quot;-&quot;:        //负数</span><br><span class="line">return                /^-\d*\.?\d+$/.test(this);</span><br><span class="line">case &quot;i&quot;:        //整数</span><br><span class="line">return                /(^-?|^\+?|\d)\d+$/.test(this);</span><br><span class="line">case &quot;+i&quot;:        //正整数</span><br><span class="line">return                /(^\d+$)|(^\+?\d+$)/.test(this);                       </span><br><span class="line">case &quot;-i&quot;:        //负整数</span><br><span class="line">return                /^[-]\d+$/.test(this);</span><br><span class="line">case &quot;f&quot;:        //浮点数</span><br><span class="line">return                /(^-?|^\+?|^\d?)\d*\.\d+$/.test(this);</span><br><span class="line">case &quot;+f&quot;:        //正浮点数</span><br><span class="line">return                /(^\+?|^\d?)\d*\.\d+$/.test(this);                       </span><br><span class="line">case &quot;-f&quot;:        //负浮点数</span><br><span class="line">return                /^[-]\d*\.\d$/.test(this);               </span><br><span class="line">default:        //缺省</span><br><span class="line">return true;                       </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//是否是颜色(#FFFFFF形式)</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.IsColor = function()</span><br><span class="line">&#123;</span><br><span class="line">var temp        = this;</span><br><span class="line">if (temp==&quot;&quot;) return true;</span><br><span class="line">if (temp.length!=7) return false;</span><br><span class="line">return (temp.search(/\#[a-fA-F0-9]&#123;6&#125;/) != -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//转换成全角</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.toCase = function()</span><br><span class="line">&#123;</span><br><span class="line">var tmp = &quot;&quot;;</span><br><span class="line">for(var i=0;i&lt;this.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(this.charCodeAt(i)&gt;0&amp;&amp;this.charCodeAt(i)&lt;255)</span><br><span class="line">&#123;</span><br><span class="line">tmp += String.fromCharCode(this.charCodeAt(i)+65248);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">tmp += String.fromCharCode(this.charCodeAt(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//对字符串进行Html编码</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.toHtmlEncode = function()</span><br><span class="line">&#123;</span><br><span class="line">var str = this;</span><br><span class="line"></span><br><span class="line">str=str.replace(/&amp;/g,&quot;&amp;amp;&quot;);</span><br><span class="line">str=str.replace(/&lt;/g,&quot;&amp;lt;&quot;);</span><br><span class="line">str=str.replace(/&gt;/g,&quot;&amp;gt;&quot;);</span><br><span class="line">str=str.replace(/\&apos;/g,&quot;&amp;apos;&quot;);</span><br><span class="line">str=str.replace(/\&quot;/g,&quot;&amp;quot;&quot;);</span><br><span class="line">str=str.replace(/\n/g,&quot;&lt;br&gt;&quot;);</span><br><span class="line">str=str.replace(/\ /g,&quot;&amp;nbsp;&quot;);</span><br><span class="line">str=str.replace(/\t/g,&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);</span><br><span class="line"></span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">===========================================</span><br><span class="line">//转换成日期</span><br><span class="line">===========================================</span><br><span class="line">*/</span><br><span class="line">String.prototype.toDate = function()</span><br><span class="line">&#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">return new Date(this.replace(/-/g, &quot;\/&quot;));</span><br><span class="line">&#125;</span><br><span class="line">catch(e)</span><br><span class="line">&#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS String对象的一些扩展：&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>kata_duplicates</title>
    <link href="http://blog.locusland.xyz/2015/06/28/kata-duplicates/"/>
    <id>http://blog.locusland.xyz/2015/06/28/kata-duplicates/</id>
    <published>2015-06-28T13:26:36.000Z</published>
    <updated>2017-09-14T07:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续刷题ING。。。<br>Description:</p><p>Given an array, find the duplicates in that array, and return a new array of those duplicates.</p><p>Note: numbers and their corresponding string representations should not be treated as duplicates (i.e., ‘1’ !== 1).</p><p>很简单的一道题，给定一个数组，返回数组中的duplicates，也就是在这个数组中出现次数大于1的元素组成的数组。。。思路就是像数组去重那样遍历数组，但数组去重遇到之前存在的元素就跳过去，这里需要把这个元素放到结果中，而且以后再遇到这个元素就不做处理了。就是说返回的结果中不能有重复元素~思路就这样，但我发现同样的思路，我和大神们的写法居然差了这么多 - -果然还是不熟练啊<br><a id="more"></a><br>我的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function duplicates(arr) &#123;</span><br><span class="line">  //TODO: return the array of duplicates from arr</span><br><span class="line">  var result = [];</span><br><span class="line">  var temp = [];</span><br><span class="line">  for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(temp.indexOf(arr[i])&lt;0) temp.push(arr[i]);</span><br><span class="line">    else if(result.indexOf(arr[i])&lt;0) result.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大神写法：</p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function duplicates(arr) &#123;</span><br><span class="line">  for (var dup = [], i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    var n = arr[i]</span><br><span class="line">    if (arr.indexOf(n, i + 1) &gt;= 0 &amp;&amp; dup.indexOf(n) &lt; 0) &#123;</span><br><span class="line">      dup.push(n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  return dup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function duplicates(arr) &#123;</span><br><span class="line">  return arr.filter(function(v, i) &#123;return arr.indexOf(v) != i &amp;&amp; arr.lastIndexOf(v) == i;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function duplicates(arr)&#123;</span><br><span class="line">  return arr.reduce(function(a, v, i)&#123;</span><br><span class="line">    return (arr.indexOf(v) != i &amp;&amp; a.indexOf(v) == -1) ? a.concat(v) : a;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function duplicates(arr) &#123;</span><br><span class="line">  var output = [];</span><br><span class="line">  for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (arr.slice(i+1).indexOf(arr[i]) &gt; -1 &amp;&amp; output.indexOf(arr[i]) &lt; 0) output.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实思路都是一样的，不过仔细想想，在很多情况下，数组那几个迭代方法在处理数组的时候要比for要来得方便得多，所以说还得慢慢熟练啊。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续刷题ING。。。&lt;br&gt;Description:&lt;/p&gt;
&lt;p&gt;Given an array, find the duplicates in that array, and return a new array of those duplicates.&lt;/p&gt;
&lt;p&gt;Note: numbers and their corresponding string representations should not be treated as duplicates (i.e., ‘1’ !== 1).&lt;/p&gt;
&lt;p&gt;很简单的一道题，给定一个数组，返回数组中的duplicates，也就是在这个数组中出现次数大于1的元素组成的数组。。。思路就是像数组去重那样遍历数组，但数组去重遇到之前存在的元素就跳过去，这里需要把这个元素放到结果中，而且以后再遇到这个元素就不做处理了。就是说返回的结果中不能有重复元素~思路就这样，但我发现同样的思路，我和大神们的写法居然差了这么多 - -果然还是不熟练啊&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>kata_uniqueinorder</title>
    <link href="http://blog.locusland.xyz/2015/06/27/kata_uniqueinorder/"/>
    <id>http://blog.locusland.xyz/2015/06/27/kata_uniqueinorder/</id>
    <published>2015-06-27T06:07:48.000Z</published>
    <updated>2017-09-14T07:43:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>据说7，8月就进入校招内推阶段，而9月就开始进行大规模校招了。。。最近开始刷题，目的就是熟练JS。。。正好把一些自己觉得不错的题（主要应该是解法）记录下来~~~<br>废话不说了直接上题：<br><a id="more"></a></p><p>######<br>Description:</p><p>Implement the function unique_in_order which takes as argument a sequence and returns a list of items without any elements with the same value next to each other and preserving the original order of elements.</p><p>For example:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniqueInOrder(<span class="string">'AAAABBBCCDAABBB'</span>) == [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>]</span><br><span class="line">uniqueInOrder(<span class="string">'ABBCcAD'</span>)         == [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'c'</span>, <span class="string">'A'</span>, <span class="string">'D'</span>]</span><br><span class="line">uniqueInOrder([1,2,2,3,3])       == [1,2,3]</span><br></pre></td></tr></table></figure></p><p>######</p><p>题目要求很简单，一个字符串或者数组，去重。。。但不是常规的去重，只是去掉相邻元素中重复的变成一个，然后返回去重后的数组。。。思路也很简单其实，新建一个结果数组，然后就是遍历一下，看后一个是否与前一个相同，如果不同就push进去直到结束。。。<br>当然我就是这么想的，而且结果也通过了，不过要针对字符串和数组区分一下，然后就是要注意一下，如果输入的是一个空字符串或者空数组，就直接返回一个空数组。。。当然我写在这里不是为了记录这些的，自己写的也就不粘上来献丑了。。。<br>记录一些大神们的写法：</p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var uniqueInOrder = function (iterable)</span><br><span class="line">&#123;</span><br><span class="line">  return [].filter.call(iterable, (function (a, i) &#123; return iterable[i - 1] !== a &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接让参数调用数组的filter方法，这个方法会针对当前数组的每一项执行它参数的callback函数，返回这个callback函数的结果为true的数组。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function uniqueInOrder(it) &#123;</span><br><span class="line">  var result = []</span><br><span class="line">  var last</span><br><span class="line">  </span><br><span class="line">  for (var i = 0; i &lt; it.length; i++) &#123;</span><br><span class="line">    if (it[i] !== last) &#123;</span><br><span class="line">      result.push(last = it[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个跟我的思路很像了，不过用了一个last来存取上一个变量，而且用[]加下标是可以针对字符串使用的，所以说少了一些不必要的判断。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var uniqueInOrder=function(iterable)&#123;</span><br><span class="line"> </span><br><span class="line">  iterable = (Array.isArray(iterable)) ? iterable : iterable.split(&apos;&apos;)</span><br><span class="line">  return iterable.filter(function(val,i,a) &#123;return val != a[i+1] &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理同1…</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var uniqueInOrder=function(iterable) &#123;</span><br><span class="line">  var input = iterable.replace ? iterable : iterable.join(&apos;&apos;);</span><br><span class="line">  var type = typeof iterable[0] === &quot;number&quot; ? Number : String;</span><br><span class="line">  return input.replace(/(\w)\1*/g,&quot;$1&quot;).split(&apos;&apos;).map(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总是会有大神喜欢用正则表达式来解决问题，这个自己参悟吧，其实懂了正则就很好理解，不过对于我这种菜鸟来说很难想出来这个思路。。。囧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;据说7，8月就进入校招内推阶段，而9月就开始进行大规模校招了。。。最近开始刷题，目的就是熟练JS。。。正好把一些自己觉得不错的题（主要应该是解法）记录下来~~~&lt;br&gt;废话不说了直接上题：&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>初探nodebb</title>
    <link href="http://blog.locusland.xyz/2015/06/17/nodebb/"/>
    <id>http://blog.locusland.xyz/2015/06/17/nodebb/</id>
    <published>2015-06-17T14:07:16.000Z</published>
    <updated>2017-09-14T07:43:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>偶然发现了NodeBB这个东东~~~不得不承认，就目前的形势来看，node已经可以在后台独当一面了，至少我是这么认为的。。。CNode社区就足以证明这一点。这个NodeBB也是个社区搭建框架，而且看起来灰常强大，而卧搭建好之后事实证明确实如此。<br>废话不多说，这里我把搭建过程和其中遇到的问题都记录一下…说不定以后会用得上。</p><a id="more"></a><p>好吧，首先必须承认，最开始我是打算在Windows系统上去弄这货，但是遇到各种各样奇葩的问题，后来去NodeBB的论坛上，好多人也都反应最新版本的nodebb在windows上并不是能很好的搭建，于是乎转战Ubuntu了。</p><h3 id="安装必备软件包"><a href="#安装必备软件包" class="headerlink" title="安装必备软件包"></a>安装必备软件包</h3><p>当然，系统必须有一些必备的软件包，首先还是必须要有git，然后安装一些nodebb所需的基本包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git nodejs nodejs-legacy npm redis-server imagemagick build-essential</span><br></pre></td></tr></table></figure><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>接下来，如果没有装node的话，需要安装一个合适版本的node，这里不一定是安装最新版本，而是一个合适的稳定版本,可以使用 <code>node –version</code> 来查看当前node版本，如果想要安装node.js v0.11 使用这个ppa:chris-lea/node.js-devel即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:chris-lea/node.js</span><br><span class="line">$ sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade</span><br></pre></td></tr></table></figure><h3 id="安装mongoDB"><a href="#安装mongoDB" class="headerlink" title="安装mongoDB"></a>安装mongoDB</h3><p>然后，这个社区目前使用的数据库是redis或者是mongoDB，就我个人而言，对于mongoDB更熟悉一些，所以我是基于mongoDB搭建的,那么首先必须在系统中安装mongoDB：<br>这里上个链接吧:<a href="http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/" target="_blank" rel="noopener">ubuntu下安装mongoDB</a></p><h3 id="克隆nodebb到本地"><a href="#克隆nodebb到本地" class="headerlink" title="克隆nodebb到本地"></a>克隆nodebb到本地</h3><p>安装好数据库之后，就可以从github上把nodebb的源码clone到本地了（nodebb目前还在完善之中，我是用的这个版本，可以根据需要选择clone哪个版本，如果不加需求就是clone最新版本了）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b v0.7.x https://github.com/NodeBB/NodeBB.git nodebb</span><br></pre></td></tr></table></figure><h3 id="安装nodebb依赖模块"><a href="#安装nodebb依赖模块" class="headerlink" title="安装nodebb依赖模块"></a>安装nodebb依赖模块</h3><p>然后进入到目标文件夹，安装nodebb的依赖模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> nodebb</span><br><span class="line">$ npm install --production</span><br></pre></td></tr></table></figure><p>在这里，最开始我是遇到了一些问题，就是node-gyp rebuild的过程巨慢无比，老是在这里卡住：<a href="http://www.bubuko.com/infodetail-827600.html" target="_blank" rel="noopener">我是解决方法链接</a></p><h3 id="为用户建立数据库"><a href="#为用户建立数据库" class="headerlink" title="为用户建立数据库"></a>为用户建立数据库</h3><p>之后需要新建一个mongoDB数据库，来存储用户数据：<br>首先进入mongo命令行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mongo</span><br></pre></td></tr></table></figure><p>创建一个名字为nodebb的数据库（如果没有名为nodebb数据库，use命令会自动创建该数据库并切换到该数据库）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; use nodebb</span><br></pre></td></tr></table></figure><p>对于mongoDB2.6.X版本（nodebb对于mongoDB的版本为2.6.0以上，密码自定）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.createUser( &#123; user: <span class="string">"nodebb"</span>, <span class="built_in">pwd</span>: <span class="string">"&lt;Enter in a secure password&gt;"</span>, roles: [ <span class="string">"readWrite"</span> ] &#125; )</span><br></pre></td></tr></table></figure></p><p>这样就在名为nodebb的数据库中建立了一个名字为nodebb的用户，具有读写权限。<br>接下来为了使其权限可用，需要对mongoDB进行一下小小的配置：找到/etc/mongod.conf文件，里面有一个“#auth = true”的注释，将注释“#”去掉（具体方法可以用gedit命令或者nano等），然后重启mongoDB:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service mongod restart</span></span><br></pre></td></tr></table></figure><p>###配置nodebb<br>进入nodebb目录对其进行配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/nodebb</span><br><span class="line">$ node app --setup</span><br></pre></td></tr></table></figure><p>setup会让你输入一系列的东东- -一般来说，默认就好，如果你想用别的也可以改成自己的：<br>-首先是hostname和端口，我是默认了，可以按照自己的想法修改；<br>-然后是数据库，我选择mongo；<br>-将你的username改成nodebb，因为上面建立的那个nodebb的用户，或者在上面设置一个其他的名字，这里就填那个；<br>-将之前步骤的密码填到密码这里；<br>-数据库的名字改为nodebb（默认好像是0），或者是上文自己定义的数据库名字<br>-就酱！然后就可以start了:</p><p>###Running<br>开始：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./nodebb start</span><br></pre></td></tr></table></figure></p><p>停止：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./nodebb stop</span><br></pre></td></tr></table></figure></p><p>也可以npm start或者npm stop来实现。也可以用node app来跑，或者更高端一些的supervisor，grunt神马的：<a href="https://docs.nodebb.org/en/latest/running/index.html" target="_blank" rel="noopener">Running NodeBB</a></p><p>差不多这样就完成了，这货可以说是相当强大的一个东西了感觉，虽然还在完善之中。几乎实现了完整的后台设置页面，管理员可对论坛进行全方面管理。，像hexo一样，你可以根据自己的喜好去设计主题和皮肤。。。先写这么多吧- -</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶然发现了NodeBB这个东东~~~不得不承认，就目前的形势来看，node已经可以在后台独当一面了，至少我是这么认为的。。。CNode社区就足以证明这一点。这个NodeBB也是个社区搭建框架，而且看起来灰常强大，而卧搭建好之后事实证明确实如此。&lt;br&gt;废话不多说，这里我把搭建过程和其中遇到的问题都记录一下…说不定以后会用得上。&lt;/p&gt;
    
    </summary>
    
      <category term="综合" scheme="http://blog.locusland.xyz/categories/%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="node" scheme="http://blog.locusland.xyz/tags/node/"/>
    
  </entry>
  
</feed>
