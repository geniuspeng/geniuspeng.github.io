<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>牧羊少年的个人博客</title>
  
  <subtitle>welcome</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.locusland.xyz/"/>
  <updated>2018-02-08T07:48:25.905Z</updated>
  <id>http://blog.locusland.xyz/</id>
  
  <author>
    <name>牧羊少年</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue源码--深入模板渲染</title>
    <link href="http://blog.locusland.xyz/2018/02/07/vue-compile/"/>
    <id>http://blog.locusland.xyz/2018/02/07/vue-compile/</id>
    <published>2018-02-07T07:34:37.000Z</published>
    <updated>2018-02-08T07:48:25.905Z</updated>
    
    <content type="html"><![CDATA[<p>之前整理了vue的响应式原理，在这里有一点是一直很模糊的，就是何时去new一个watcher，当data变化时又如何通知视图去进行怎样的更新…这里面涉及到了模板渲染和虚拟DOM的diff以及更新操作。其实模板渲染过程在实际使用vue的过程可能并不需要太深理解，但就vue来说，这些底层思想可以更好地让我们理解这个框架，以及了解为什么Vue的API要如此设计…</p><a id="more"></a><p>上一次也提过，vue2+与vue1+的模板渲染过程完全不同，vue1使用的是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="noopener">DocumentFragment API</a>，具体就不介绍了（可以直接跳到MDN去了解），而vue2开始则使用了Virtual DOM，基于Virtual DOM，vue2支持了服务端渲染SSR，以及JSX语法。介绍渲染流程之前，先说明两个数据结构：抽象语法树AST，以及VNode。</p><h3 id="AST数据结构"><a href="#AST数据结构" class="headerlink" title="AST数据结构"></a>AST数据结构</h3><p>AST 的全称是 Abstract Syntax Tree（抽象语法树），是源代码的抽象语法结构的树状表现形式，计算机学科中编译原理的概念。而vue就是将模板代码映射为AST数据结构，进行语法解析。这里采用了flow的语法，<a href="https://flow.org/" target="_blank" rel="noopener">flow</a>是一个JS静态类型检查工具。</p><p>首先看一下 Vue 2.0 源码中 <a href="https://github.com/vuejs/vue/blob/v2.5.13/flow/compiler.js#L75-L172" target="_blank" rel="noopener">AST 数据结构</a> 的定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">declare type ASTNode = ASTElement | ASTText | ASTExpression</span><br><span class="line">declare type ASTElement = &#123; <span class="comment">// 有关元素的一些定义</span></span><br><span class="line">  type: <span class="number">1</span>;</span><br><span class="line">  tag: string;</span><br><span class="line">  attrsList: <span class="built_in">Array</span>&lt;&#123; <span class="attr">name</span>: string; value: string &#125;&gt;;</span><br><span class="line">  attrsMap: &#123; [key: string]: string | <span class="literal">null</span> &#125;;</span><br><span class="line">  parent: ASTElement | <span class="keyword">void</span>;</span><br><span class="line">  children: <span class="built_in">Array</span>&lt;ASTNode&gt;;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">declare type ASTExpression = &#123;</span><br><span class="line">  type: <span class="number">2</span>;</span><br><span class="line">  expression: string;</span><br><span class="line">  text: string;</span><br><span class="line">  tokens: <span class="built_in">Array</span>&lt;string | <span class="built_in">Object</span>&gt;;</span><br><span class="line">  <span class="keyword">static</span>?: boolean;</span><br><span class="line">  <span class="comment">// 2.4 ssr optimization</span></span><br><span class="line">  ssrOptimizability?: number;</span><br><span class="line">&#125;;</span><br><span class="line">declare type ASTText = &#123;</span><br><span class="line">  type: <span class="number">3</span>;</span><br><span class="line">  text: string;</span><br><span class="line">  <span class="keyword">static</span>?: boolean;</span><br><span class="line">  isComment?: boolean;</span><br><span class="line">  <span class="comment">// 2.4 ssr optimization</span></span><br><span class="line">  ssrOptimizability?: number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="VNODE数据结构"><a href="#VNODE数据结构" class="headerlink" title="VNODE数据结构"></a>VNODE数据结构</h3><p>VNODE就是vue中的虚拟dom节点，<a href="https://github.com/vuejs/vue/blob/v2.5.13/src/core/vdom/vnode.js#L31-L64" target="_blank" rel="noopener">VNODE 数据结构</a> 如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (</span><br><span class="line">  tag?: string,</span><br><span class="line">  data?: VNodeData,</span><br><span class="line">  children?: ?Array&lt;VNode&gt;,</span><br><span class="line">  text?: string,</span><br><span class="line">  elm?: Node,</span><br><span class="line">  context?: Component,</span><br><span class="line">  componentOptions?: VNodeComponentOptions,</span><br><span class="line">  asyncFactory?: Function</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">this</span>.tag = tag</span><br><span class="line">  <span class="keyword">this</span>.data = data</span><br><span class="line">  <span class="keyword">this</span>.children = children</span><br><span class="line">  <span class="keyword">this</span>.text = text</span><br><span class="line">  <span class="keyword">this</span>.elm = elm</span><br><span class="line">  <span class="keyword">this</span>.ns = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.context = context</span><br><span class="line">  <span class="keyword">this</span>.fnContext = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.fnOptions = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.fnScopeId = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">  <span class="keyword">this</span>.componentOptions = componentOptions</span><br><span class="line">  <span class="keyword">this</span>.componentInstance = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.raw = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">this</span>.isOnce = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">this</span>.asyncFactory = asyncFactory</span><br><span class="line">  <span class="keyword">this</span>.asyncMeta = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.isAsyncPlaceholder = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实DOM存在什么问题，为什么要用虚拟DOM</p><p>我们为什么不直接使用原生 DOM 元素，而是使用真实 DOM 元素的简化版 VNode，最大的原因就是 document.createElement 这个方法创建的真实 DOM 元素会带来性能上的损失。我们来看一个 document.createElement 方法的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> div) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开 console 运行一下上面的代码，会发现打印出来的属性多达 228 个，而这些属性有 90% 多对我们来说都是无用的。VNode 就是简化版的真实 DOM 元素，关联着真实的dom，比如属性elm，只包括我们需要的属性，并新增了一些在 diff 过程中需要使用的属性，例如 isStatic。</p><h3 id="模板渲染流程"><a href="#模板渲染流程" class="headerlink" title="模板渲染流程"></a>模板渲染流程</h3><p>先来一张图：<br><img src="https://geniuspeng.github.io/image-storage/blog/vue/vue-render.jpg" alt="vue渲染流程"></p><p>首先从<a href="https://github.com/vuejs/vue/blob/v2.1.10/src/entries/web-runtime-with-compiler.js#L14-L67" target="_blank" rel="noopener">$mount</a>开始，可以看到，mount其实就是拿到了html模板作为template，然后将这个template通过compileToFunctions方法编译成render函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (template) &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    mark(<span class="string">'compile'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; <span class="comment">//对获取到的template进行编译</span></span><br><span class="line">    shouldDecodeNewlines,</span><br><span class="line">    shouldDecodeNewlinesForHref,</span><br><span class="line">    delimiters: options.delimiters,</span><br><span class="line">    comments: options.comments</span><br><span class="line">  &#125;, <span class="keyword">this</span>)</span><br><span class="line">  options.render = render</span><br><span class="line">  options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    mark(<span class="string">'compile end'</span>)</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;<span class="keyword">this</span>._name&#125;</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么这个<a href="https://github.com/vuejs/vue/blob/v2.1.10/src/platforms/web/compiler/index.js#L36-L84" target="_blank" rel="noopener">compileToFunctions</a>做了什么呢？主要将 template 编译成 render 函数。首先读缓存，没有缓存就调用 compile 方法拿到 render 函数 的字符串形式，再通过 new Function 的方式生成 render 函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有缓存的话就直接在缓存里面拿</span></span><br><span class="line"><span class="keyword">const</span> key = options &amp;&amp; options.delimiters</span><br><span class="line">            ? <span class="built_in">String</span>(options.delimiters) + template</span><br><span class="line">            : template</span><br><span class="line"><span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> compiled = compile(template, options) <span class="comment">// compile 后面会详细讲</span></span><br><span class="line">res.render = makeFunction(compiled.render) <span class="comment">//通过 new Function 的方式生成 render 函数并缓存</span></span><br><span class="line"><span class="keyword">const</span> l = compiled.staticRenderFns.length</span><br><span class="line">res.staticRenderFns = <span class="keyword">new</span> <span class="built_in">Array</span>(l)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i])</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (cache[key] = res) <span class="comment">// 记录至缓存中</span></span><br></pre></td></tr></table></figure></p><p>现在我们具体看一下<a href="https://github.com/vuejs/vue/blob/v2.5.13/src/compiler/index.js" target="_blank" rel="noopener">compile</a>方法，上文中提到 compile 方法就是将 template 编译成 render 函数 的字符串形式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> AST = parse(template.trim(), options) <span class="comment">//1. parse</span></span><br><span class="line">  optimize(AST, options)  <span class="comment">//2.optimize</span></span><br><span class="line">  <span class="keyword">const</span> code = generate(AST, options) <span class="comment">//3.generate</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    AST,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数主要有三个步骤组成：parse，optimize 和 generate，分别输出一个包含 AST，staticRenderFns 的对象和 render函数 的字符串。</p><p><a href="https://github.com/vuejs/vue/blob/v2.5.13/src/compiler/parser/index.js" target="_blank" rel="noopener">parse</a> 函数，主要功能是将 template字符串解析成 AST,采用了 jQuery 作者 John Resig 的 HTML Parser。前面定义了ASTElement的数据结构，parse 函数就是将template里的结构（指令，属性，标签等）转换为AST形式存进ASTElement中，最后解析生成AST。</p><p><a href="https://github.com/vuejs/vue/blob/v2.5.13/src/compiler/optimizer.js#L21-L29" target="_blank" rel="noopener">optimize</a> 函数（src/compiler/optimizer.js）主要功能就是标记静态节点，为后面 patch 过程中对比新旧 VNode 树形结构做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。</p><p><a href="https://github.com/vuejs/vue/blob/v2.5.13/src/compiler/codegen/index.js#L40-L50" target="_blank" rel="noopener">generate</a> 函数（src/compiler/codegen/index.js）主要功能就是根据 AST 结构拼接生成 render 函数的字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">generate</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ast: ASTElement | void,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CodegenResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="keyword">new</span> CodegenState(options)</span><br><span class="line">  <span class="keyword">const</span> code = ast ? genElement(ast, state) : <span class="string">'_c("div")'</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render: <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>,</span><br><span class="line">    staticRenderFns: state.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 genElement 函数（src/compiler/codegen/index.js）是会根据 AST 的属性调用不同的方法生成字符串返回。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">genElement</span> (<span class="params">el: ASTElement, state: CodegenState</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;</span><br><span class="line">    <span class="keyword">return</span> genStatic(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.once &amp;&amp; !el.onceProcessed) &#123;</span><br><span class="line">    <span class="keyword">return</span> genOnce(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class="line">    <span class="keyword">return</span> genFor(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class="line">    <span class="keyword">return</span> genIf(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.tag === <span class="string">'template'</span> &amp;&amp; !el.slotTarget) &#123;</span><br><span class="line">    <span class="keyword">return</span> genChildren(el, state) || <span class="string">'void 0'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.tag === <span class="string">'slot'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> genSlot(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// component or element</span></span><br><span class="line">    <span class="keyword">let</span> code</span><br><span class="line">    <span class="keyword">if</span> (el.component) &#123;</span><br><span class="line">      code = genComponent(el.component, el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = el.plain ? <span class="literal">undefined</span> : genData(el, state)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> children = el.inlineTemplate ? <span class="literal">null</span> : genChildren(el, state, <span class="literal">true</span>)</span><br><span class="line">      code = <span class="string">`_c('<span class="subst">$&#123;el.tag&#125;</span>'<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        data ? <span class="string">`,<span class="subst">$&#123;data&#125;</span>`</span> : <span class="string">''</span> <span class="regexp">//</span> data</span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span><span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        children ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">''</span> <span class="regexp">//</span> children</span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span>)`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// module transforms</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; state.transforms.length; i++) &#123;</span><br><span class="line">      code = state.transforms[i](el, code)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是 compile 函数中三个核心步骤的介绍，compile 之后我们得到了 render 函数 的字符串形式，后面通过 new Function 得到真正的渲染函数。数据发现变化后，会执行 Watcher 中的 _update 函数（src/core/instance/lifecycle.js），_update 函数会执行这个渲染函数，输出一个新的 VNode 树形结构的数据。然后在调用 patch 函数，拿这个新的 VNode 与旧的 VNode 进行对比，只有发生了变化的节点才会被更新到真实 DOM 树上。</p><h3 id="mount后续"><a href="#mount后续" class="headerlink" title="mount后续"></a>mount后续</h3><p>通过compile生成render方法之后，会进一步执行<a href="https://github.com/vuejs/vue/blob/v2.5.13/src/core/instance/lifecycle.js#L143-L209" target="_blank" rel="noopener">mount</a>方法,在$mount中可以看到最后一句话:return mount.call(this, el, hydrating),这个mount实际上就是runtime中的mount，执行的就是lifecycle中的mountComponent方法，看一下基本逻辑:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发 beforeMount 生命周期钩子</span></span><br><span class="line">callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> updateComponent <span class="comment">//updateComponent是watcher更新时的回调，用于更新视图操作</span></span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">  updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = vm._name</span><br><span class="line">    <span class="keyword">const</span> id = vm._uid</span><br><span class="line">    <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">    <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">    mark(startTag)</span><br><span class="line">    <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">    mark(endTag)</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">    mark(startTag)</span><br><span class="line">    vm._update(vnode, hydrating)</span><br><span class="line">    mark(endTag)</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以前是直接new Watch赋值给vm._watcher,现在这一步放到了watcher的构造函数中</span></span><br><span class="line"><span class="comment">// we set this to vm._watcher inside the watcher's constructor</span></span><br><span class="line"><span class="comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line"><span class="comment">// component's mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop, <span class="literal">null</span>, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line"><span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line"><span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">  vm._isMounted = <span class="literal">true</span></span><br><span class="line">  callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vm</span><br></pre></td></tr></table></figure><p>首先会new一个watcher对象（主要是将模板与数据建立联系），在watcher对象创建后，会运行传入的方法 vm._update(vm._render(), hydrating) 。其中的vm._render()主要作用就是运行前面compiler生成的render方法，并返回一个vNode对象。vm.update() 则会对比新的 vdom 和当前 vdom，并把差异的部分渲染到真正的 DOM 树上。</p><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>patch.js 就是新旧 VNode 对比的 diff 函数，主要是为了优化dom，通过算法使操作dom的行为降到最低，diff 算法来源于 snabbdom，是 VDOM 思想的核心。snabbdom 的算法为了 DOM 操作跨层级增删节点较少的这一目标进行优化，它只会在同层级进行, 不会跨层级比较。</p><hr><p>参考链接</p><ul><li><a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">官方文档：渲染函数 &amp; JSX</a></li><li><a href="https://zhuanlan.zhihu.com/p/30332791" target="_blank" rel="noopener">深入vue2.0模板渲染底层思想</a></li><li><a href="https://zhuanlan.zhihu.com/p/32754111" target="_blank" rel="noopener">vue 学习笔记 - 完成dom渲染</a><br>扩展</li><li><a href="https://github.com/aooy/blog/issues/2" target="_blank" rel="noopener">解析vue2.0的diff算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前整理了vue的响应式原理，在这里有一点是一直很模糊的，就是何时去new一个watcher，当data变化时又如何通知视图去进行怎样的更新…这里面涉及到了模板渲染和虚拟DOM的diff以及更新操作。其实模板渲染过程在实际使用vue的过程可能并不需要太深理解，但就vue来说，这些底层思想可以更好地让我们理解这个框架，以及了解为什么Vue的API要如此设计…&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.locusland.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="vue" scheme="http://blog.locusland.xyz/tags/vue/"/>
    
      <category term="源码" scheme="http://blog.locusland.xyz/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码--解读vue响应式原理</title>
    <link href="http://blog.locusland.xyz/2018/01/05/vue-reactivity/"/>
    <id>http://blog.locusland.xyz/2018/01/05/vue-reactivity/</id>
    <published>2018-01-05T06:55:11.000Z</published>
    <updated>2018-02-07T07:39:11.538Z</updated>
    
    <content type="html"><![CDATA[<p>Vue的官方说明里有<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">深入响应式原理</a>这一节。在此官方也提到过：</p><blockquote><p>当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。</p></blockquote><p>官网只是说了一个大概原理，浏览了一下vue的源码以及其他关于此处的解释，这一块其实可以总结为两点：利用Object.defineProperty进行数据劫持同时结合观察者模式（发布/订阅模式）来实现数据双向绑定，这也是vue响应式原理的核心。首先先把这两个东西简单介绍一下吧~</p><a id="more"></a><h3 id="关于Object-defineProperty"><a href="#关于Object-defineProperty" class="headerlink" title="关于Object.defineProperty"></a>关于Object.defineProperty</h3><p>关于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a>我觉得还是MDN上说的更明白详细一些，我写在这里无非是一些ctrl C+V，总之我们要知道它是一个定义属性描述符的东西，可以劫持一个对象属性的getter和setter，而Vue正是通过在属性改变时劫持这些来通知watcher（后文会讲）。下面这个例子实现了一个极简的双向绑定：</p><p></p><p data-height="300" data-theme-id="15655" data-slug-hash="dJVeGj" data-default-tab="js,result" data-user="geniuspeng" data-embed-version="2" data-pen-title="极简的双向绑定" class="codepen">See the Pen <a href="https://codepen.io/geniuspeng/pen/dJVeGj/" target="_blank" rel="noopener">极简的双向绑定</a> by Yunpeng Bai (<a href="https://codepen.io/geniuspeng" target="_blank" rel="noopener">@geniuspeng</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p></p><p>它的效果就是，input框输出改变的时候，span的内容随之改变，同时如果在控制台直接改变obj.hello属性，input和span的内容同时会一起变化（验证这个得去codepen页面中的console控制台），其原理就是利用Object.defineProperty劫持了属性的set方法。</p><h3 id="关于观察者模式"><a href="#关于观察者模式" class="headerlink" title="关于观察者模式"></a>关于观察者模式</h3><p>观察者模式（有时又被称为发布（publish ）-订阅（Subscribe）模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。<br>观察者模式根据具体不同的场景可以实现出不同的版本，但其核心思想没有变化,下面是根据vue源码简化出来的一个简单模型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;<span class="comment">//主题对象</span></span><br><span class="line">  <span class="keyword">this</span>.subs = []; <span class="comment">//订阅者列表</span></span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//主题对象通知订阅者</span></span><br><span class="line">  <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>)</span>&#123; <span class="comment">//遍历所有的订阅者，执行订阅者提供的更新方法</span></span><br><span class="line">    sub.update();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">x</span>) </span>&#123; <span class="comment">//订阅者</span></span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">&#125;、</span><br><span class="line">Sub.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//订阅者更新</span></span><br><span class="line">  <span class="keyword">this</span>.x = <span class="keyword">this</span>.x * <span class="keyword">this</span>.x;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pub = &#123; <span class="comment">//发布者</span></span><br><span class="line">  publish: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    dep.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> dep = <span class="keyword">new</span> Dep(); <span class="comment">//主题对象实例</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(dep.subs, <span class="keyword">new</span> Sub(<span class="number">1</span>), <span class="keyword">new</span> Sub(<span class="number">2</span>), <span class="keyword">new</span> Sub(<span class="number">3</span>)); <span class="comment">//新增 3 个订阅者</span></span><br><span class="line">pub.publish(); <span class="comment">//发布者发布更新</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>首先有3个主体：发布者，主题对象，订阅者，其中发布者和主题对象是一对一的（某些其他场景可能一对多？），而主题对象和订阅者也是一对多的关系。发布者通过发布某个主题对象，主题对象更新并通知其所有的订阅者，然后每个订阅者执行update进行更新。<br><strong>对于Vue，我们这里可以认为Vue实例中的data中的每一项属性是一个Dep，而所有用到这个属性的地方都是这个Dep的一个订阅者（sub），当这个属性值变化时，观察者通过监听捕获变化，告诉这个dep去notify每一个订阅者。</strong></p><h3 id="Observer-，Dep和Watcher"><a href="#Observer-，Dep和Watcher" class="headerlink" title="Observer ，Dep和Watcher"></a>Observer ，Dep和Watcher</h3><p>Observer、Watcher、Dep 是响应式原理中涉及到的 3 个重要的对象,可以说分别上面的发布者，主体对象，订阅者相对应。其关系可以简化为下图所示：<br><img src="https://geniuspeng.github.io/image-storage/blog/vue/vue-reactivity.png?w=651&amp;h=327" alt="https://geniuspeng.github.io/image-storage/blog/vue/vue-reactivity.png"></p><h4 id="Observer对象"><a href="#Observer对象" class="headerlink" title="Observer对象"></a>Observer对象</h4><p>这个东西，字面意思是一个观察者，我个人理解就是上面所说的Object.defineProperty + 发布者的结合体，它的主要功能是做数据劫持，在数据获得更新的时候（拦截set方法），执行主题对象（Dep）的notify方法，通知所有的订阅者（Watcher）。<br>Observer类定义在<a href="https://github.com/vuejs/vue/blob/v2.5.13/src/core/observer/index.js#L40-L54" target="_blank" rel="noopener">src/core/observer/index.js</a>中，先来看一下Observer的构造函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value</span><br><span class="line">  <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">  def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">    <span class="keyword">const</span> augment = hasProto</span><br><span class="line">      ? protoAugment</span><br><span class="line">      : copyAugment</span><br><span class="line">    augment(value, arrayMethods, arrayKeys)</span><br><span class="line">    <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.walk(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>value是需要被观察的数据对象，在构造函数中，会给value增加<strong>ob</strong>属性，作为数据已经被Observer观察的标志。如果value是数组，就使用observeArray遍历value，对value中每一个元素调用observe分别进行观察。如果value是对象，则使用walk遍历value上每个key，对每个key调用defineReactive来获得该key的set/get控制权。<br>在<a href="https://github.com/vuejs/vue/blob/v2.5.13/src/core/observer/index.js" target="_blank" rel="noopener">src/core/observer/index.js</a>中还有几个方法，大致解释如下</p><ul><li>observeArray: 遍历数组，对数组的每个元素调用observe</li><li>observe: 检查对象上是否有<strong>ob</strong>属性，如果存在，则表明该对象已经处于Observer的观察中，如果不存在，则new Observer来观察对象（其实还有一些判断逻辑，为了便于理解就不赘述了）</li><li>walk: 遍历对象的每个key，对对象上每个key的数据调用defineReactive</li><li>defineReactive: 通过Object.defineProperty设置对象的key属性，使得能够捕获到该属性值的set/get动作。一般是由Watcher的实例对象进行get操作，此时Watcher的实例对象将被自动添加到Dep实例的依赖数组中，在外部操作触发了set时，将通过Dep实例的notify来通知所有依赖的watcher进行更新。（后面详细介绍）</li></ul><p>defineReactive方法如下，这是observer类的一个核心方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>defineReactive 是对 Object.defineProperty 方法的包装，结合 observe 方法对数据项进行深入遍历，最终将所有的属性就转化为 getter 和 setter。至此，所有的数据都已经转换为 Observer 对象。即数据的读操作都会触发 getter 函数，写操作都会触发 setter 函数。<br>那走到这里，会有很多问题，比如Dep在哪？如何往Dep中添加订阅者？</p><h3 id="Dep对象"><a href="#Dep对象" class="headerlink" title="Dep对象"></a>Dep对象</h3><p>Dep类定义在<a href="https://github.com/vuejs/vue/blob/v2.5.13/src/core/observer/dep.js" target="_blank" rel="noopener">src/core/observer/dep.js</a>中。<br>Dep是Observer与Watcher之间的纽带，也可以认为Dep是服务于Observer的订阅系统。Watcher订阅某个Observer的Dep，当Observer观察的数据发生变化时，通过Dep通知各个已经订阅的Watcher。其构造函数和主要方法如下。其中sub就是订阅者Watcher，在后文介绍：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>Dep提供了如下几个方法：</p><ul><li>addSub: 接收的参数为Watcher实例，并把Watcher实例存入记录依赖的数组中</li><li>removeSub: 与addSub对应，作用是将Watcher实例从记录依赖的数组中移除</li><li>depend: Dep.target上存放这当前需要操作的Watcher实例，调用depend会调用该Watcher实例的addDep方法，addDep的功能可以看下面对Watcher的介绍</li><li>notify: 通知依赖数组中所有的watcher进行更新操作</li></ul><h3 id="Watcher对象"><a href="#Watcher对象" class="headerlink" title="Watcher对象"></a>Watcher对象</h3><p>Watcher类定义在<a href="https://github.com/vuejs/vue/blob/v2.5.13/src/core/observer/watcher.js" target="_blank" rel="noopener">src/core/observer/watcher.js</a>。其构造函数如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (</span><br><span class="line">  vm: Component,</span><br><span class="line">  expOrFn: string | Function,</span><br><span class="line">  cb: Function,</span><br><span class="line">  options?: ?Object,</span><br><span class="line">  isRenderWatcher?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">this</span>.vm = vm</span><br><span class="line">  <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">    vm._watcher = <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">// options</span></span><br><span class="line">  <span class="keyword">if</span> (options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">    <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">    <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">    <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.cb = cb</span><br><span class="line">  <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">  <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">  <span class="keyword">this</span>.deps = []</span><br><span class="line">  <span class="keyword">this</span>.newDeps = []</span><br><span class="line">  <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">    ? expOrFn.toString()</span><br><span class="line">    : <span class="string">''</span></span><br><span class="line">  <span class="comment">// parse expression for getter</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</span><br><span class="line">        <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">        <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">    ? <span class="literal">undefined</span></span><br><span class="line">    : <span class="keyword">this</span>.get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>watcher实例有这些方法：</p><ul><li>get: 将Dep.target设置为当前watcher实例，在内部调用this.getter，如果此时某个被Observer观察的数据对象被取值了，那么当前watcher实例将会自动订阅数据对象的Dep实例</li><li>addDep: 接收参数dep(Dep实例)，让当前watcher订阅dep</li><li>cleanupDeps: 清除newDepIds和newDep上记录的对dep的订阅信息</li><li>update: 立刻运行watcher或者将watcher加入队列中等待统一flush</li><li>run: 运行watcher，调用this.get()求值，然后触发回调</li><li>evaluate: 调用this.get()求值</li><li>depend: 遍历this.deps，让当前watcher实例订阅所有dep</li><li>teardown: 去除当前watcher实例所有的订阅</li></ul><p>Observer，Dep，Watcher所有的代码都过一遍之后，再来回头看看究竟是如何添加订阅者的。说白了就是Dep中的this.subs = []方法如何添加相应的订阅者watcher的。在这里还应该列出两个重要的方法，watcher的get（）方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">get () &#123;</span><br><span class="line">  pushTarget(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">      handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget()</span><br><span class="line">    <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.id</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在Dep中可以看到Dep在一开始定义了一个全局属性Dep.target，在新建watcher是，这个属性为null，而在watcher的构造函数中最后会执行自己的get（）方法，进而执行pushTarget(this)方法，可以看到get()方法中做了一件事情：value = this.getter.call(vm, vm)，然后popTarget（）。Dep.target只是一个标记，存储当前的watcher实例，而执行这句话的意义在于触发Object.defineProperty中的get拦截，而在bject.defineProperty中的get那里，我们可以看到dep.depend()，正是在这里将当前的订阅者watcher绑定当Dep上。<br>也就是说，每个watcher第一次实例化的时候，都会作为订阅者订阅其相应的Dep。<br>而关于watcher何时进行实例化的问题，模板渲染初始化相关指令调用data中的属性，或者正常进行数据绑定时都会创建watcher实例。<br><strong>PS: 在模板渲染过程中，vue1.x与vue2.x完全不同，1.x是利用documentFragment来实现，而2.x向react靠拢，加入了virtual dom，同时通过自己生产的render方法进行渲染，不过无论是那种方法，都会在初始时对所关联的data属性进行watcher实例化并且绑定watcher变化时的更新callback，确保data更新时会重新对相应的地方进行视图更新。</strong></p><p>总结一下：</p><ol><li>模板编译过程中的指令和数据绑定都会生成 Watcher 实例，watch 函数中的对象也会生成 Watcher 实例，在实例化的过程中，会调用 watcher.js 中的 get 函数 touch 这个 Watcher 的表达式或函数涉及的所有属性；</li><li>touch 开始之前，Watcher 会设置 Dep 的静态属性 Dep.target 指向其自身，目的在于标记此watcher实例是第一次创建，需要添加到一个Dep中；</li><li>touch 属性的过程中，属性的 getter 函数会被访问；</li><li>属性 getter 函数中会判断 Dep.target（target 中保存的是第 2 步中设置的 Watcher 实例）是否存在，若存在则将 getter 函数所在的 Observer 实例的 Dep 实例保存到 Watcher 的列表中，并在此 Dep 实例中添加 Watcher 为订阅者；</li><li>重复上述过程直至 Watcher 的表达式或函数涉及的所有属性均 touch 结束（即表达式或函数中所有的数据的 getter 函数都已被触发），Dep.target 被置为 null，此时已经将该watcher作为订阅者绑定到Dep中；</li></ol><hr><p>参考链接</p><ul><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">官方文档：深入响应式原理</a></li><li><a href="http://zhouweicsu.github.io/blog/2017/03/07/vue-2-0-reactivity/" target="_blank" rel="noopener">Vue2.0源码解读：响应式原理</a></li><li><a href="https://segmentfault.com/a/1190000008377887" target="_blank" rel="noopener">Vue原理解析之 observer 模块</a></li><li><a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">剖析Vue原理&amp;实现双向绑定MVVM</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue的官方说明里有&lt;a href=&quot;https://cn.vuejs.org/v2/guide/reactivity.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入响应式原理&lt;/a&gt;这一节。在此官方也提到过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官网只是说了一个大概原理，浏览了一下vue的源码以及其他关于此处的解释，这一块其实可以总结为两点：利用Object.defineProperty进行数据劫持同时结合观察者模式（发布/订阅模式）来实现数据双向绑定，这也是vue响应式原理的核心。首先先把这两个东西简单介绍一下吧~&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.locusland.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="vue" scheme="http://blog.locusland.xyz/tags/vue/"/>
    
      <category term="源码" scheme="http://blog.locusland.xyz/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>从源码角度实现一个自己的Promise</title>
    <link href="http://blog.locusland.xyz/2017/12/14/my-promise/"/>
    <id>http://blog.locusland.xyz/2017/12/14/my-promise/</id>
    <published>2017-12-14T03:12:18.000Z</published>
    <updated>2017-12-25T03:37:26.155Z</updated>
    
    <content type="html"><![CDATA[<p>关于Promise的概念以及意义就不在这里介绍了，最近看到了一些实现Promise的核心思想，在这里整理一下。写这篇文章并不是为了实现一个自己的Promise，毕竟现在es6已经标准支持，而且还有一大堆的第三方Promise库，主要是为了从最底层的角度深入理解一下Promise的实现思路。<br><a id="more"></a></p><h3 id="1-从状态机出发"><a href="#1-从状态机出发" class="headerlink" title="1.从状态机出发"></a>1.从状态机出发</h3><p>我们知道，Promise的作用在于包裹一个异步（或同步）操作，然后通过then方法实现这个操作成功（或失败）的回调，而这其中的原理则是可以通过一个类似状态机的机制来控制。首先需要明确几个概念，这些概念可以从Promise/A的API规范中找到：</p><ul><li><p>Promise（中文：承诺）其实为一个有限状态机，共有三种状态：pending（执行中）、fulfilled（执行成功）和rejected（执行失败）。</p></li><li><p>其中pending为初始状态，fulfilled和rejected为结束状态（结束状态表示promise的生命周期已结束）。</p></li><li><p>状态转换关系为：fulfill方法(pending-&gt;fulfilled)，reject(pending-&gt;rejected)，此状态转换不可逆。</p></li><li><p>随着状态的转换将触发各种事件（如执行成功事件、执行失败事件等）。 </p></li></ul><p>根据这些信息，我们就可以得出一个Promise的初始模型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//存储状态：PENDING, FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">let</span> state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储 FULFILLED 或者 REJECTED时传入的参数value</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储</span></span><br><span class="line">  <span class="keyword">let</span> handlers = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    state = FULFILLED;</span><br><span class="line">    value = result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    state = REJECTED;</span><br><span class="line">    value = error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-实现handle方法"><a href="#2-实现handle方法" class="headerlink" title="2.实现handle方法"></a>2.实现handle方法</h3><p>有了上面的初始模型，接下来需要一个resolve方法，我们知道new Promise（）的时候传入的参数是一个function，而这个function有两个参数resolve和reject，并且这两个参数都是一个function，就是说是一个带了两个function参数的function。而里面的resolve和reject方法决定了这个Promise的走向（fulfill方法还是reject），我们的handle方法就是决定这个走向用的，说起来有点绕，看一下handle大致做了什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//存储状态：PENDING, FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">let</span> state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储 FULFILLED 或者 REJECTED时传入的参数value</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储</span></span><br><span class="line">  <span class="keyword">let</span> defers = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    state = FULFILLED;</span><br><span class="line">    value = result;</span><br><span class="line">    handle(defers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    state = REJECTED;</span><br><span class="line">    value = error;</span><br><span class="line">    handle(defers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">      defers = handler;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">        <span class="comment">//do sth fulfilled</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (state === REJECTED) &#123;</span><br><span class="line">        <span class="comment">//do sth rejected</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fn(fulfill, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-实现then方法"><a href="#3-实现then方法" class="headerlink" title="3.实现then方法"></a>3.实现then方法</h3><p>then方法接受两个参数，分别是fulfill方法之后的回调onResolved以及reject之后的回调onRejected。同时因为Promise内的方法可能是同步页可能是异步，为了保证handle都能正常执行，我们需要一个defers变量，这样同步情况下，fulfill方法不会执行handle，而是到then的时候再执行handle，处于一个完全同步状态，而异步情况，在pending的时候将相应的handler存到defer中，直到fulfill的时候去进行处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//存储状态：PENDING, FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">let</span> state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储 FULFILLED 或者 REJECTED时传入的参数value</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储异步情况相应的handler</span></span><br><span class="line">  <span class="keyword">let</span> defers = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    state = FULFILLED;</span><br><span class="line">    value = result;</span><br><span class="line">    <span class="keyword">if</span> (defers) &#123;</span><br><span class="line">      handle(defers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    state = REJECTED;</span><br><span class="line">    value = error;</span><br><span class="line">    <span class="keyword">if</span> (defers) &#123;</span><br><span class="line">      handle(defers);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">      defers = handler;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">        handler.onFulfilled(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (state === REJECTED) &#123;</span><br><span class="line">        handler.onRejected(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    handle(&#123;</span><br><span class="line">      onFulfilled,</span><br><span class="line">      onRejected</span><br><span class="line">    &#125;);</span><br><span class="line">   &#125;;</span><br><span class="line">  fn(fulfill, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里基本的逻辑已经出来了，但实际上还有很多可以改进的地方。比如Promise不仅仅可以接收一个单独的值，同样可以接收一个Promise对象，而then的返回值也是一个Promise对象，也就是完全支持链式调用。下面从这两个角度出发，进行完善。</p><h3 id="支持Promise参数"><a href="#支持Promise参数" class="headerlink" title="支持Promise参数"></a>支持Promise参数</h3><p>resolve 既可以接受一个 Promise，也可以接受一个基本类型。当 resolve 一个 Promise 时，就成了酱紫：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">'aaa'</span>)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>我们上面的方法就无法达到效果，这时我们需要一个新的方法来进行改进，可以把这个方法就叫做resolve，而之前的fulfill方法我们仅仅当做是一个改变state状态的方法，也就是说简单来说，resolve其实就是改进了一下fulfill，那么最开始其实就是 这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  fulfill(result)</span><br><span class="line">&#125;</span><br><span class="line">fn(resolve, reject);</span><br></pre></td></tr></table></figure></p><p>嗯就这样，下面开始改进。因为resolve可能接收一个Promise对象，Promise一定有then方法，我们可以对这点进行一个判断，是否为Promise对象进行不同的处理，同时还需要一个doResolve方法进行对传入的Promise对象的递归处理（因为传入的Promise对象rosolve的可能还是个Promise对象，不一定嵌套了多少层- -）…这两个方法实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThen</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.then;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResolve</span> (<span class="params">fn, onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> done = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 执行由 resolve 传入的 resolve 回调</span></span><br><span class="line">      onFulfilled(value)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      onRejected(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">    done = <span class="literal">true</span></span><br><span class="line">    onRejected(ex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> then = getThen(result)</span><br><span class="line">    <span class="keyword">if</span> (then) &#123;</span><br><span class="line">      <span class="comment">// 递归 resolve 待解析的 Promise</span></span><br><span class="line">      doResolve(then.bind(result), resolve, reject)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fulfill(result)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getThen其实很简单，就是判断这个对象是否有then方法，如果有，我们当做Promise处理，通过doResolve来递归resolve方法，直到遇到的不是Promise对象为止，resolve出真正的值。而doResolve大致就是一个tryCallTwo的功能，让第一个fn参数以后两个参数为参数去执行,即做了最开始fn(resolve, reject)的工作，类似这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryCallTwo</span>(<span class="params">fn, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(a, b);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">return</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时doResolve需要确保 onFulfilled 与 onRejected 只会被调用一次，而我们的最后一行的fn(resolve, reject)需要替换成doResolve(fn, resolve, reject),至此为止，完整的实现为（getThen和doResolve做为两个辅助函数，为了更清晰，我们放在Promise外面）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThen</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.then;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResolve</span> (<span class="params">fn, onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> done = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 执行由 resolve 传入的 resolve 回调</span></span><br><span class="line">      onFulfilled(value)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      onRejected(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">    done = <span class="literal">true</span></span><br><span class="line">    onRejected(ex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//存储状态：PENDING, FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">let</span> state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储 FULFILLED 或者 REJECTED时传入的参数value</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储异步情况相应的handler</span></span><br><span class="line">  <span class="keyword">let</span> defers = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    state = FULFILLED;</span><br><span class="line">    value = result;</span><br><span class="line">    <span class="keyword">if</span> (defers) &#123;</span><br><span class="line">      handle(defers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    state = REJECTED;</span><br><span class="line">    value = error;</span><br><span class="line">    <span class="keyword">if</span> (defers) &#123;</span><br><span class="line">      handle(defers);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = getThen(result)</span><br><span class="line">      <span class="keyword">if</span> (then) &#123;</span><br><span class="line">        <span class="comment">// 递归 resolve 待解析的 Promise</span></span><br><span class="line">        doResolve(then.bind(result), resolve, reject)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      fulfill(result)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">      defers = handler;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">        handler.onFulfilled(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (state === REJECTED) &#123;</span><br><span class="line">        handler.onRejected(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    handle(&#123;</span><br><span class="line">      onFulfilled,</span><br><span class="line">      onRejected</span><br><span class="line">    &#125;);</span><br><span class="line">   &#125;;</span><br><span class="line">  doResolve(fn, resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="优化handle方法"><a href="#优化handle方法" class="headerlink" title="优化handle方法"></a>优化handle方法</h3><p>这里的handle方法有一点小问题，首先，handle传入参数handler，这个handler这里可以看出是then带过来的一个对象，其中包含了成功和拒绝两个状态的回调onFulfilled, onRejected，当然我们在then中完全可以不写参数（虽然这样没有了then的意义），比如这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'sth'</span>)</span><br><span class="line">&#125;).then();</span><br></pre></td></tr></table></figure></p><p>这种情况会因为handler.onFulfilled或者handler.onRejected不存在而导致报错，于是可以把handle方法稍微优化一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">    defers = handler;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> handlerCallback;</span><br><span class="line">    <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">      handlerCallback = handler.onFulfilled || <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handlerCallback = handler.onRejected || <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handlerCallback) &#123;</span><br><span class="line">      handlerCallback(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过一个handlerCallback存储回调。。。没有的时候，就什么也不做就可以了。</p><h3 id="实现链式调用"><a href="#实现链式调用" class="headerlink" title="实现链式调用"></a>实现链式调用</h3><p>我们都知道，then方法的回调可以return一个值，而then方法本身返回的是一个Promise，而这个Promise中resolve的结果就是这个return的值，所以可以实现完整的链式调用，对于这一点，我们只需要把上述的then方法稍微加工一下，让它返回一个Promise：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    handle(&#123;</span><br><span class="line">      onFulfilled,</span><br><span class="line">      onRejected,</span><br><span class="line">      resolve,</span><br><span class="line">      reject</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>then方法改了之后，handle方法也需要进行一些改进,因为此时handle的参数handler不仅仅有onFulfilled, onRejected这两个回调，还需要传入then返回的Promise的reslove和reject方法。而传给下一个then（链式）的值就是这个resolve所解析出来的value，所以在这个handle方法的最后，一定要resolve这个value。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">    defers = handler;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> handlerCallback = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">      handlerCallback = handler.onFulfilled;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handlerCallback = handler.onRejected;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handlerCallback) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">        handler.resolve(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler.reject(value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ret = handlerCallback(value);</span><br><span class="line">    handler.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把优化后的再整理一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThen</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.then;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResolve</span> (<span class="params">fn, onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> done = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 执行由 resolve 传入的 resolve 回调</span></span><br><span class="line">      onFulfilled(value)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">      done = <span class="literal">true</span></span><br><span class="line">      onRejected(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span></span><br><span class="line">    done = <span class="literal">true</span></span><br><span class="line">    onRejected(ex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//存储状态：PENDING, FULFILLED or REJECTED</span></span><br><span class="line">  <span class="keyword">let</span> state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储 FULFILLED 或者 REJECTED时传入的参数value</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存储异步情况相应的handler</span></span><br><span class="line">  <span class="keyword">let</span> defers = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    state = FULFILLED;</span><br><span class="line">    value = result;</span><br><span class="line">    <span class="keyword">if</span> (defers) &#123;</span><br><span class="line">      handle(defers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    state = REJECTED;</span><br><span class="line">    value = error;</span><br><span class="line">    <span class="keyword">if</span> (defers) &#123;</span><br><span class="line">      handle(defers);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = getThen(result)</span><br><span class="line">      <span class="keyword">if</span> (then) &#123;</span><br><span class="line">        <span class="comment">// 递归 resolve 待解析的 Promise</span></span><br><span class="line">        doResolve(then.bind(result), resolve, reject)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      fulfill(result)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">      defers = handler;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> handlerCallback = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">        handlerCallback = handler.onFulfilled;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handlerCallback = handler.onRejected;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!handlerCallback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">          handler.resolve(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          handler.reject(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> ret = handlerCallback(value);</span><br><span class="line">      handler.resolve(ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onFulfilled,</span><br><span class="line">        onRejected,</span><br><span class="line">        resolve,</span><br><span class="line">        reject</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125;;</span><br><span class="line">  doResolve(fn, resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此为止，基本上的功能已经完成了，当然，ES6标注的Promise还有Promise.all,Promise.race等方法，不过只要Promise的基本实现原理弄明白了，这些扩展起来也是很简单事情。<br>还有一点需要注意，Promise内部是纯异步实现的，即使是同步直接传入一个resolve值也会是异步完成，在ES6标准中的Promise是通过Job Queue来完成（可以参考以前的文章Micro-task），在这里我们可以通过setTimeout来简单模拟一下，虽然不完全相同（setTimeout属于Macro-task），但是可以大体上实现纯异步的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state === PENDING) &#123;</span><br><span class="line">    defers = handler;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> handlerCallback = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">        handlerCallback = handler.onFulfilled;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handlerCallback = handler.onRejected;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!handlerCallback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state === FULFILLED) &#123;</span><br><span class="line">          handler.resolve(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          handler.reject(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> ret = handlerCallback(value);</span><br><span class="line">      handler.resolve(ret);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯就酱~~~~参考链接：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise MDN</a></li><li><a href="http://es6.ruanyifeng.com/?search=mixin&amp;x=0&amp;y=0#docs/promise" target="_blank" rel="noopener">阮一峰–ES6标准——Promise</a></li><li><a href="https://github.com/then/promise/blob/master/src/core.js" target="_blank" rel="noopener">implements Promise in a very similar way.</a></li><li><a href="https://www.promisejs.org/" target="_blank" rel="noopener">promisejs.org</a></li><li><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">【翻译】Promises/A+规范</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Promise的概念以及意义就不在这里介绍了，最近看到了一些实现Promise的核心思想，在这里整理一下。写这篇文章并不是为了实现一个自己的Promise，毕竟现在es6已经标准支持，而且还有一大堆的第三方Promise库，主要是为了从最底层的角度深入理解一下Promise的实现思路。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="Promise" scheme="http://blog.locusland.xyz/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Macro-task 与 Micro-task</title>
    <link href="http://blog.locusland.xyz/2017/11/15/task-and-job/"/>
    <id>http://blog.locusland.xyz/2017/11/15/task-and-job/</id>
    <published>2017-11-15T09:50:41.000Z</published>
    <updated>2017-12-29T03:40:35.586Z</updated>
    
    <content type="html"><![CDATA[<p>讲道理，从16年3月入前端的坑，到现在总觉得好歹也应该够了解js了，不过最近看到关于setTimeout (fn, 0)突然让我想到了刚学js的时候就一知半解的Event Loop，还有相关的Task queue,后来听说过的Macro task，Micro task(当然只是听说，啥也不懂)。今天把最近学到的一些东西整理一下，还是从一道题开始吧~<br><a id="more"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'global1'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'global2'</span>);</span><br></pre></td></tr></table></figure><p>对就是酱紫，而且这是一个简单版本，相信有很多小伙伴也看过这种，也知道结果。对于我来说，先前知道的可能也就是setTimeout (fn, 0)会把回调放到一个任务队列（task queue）里，ajax回调也是，Promise的resolve回调也是，dom事件监听（click等）同样，这些回调脱离了主线程，而在主线程空闲下来的时候去执行这些回调，但又不是完全结束之后，而是在适当的时机执行适当的回调。。。什么乱七八糟的啊~！@%#……￥&amp;就是说，如果ajax请求结果很慢是不是就要很后面执行？setTimeout和ajax，Promise都有什么顺序关系吗？为什么上面的Promise的then一定要timeout前面？<br>所以说，之前我只知道有一些callback会延迟执行，放到一个什么任务队列里，但具体是什么样的，时间循环怎么循环的，基本上是处于完全混乱状态。<br>今天在这里整理一下~<br>看了很多文章，基本的解释都一样，最通俗的解释就是，我们执行js代码需要一个函数调用栈（我这就叫执行栈吧），需要执行什么就push进去执行，执行过后再释放，所有的方法都是依赖于这个执行栈。而我们有两种任务类型宏任务macro-task，和微任务micio-task，它们都依赖于执行栈去执行。</p><ul><li>macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</li><li>micro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)。<br>而执行整体代码时，直接执行的直接放到执行栈中，遇到相应的task则放在其对应的task queue中。<br><em>一个事件循环从macro-task开始执行，当前执行栈没有可执行的东西时，开始执行micro-task的内容，然后开启下一个事件循环。而setTimeout被放入macro-task的队列，所以要等到下一个循环才能出来。</em>这就解释了为什么timeout在then后面。<br>我说的好像很乱，他<a href="http://www.jianshu.com/p/12b9f73c5a4f#" target="_blank" rel="noopener">这里</a>有图,可以参照这个去理解一下~<br>其实这篇文章已经写得很详细了，基本原理就是这样，还给了很长的例子来图解~~只是看完我突然想到，事件监听的回调，或者ajax的回调，放到这里会是什么样呢？理论上这些回调应该是属于macro-task（至于为什么一会再说），于是我在上面加了几句话：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'global1'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>)</span><br><span class="line">&#125;;</span><br><span class="line">btn.click();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'global2'</span>);</span><br></pre></td></tr></table></figure><p>不出所料，click在global1和global2之间输出的。也就是说，立即点击的按钮虽然放了回调，但是它的回调什么时候入栈执行取决于什么时候点击，就是点击的时机，如果点击就是在第一个event loop中，那就是在第一个event loop中执行。当然在实际中，我们点击某个按钮肯定不会在第一个event loop，这里的第一个指的就是整体script，我们在某个时机点击，点击的时候才将console.log(‘click’)放入相应的任务队列，而这个队列应该处于未来的某次循环中，而且这个应该属于event task，与setTimeout是不同的任务源，应该是不同的任务队列。从这里基本上就可以知道，其实将callback放入队列（macro-task或micro-task）的时机是不确定的，setTimeout设置5000的话应该就是5秒之后放入，对于点击则是具体click的时候，那么ajax应该就是返回请求完成的时候，取决于这次请求到底花了多久。</p><p>————————————————————————————————我是分隔线——————————————————————————————————————————<br>以上是我自己的理解，写得也比较乱，下面从规范的角度重新把这个问题捋一捋…</p><h3 id="关于event-loop"><a href="#关于event-loop" class="headerlink" title="关于event loop"></a>关于event loop</h3><p>以下几点可以从<a href="https://www.w3.org/TR/html5/webappapis.html#event-loop" target="_blank" rel="noopener">event loop</a>规范中整理出来</p><ol><li>event loop依赖于浏览器环境（这里不考虑node中的event loop以及worker中的event loop），1个浏览器环境至多有1个event loop，如果这个浏览器环境销毁，event loop也随之消失。</li><li>一个event loop可以有1个或多个任务队列（task queues）。</li><li>一个task queue是一列有序的task，用来做以下工作：Events task，Parsing task， Callbacks task， Using a resource task， Reacting to DOM manipulation task等。</li><li>每一个task都和相应的document相关联，一般这个documnet就是当前script所在的浏览器上下文的document。event loop用来处理相应document下的tasks。</li><li>每一个task都有相应的task source（任务源），从同一个task source来的task必须放到同一个task queue，从不同源来的则被添加到不同task queue。</li><li>每个(task source对应的)task queue都保证自己队列的先进先出的执行顺序，但event loop的每个turn，是由浏览器决定从哪个task source挑选task。这允许浏览器为不同的task source设置不同的优先级，比如为用户交互设置更高优先级来使用户感觉流畅。</li></ol><h3 id="关于Job，Job-queues"><a href="#关于Job，Job-queues" class="headerlink" title="关于Job，Job queues"></a>关于Job，Job queues</h3><p>来看<a href="http://ecma-international.org/ecma-262/6.0/index.html#sec-jobs-and-job-queues" target="_blank" rel="noopener">ES20-15</a>规范中提到的Job和Job queues<br><img src="https://pic4.zhimg.com/5014ab6454bc214f76e3260fb68c3a1b_r.png" alt=""><br>一个Job Queue是一个先进先出的队列。一个ECMAScript实现必须至少包含以上两个Job Queue。<br>以下又强调了，单独的任务队列中的任务总是按先进先出的顺序执行，但是不保证多个任务队列中的任务优先级，具体实现可能会交叉执行。<br><img src="https://pic4.zhimg.com/50/0c6864c8a0e8a5f7f5abd8f9ddcddbe3_hd.jpg" alt=""><br>跟随PromiseJobs到25.4章节，可以看到<br><img src="https://pic4.zhimg.com/fed4b5f8710e3c3473e12a181394845f_b.png" alt=""><br>promise中reslove（fullfilled）的部分会把一个任务放到名为“PromiseJobs”的任务队列中，其实就是我们所说的micro-task。</p><p>综上从task和job两个规范可以得出，EcmaScript的Job queue与HTML的Task queue有异曲同工之妙。它们都可以有好几个，多个任务队列之间的顺序都是不保证的。但是，有一点可以确定，在当前的event loop的一次turn中，micro-task应该是在macro-task之后执行。<br>为什么呢？还是那个问题，为什么micro在macro后面，也就是为什么Promise的then在timeout后面？<br>这里有一个翻译的<a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">图灵社区 : 阅读 : 【翻译】Promises/A+规范</a>,在这篇文章中提到了所谓的macro-task和micro-task。有一个关键点就是script（整体代码）属于macro-task，我们从整体代码开始执行，在macro中遇到Promise产生了micro任务，遇到settimeout产出了新的macro任务，而settimeout产生的新的macro任务不会放到当前的循环中了，只能等到下一个循环的macro中去执行，而micro任务则可以在当前循环macro任务全部完成之后开始依次执行。<br>这里还有个问题，就是为什么settimeout不能放在当前的循环中呢。之前说的setTimeout (fn, 0)，之前说过不同task source（任务源）会放入不同的task queue（任务队列），所以setTimeout的回调会进入一个单独存放setTimeout的task queue（任务队列），而不可能放入当前整体代码的marco-task队列，即使我们将延迟时间设置为0，它定义的操作仍然需要等待所有代码执行完毕之后才开始执行。这里的延迟时间，并非相对于setTimeout执行这一刻，而是相对于其他代码执行完毕这一刻。所以说setTimeout方法不可能在当前循环的macro任务中执行。</p><p>好吧扯了一大堆，现在来把最开始那个题简单梳理一下~~~~<br>首先，全局代码（整体script）在macro-task中。</p><ol><li>从整体代码的macro-task开始执行，执行到global1，直接放到执行栈中执行，直接输出。</li><li>遇到setTimeOut，将此回调放到setTimeOut任务源的macro-task队列中，具体什么时候放取决于setTimeOut的第二个参数。</li><li>遇到了Promise，这里面的参数fn属于当前整体代码的macro-task，会立即执行，输出promise1。</li><li>for循环并不会导致进入其他任务队列，遇到resolve方法并执行。</li><li>继续执行输出promise2。</li><li>Promise的构造函数中resolve执行完毕的情况下，遇到then方法，从当前的macro-task创建了一个micro-task，并将这里resolve的回调（也就是then中的内容）打入这个micro-task队列。</li><li>继续执行，输出global2。</li><li>整体代码已经没有可执行的东西了，说明此次循环macro-task结束，开始执行micro-task队列，输出then1。</li><li>当前循环的micro-task也没东西了，开始下一次循环，只剩下setTimeOut的那个队列，输出timeout1。</li></ol><p>————————————————————————————————我也是分隔线——————————————————————————————————————————<br>刚刚的macro-task和micro-task都有提到node中关于定时器的一些东东比如setImmediate，process.nextTick等，setImmediate比较好说，可以初步理解为一个延迟为0的setTimeOut，当然是有一些区别不在这里详细介绍，输入macro-task。这里需要说明的一点是process.nextTick，按照归类它属于micro-task，那么看这个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">    res()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'nexttick'</span>))</span><br></pre></td></tr></table></figure><p>在node中执行结果process.nextTick()永远是优先于Promise的。这个似乎用上面的逻辑解释不通，nextTick中的可执行任务执行完毕之后，才会开始执行Promise队列中的任务。实际上在v8中，process.nextTick()严格来讲并不完全属于micro-task，看一下<a href="https://github.com/nodejs/node/blob/master/lib/internal/process/next_tick.js" target="_blank" rel="noopener">node的源码</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run callbacks that have no domain.</span></span><br><span class="line">  <span class="comment">// Using domains will cause this to be overridden.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_tickCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (tickInfo[kIndex] &lt; tickInfo[kLength]) &#123;</span><br><span class="line">        ++tickInfo[kIndex];</span><br><span class="line">        <span class="keyword">const</span> tock = nextTickQueue.shift();</span><br><span class="line">        <span class="keyword">const</span> callback = tock.callback;</span><br><span class="line">        <span class="keyword">const</span> args = tock.args;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CHECK(Number.isSafeInteger(tock[async_id_symbol]))</span></span><br><span class="line">        <span class="comment">// CHECK(tock[async_id_symbol] &gt; 0)</span></span><br><span class="line">        <span class="comment">// CHECK(Number.isSafeInteger(tock[trigger_async_id_symbol]))</span></span><br><span class="line">        <span class="comment">// CHECK(tock[trigger_async_id_symbol] &gt; 0)</span></span><br><span class="line"></span><br><span class="line">        emitBefore(tock[async_id_symbol], tock[trigger_async_id_symbol]);</span><br><span class="line">        <span class="comment">// emitDestroy() places the async_id_symbol into an asynchronous queue</span></span><br><span class="line">        <span class="comment">// that calls the destroy callback in the future. It's called before</span></span><br><span class="line">        <span class="comment">// calling tock.callback so destroy will be called even if the callback</span></span><br><span class="line">        <span class="comment">// throws an exception that is handles by 'uncaughtException' or a</span></span><br><span class="line">        <span class="comment">// domain.</span></span><br><span class="line">        <span class="comment">// TODO(trevnorris): This is a bit of a hack. It relies on the fact</span></span><br><span class="line">        <span class="comment">// that nextTick() doesn't allow the event loop to proceed, but if</span></span><br><span class="line">        <span class="comment">// any async hooks are enabled during the callback's execution then</span></span><br><span class="line">        <span class="comment">// this tock's after hook will be called, but not its destroy hook.</span></span><br><span class="line">        <span class="keyword">if</span> (async_hook_fields[kDestroy] &gt; <span class="number">0</span>)</span><br><span class="line">          emitDestroy(tock[async_id_symbol]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using separate callback execution functions allows direct</span></span><br><span class="line">        <span class="comment">// callback invocation with small numbers of arguments to avoid the</span></span><br><span class="line">        <span class="comment">// performance hit associated with using `fn.apply()`</span></span><br><span class="line">        _combinedTickCallback(args, callback);</span><br><span class="line"></span><br><span class="line">        emitAfter(tock[async_id_symbol]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kMaxCallbacksPerLoop &lt; tickInfo[kIndex])</span><br><span class="line">          tickDone();</span><br><span class="line">      &#125;</span><br><span class="line">      tickDone();</span><br><span class="line">      _runMicrotasks();</span><br><span class="line">      emitPendingUnhandledRejections();</span><br><span class="line">    &#125; <span class="keyword">while</span> (tickInfo[kLength] !== <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，_tickCallback 执行时不断取 nextTickQueue 中元素并执行。执行完以后，执行 _runMicrotasks() ，也就是执行 microtasks 。从这个角度来说，nextTick 和 microtask 是同一层级的。而_runMicrotasks() 调用 v8 的 RunMicrotasks，处理 v8 的 microtasks。而从实际效果来说，process.nextTick 被看作 microtask 没有问题。</p><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/80x15.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲道理，从16年3月入前端的坑，到现在总觉得好歹也应该够了解js了，不过最近看到关于setTimeout (fn, 0)突然让我想到了刚学js的时候就一知半解的Event Loop，还有相关的Task queue,后来听说过的Macro task，Micro task(当然只是听说，啥也不懂)。今天把最近学到的一些东西整理一下，还是从一道题开始吧~&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="task" scheme="http://blog.locusland.xyz/tags/task/"/>
    
      <category term="event loop" scheme="http://blog.locusland.xyz/tags/event-loop/"/>
    
  </entry>
  
  <entry>
    <title>关于一道题想到的...</title>
    <link href="http://blog.locusland.xyz/2017/11/14/settimeout/"/>
    <id>http://blog.locusland.xyz/2017/11/14/settimeout/</id>
    <published>2017-11-14T07:51:06.000Z</published>
    <updated>2017-12-25T03:37:26.160Z</updated>
    
    <content type="html"><![CDATA[<p>最新偶然看到一个关于for + setTimeout (fn, 0)的问题，其实在面试中，我们也经常被问到关于这类问题，一般涉及到闭包，作用域和作用域链，然后关于setTimeout (fn, 0)的执行顺序，顺便可以带出一些异步执行，任务队列，时间循环的东西，关于这些自己在一年前找工作的时候了解了一些，但是也不是很透彻。当时看的是阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a>,只是大概知道有这么个东西，但具体来说还是…一脸萌比的状态<br><a id="more"></a><br>先来看看最开始说的那一道题吧，虽然和主要想写的东西没啥关系…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯就是这么一道题，相信稍微了解js的都能知道输出结果—&gt;在1秒之后连续输出5个5。而且原因简单来说就是setTimeout会延迟执行，等到里面执行的时候，i已经变成5了。嗯这么说倒是一点毛病没有，但是关于这个setTimeout往深了讲，能挖出来的东西就太多了。不过这里就先不挖了，这个时候我们还可能被问到如何修改一下变成输出0到4？？？<br>这个解决方法也是很多啦~~~不过大多数同学应该想到的就是利用<a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife" target="_blank" rel="noopener">IIFE</a>增加一个闭包来解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">   setTimeout( (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理也不用细说了吧，应该都知道，就是让里面的i就是里面的i，外面的i就是外面的i，如果真的不理解原理可以参考<a href="http://www.jianshu.com/p/9b4a54a98660" target="_blank" rel="noopener">这个</a>。<br>当然我之前不知道的是，除了这种传统的方法（或者类似的），还发现了很多‘野路子’，比如把上边那段代码去掉两行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">   setTimeout( (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(i);</span><br><span class="line">   &#125;)(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你对js理解很深，完全可以看懂这个套路。理论上setTimeout传入的第一个参数应该是个fn，这里传的是一个IIFE，然而这个函数并没有return值，所以最后的结果就是undefined，所以for里面的实际就是setTimeout(undefined, 1000），当然啦这个没有任何效果，不过里面的东西可是会立即执行的，当然这么写会立即输出而不是延迟1秒。<br>当然啦还有一些其他的方法咯，比如这这样,使用ES5的bind的方法<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind传送门</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">  setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;.bind(<span class="literal">null</span>,i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还可以这样，也许你不知道setTimeout方法可以传3个以上的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过现在有了ES6，其实只要改3个字母就可以咯：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面也说过，这个和主要想写的没啥关系，其实最近看了很多关于时间循环机制（event loop）的东西，打算在下一篇整理一下~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最新偶然看到一个关于for + setTimeout (fn, 0)的问题，其实在面试中，我们也经常被问到关于这类问题，一般涉及到闭包，作用域和作用域链，然后关于setTimeout (fn, 0)的执行顺序，顺便可以带出一些异步执行，任务队列，时间循环的东西，关于这些自己在一年前找工作的时候了解了一些，但是也不是很透彻。当时看的是阮一峰老师的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/10/event-loop.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 运行机制详解：再谈Event Loop&lt;/a&gt;,只是大概知道有这么个东西，但具体来说还是…一脸萌比的状态&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="闭包" scheme="http://blog.locusland.xyz/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="IIFE" scheme="http://blog.locusland.xyz/tags/IIFE/"/>
    
  </entry>
  
  <entry>
    <title>PWA:service-worker篇</title>
    <link href="http://blog.locusland.xyz/2017/09/19/pwa-service-worker/"/>
    <id>http://blog.locusland.xyz/2017/09/19/pwa-service-worker/</id>
    <published>2017-09-19T07:31:58.000Z</published>
    <updated>2017-12-28T02:52:41.302Z</updated>
    
    <content type="html"><![CDATA[<p>在2014年，W3C公布了service worker的草案，service worker提供了很多新的能力，使得web app拥有与native app相同的离线体验、消息推送体验。<br>Service Worker是PWA的核心。谷歌给以 Service Worker API 为核心实现的 web 应用取了个高大上的名字：Progressive Web Apps（PWA，渐进式增强 WEB 应用），并且在其主要产品上进行了深入的实践。<br><a id="more"></a></p><h3 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h3><p>Service Worker是Web Workers大家族中的一员，所以这里还是首先介绍一下Web Workers。<br>Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。此外，他们可以使用XMLHttpRequest执行 I/O  (尽管responseXML和通道属性总是为空)。一旦创建， 一个worker 可以将消息发送到创建它的JavaScript代码, 通过将消息发布到该代码指定的事件处理程序 (反之亦然)。<br>实际上是一种多线程的机制，worker与用户页面的JS是相互独立的两个线程，所以能够互不干扰，worker有自己的作用域（如专用Worker的作用域DedicatedWorkerGlobalScope），worker内可以使用大多数JavaScript特性，包括Navigator，XMLHttpRequest，Math，Date等等。需要注意的是，worker内的代码不能操作DOM，也无法影响页面外观，综合整理worker大致有如下特点：</p><ul><li>全局对象就是worker对象本身，就是说self和this都指向worker对象。</li><li>最小化的navigator对象，有online，appName，appVersion，userAgent和platFrom属性。</li><li>只读的location</li><li>WindowTimers.setTimeout 和 WindowTimers.setInterval</li><li>XMLHttpRequest</li><li>Array, Date, Math, String</li></ul><p>在一个worker中最主要的你不能做的事情就是直接影响父页面。包括操作父页面的节点以及使用页面中的对象。比如通过PostMessage方法。<br>目前主要的web worker大致有以下几种：</p><ul><li>Worker（专用worker）：正如名字一样，就是一个正常的worker，可以通过var myWorker = new Worker(‘worker.js’)穿件;</li><li>SharedWorker（共享worker）：一个共享worker可以被多个脚本使用——即使这些脚本正在被不同的window、iframe或者worker访问，生成共享worker可以通过var myWorker = new SharedWorker(‘worker.js’)创建;</li><li>ServiceWorker： 一般作为web应用程序、浏览器和网络（如果可用）之前的代理服务器。它们旨在（除开其他方面）创建有效的离线体验，拦截网络请求，以及根据网络是否可用采取合适的行动并更新驻留在服务器上的资源。他们还将允许访问推送通知和后台同步API。本文详细介绍。</li><li>Chrome Workers： 一种仅适用于firefox的worker。如果您正在开发附加组件，希望在扩展程序中使用worker且有在你的worker中访问  js-ctypes 的权限，你可以使用Chrome Workers。详情请参阅<a href="https://developer.mozilla.org/en-US/docs/Web/API/ChromeWorker" target="_blank" rel="noopener">ChromeWorker</a>。</li><li>Audio Workers（音频worker）：配合Web Audio API使用，使得在web worker上下文中直接完成脚本化音频处理成为可能。</li></ul><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>Service Worker做为Worker一种，具有上述提到的worker的所有特性，同时还提供的自己独有的一些功能。例如：在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。<br>基于 Service Worker API 的特性，结合 Fetch API、Cache API、Push API、postMessage API 和 Notification API，可以在基于浏览器的 web 应用中实现如离线缓存、消息推送、静默更新等 native 应用常见的功能，以给 web 应用提供更好更丰富的使用体验。</p><h4 id="Service-Worker兼容性"><a href="#Service-Worker兼容性" class="headerlink" title="Service Worker兼容性"></a>Service Worker兼容性</h4><p>参考<a href="http://caniuse.com/#feat=serviceworkers" target="_blank" rel="noopener">http://caniuse.com/#feat=serviceworkers</a><br><img src="https://raw.githubusercontent.com/geniuspeng/image-storage/master/blog/service-worker/sw-caniuse.png" alt="img"><br>当前，Edge已经竖起了小绿旗（默认不支持但可以手动开启），只剩下苹果的Safari还是一片红，虽然如此，不过最近似乎也开始在默默地搞起来了，支持sw只是时间的问题，至于IE嘛，不想多说。</p><h4 id="Service-Worker生命周期"><a href="#Service-Worker生命周期" class="headerlink" title="Service Worker生命周期"></a>Service Worker生命周期</h4><p>服务工作线程的生命周期完全独立于网页，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install -&gt; installed -&gt; actvating -&gt; Active -&gt; Activated -&gt; Redundant</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geniuspeng/image-storage/master/blog/service-worker/sw-lifecycle.png" alt="img"><br>要为网站安装服务工作线程，您需要先在页面的 JavaScript 中注册。 注册服务工作线程将会导致浏览器在后台启动服务工作线程安装步骤。</p><p>在安装过程中，您通常需要缓存某些静态资产。如果所有文件均已成功缓存，那么服务工作线程就安装完毕。如果任何文件下载失败或缓存失败，那么安装步骤将会失败，服务工作线程就无法激活（也就是说，不会安装）。 如果发生这种情况，不必担心，它下次会再试一次。 但这意味着，如果安装完成，您可以知道您已在缓存中获得那些静态资产。</p><p>安装之后，接下来就是激活步骤，这是管理旧缓存的绝佳机会，我们将在服务工作线程的更新部分对此详加介绍。</p><p>激活之后，服务工作线程将会对其作用域内的所有页面实施控制，不过，首次注册该服务工作线程的页面需要再次加载才会受其控制。服务工作线程实施控制后，它将处于以下两种状态之一：服务工作线程终止以节省内存，或处理获取和消息事件，从页面发出网络请求或消息后将会出现后一种状态。</p><h4 id="使用Service-Worker"><a href="#使用Service-Worker" class="headerlink" title="使用Service Worker"></a>使用Service Worker</h4><p>使用Service Worker有几个需要注意的地方，首先，要对一些前置的基础知识有一些了解，主要是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a>,以及前文提到的Fetch API，Cache API。<br>其次，由于一些不可描述的原因，Service Worker只能跑在HTTPS的服务器上，当然，Chrome等浏览器都对localhost跳过了安全认证，我们可以使用本地localhost进行调试。<br>这里主要介绍Service Worker的注册，以及相关事件的监听处理。</p><h5 id="注册Service-Worker"><a href="#注册Service-Worker" class="headerlink" title="注册Service Worker"></a>注册Service Worker</h5><p>Service Worker的注册不同于其他web workers，但是也很简单，只需要使用一个register方法即可，例如注册/sw/sw.js文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">navigator.serviceWorker</span><br><span class="line">         .register(<span class="string">'/sw/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/'</span>&#125;)</span><br><span class="line">         .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Service Worker Registered'</span>); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里有一个作用域的问题，如果你的sw.js写在/sw/路径下，不带第二个scope参数，Service worker只能监听/sw/路径下的fetch事件，而无法监听此目录外的fetch，使用scope可以改变这个作用域到根目录，对整个站点生效。另外Service Worker 没有页面作用域的概念，作用域范围内的所有页面请求都会被当前激活的 Service Worker 所监控。</p><h5 id="install事件"><a href="#install事件" class="headerlink" title="install事件"></a>install事件</h5><p>只有注册是在页面js内实现，而sw所有的事件处理都写在worker的js下。首先是install事件，当前脚本被安装时，会触发 install 事件，在这个事件里，通常会做一些缓存的添加处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cacheName = <span class="string">'my-cache'</span>;</span><br><span class="line"><span class="keyword">let</span> filesToCache = [</span><br><span class="line">  <span class="string">'/index.html'</span>,</span><br><span class="line">  <span class="string">'/js/test.js'</span>,</span><br><span class="line">  <span class="string">'/css/test.css'</span></span><br><span class="line">];</span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Install'</span>);</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(cacheName).then(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Caching app shell'</span>);</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(filesToCache);</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意这里的event参数，实际上是一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/InstallEvent" target="_blank" rel="noopener">InstallEvent</a>实例，它继承了父类<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ExtendableEvent" target="_blank" rel="noopener">ExtendableEvent</a>和Event的方法。<br>Event &lt;- ExtendableEvent &lt;- InstallEvent<br>而ExtendableEvent有一个独有的方法waitUnti(),这个方法接收一个Promise（或者async function），会阻塞当前事件的行为而优先执行该Promise，直到Promise结束，再继续进行当前事件。所以在install事件里一般在安装之前先把重要的app shell进行缓存，确切的说一般缓存的是用于离线展示的相关资源。需要注意的是，filesToCache全部缓存之后，才会执行install事件，也就是说如果waitUntil内的Promise没有成功，install事件将不会触发而导致Service worker安装失败而进入redundant (废弃)状态，所以这里应尽量减少filesToCache中的缓存资源。<br>安装成功后，即进入等待(waiting)或激活(active)状态。在激活状态可通过监听各种事件，实现更为复杂的逻辑需求。</p><h4 id="activate事件"><a href="#activate事件" class="headerlink" title="activate事件"></a>activate事件</h4><p>当安装完成后并进入激活状态，会触发 activate 事件。通过监听 activate 事件你可以做一些预处理，如对于旧版本的更新、对于无用缓存的清理等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Activate'</span>);</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keyList.map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== cacheName) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'[ServiceWorker] Removing old cache'</span>, key);</span><br><span class="line">          <span class="keyword">return</span> caches.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> self.clients.claim();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的event同样继承了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ExtendableEvent" target="_blank" rel="noopener">ExtendableEvent</a>，在这里对CacheStorage对象进行遍历，将过期的cache进行一个移除操作，及时清理CacheStorage的存储空间。<br>waitUntil阻塞activate事件，这可以确保清理操作会在第一次 fetch 事件之前完成。<br>在激活时执行clients.claim 方法，更新所有客户端上的 Service Worker。</p><h4 id="fetch事件"><a href="#fetch事件" class="headerlink" title="fetch事件"></a>fetch事件</h4><p>当浏览器发起请求时，会触发 fetch 事件。<br>Service Worker 安装成功并进入激活状态后即运行于浏览器后台，可以通过 fetch 事件可以拦截到当前作用域范围内的 http/https 请求，并且给出自己的响应。结合 Fetch API ，可以简单方便地处理请求响应，实现对网络请求的控制。这个功能十分强大，可以说是PWA的核心功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[Service Worker] Fetch'</span>, e.request.url);</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> response || fetch(e.request);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此处的参数是一个FetchEvent的实例，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent" target="_blank" rel="noopener">FetchEvent</a>继承了Event的属性和方法，同时拥有自己的方法respondWith。<br>FetchEvent 接口的 respondWith() 方法旨在包裹代码，这些代码为来自页面的request生成自定义的response。这些代码通过返回一个 Response 、 network error 或者 Fetch的方式resolve。</p><h4 id="push事件"><a href="#push事件" class="headerlink" title="push事件"></a>push事件</h4><p>push 事件是为推送准备的。不过首先你需要了解一下 Notification API 和 PUSH API。</p><p>通过 PUSH API，当订阅了推送服务后，可以使用推送方式唤醒 ServiceWorker 以响应来自系统消息传递服务的消息，即使用户已经关闭了页面。</p><p>推送的实现有两步：</p><p>不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging<gcm> 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通）。</gcm></p><h4 id="sync事件"><a href="#sync事件" class="headerlink" title="sync事件"></a>sync事件</h4><p>sync事件由background sync发出，是一种后台同步事件。background sync 是 Google 配合 SW 推出的 API，用于为 SW 提供一个可以实现注册和监听同步处理的方法。但它还不在 W3C WEB API 标准中。在 Chrome 中这也只是一个实验性功能，需要访问 chrome://flags/#enable-experimental-web-platform-features ，开启该功能，然后重启生效。<br>后台同步功能允许你一次性或按间隔请求后台数据同步，可以配合其他API实现一些很强大的功能如定时推送，定时更新等。用户无需打开页面，只要唤醒了Service Worker，就可以收到sync事件。<br>在页面注册sync事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register your service worker:</span></span><br><span class="line">navigator.serviceWorker.register(<span class="string">'/sw.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then later, request a one-off sync:</span></span><br><span class="line">navigator.serviceWorker.ready.then(<span class="function"><span class="keyword">function</span>(<span class="params">swRegistration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> swRegistration.sync.register(<span class="string">'myFirstSync'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在sw.js中监听sync事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'sync'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.tag == <span class="string">'myFirstSync'</span>) &#123;</span><br><span class="line">    event.waitUntil(doSomeStuff());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一个很酷的地方在于，sync事件可以在离线时发出，ServiceWorker会记住发出的事件，并且在重新联网时做出响应，这可以解决我们实际生活中很多不必要的“时间浪费”，比如我们提交某个表单，提交的时候可能网络不好等了好久，最后还没提交成功又要重新填写表单数据，有了sync时间我们完全不必考虑网络情况，让后台同步解决就可以了。</p><h4 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h4><p>前面说过，ServiceWorker同其他Worker一样，运行于一个独立的沙盒中，无法访问DOM等页面相关的信息，但我们可以通过 postMessage<br>API，实现Service Worker与页面之间的通信。</p><h5 id="页面向SW发消息"><a href="#页面向SW发消息" class="headerlink" title="页面向SW发消息"></a>页面向SW发消息</h5><p>首先在sw注册之后，才可以navigator.serviceWorker.controller句柄。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sendMessageToSW = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  navigator.serviceWorker.controller &amp;&amp; navigator.serviceWorker.controller.postMessage(msg);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">           .register(<span class="string">'/service-worker.js'</span>)</span><br><span class="line">           .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Service Worker Registered'</span>); &#125;)</span><br><span class="line">           .then(<span class="function"><span class="params">()</span> =&gt;</span> sendMessageToSW(<span class="string">'hello sw!'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在sw.js监听message事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>反过来 service worker 给主页面发消息就要复杂一点了。在 service worker 里发送信息需要通过 Client 对象的 postMessage 方法。获取 Client 的方法有很多，比如，刚从主页面发来的消息，事件的来源就是一个 Client 对象，即 event.source。不过，这只能向来源发消息，但如果你开了几个网页，或者不是通过主页消息发来的该怎么办哪？方法还是有的，在 service workers 中可以通过 clients 来获取所有的页面对象或其他的 service workers。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.clients.matchAll().then(<span class="function"><span class="keyword">function</span>(<span class="params">clientList</span>) </span>&#123;</span><br><span class="line">    clientList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">        client.postMessage(<span class="string">'Service worker attached.'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意这里的postMessage都不是window作用域下的，而是页面中的navigator.serviceWorker.controller下面的postMessage，同样Service Worker下拥有client的postMessage方法可以实现从Service Worker向页面发送消息。</p><h4 id="online-offline事件"><a href="#online-offline事件" class="headerlink" title="online/offline事件"></a>online/offline事件</h4><p>当网络状态发生变化时，会触发 online 或 offline 事件。结合这两个事件，可以与 Service Worker 结合实现更好的离线使用体验，例如当网络发生改变时，替换/隐藏需要在线状态才能使用的链接导航等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'离线了'</span>)</span><br><span class="line">  Notification.requestPermission().then(<span class="function">(<span class="params">grant</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grant !== <span class="string">'granted'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> notification = <span class="keyword">new</span> Notification(<span class="string">"网络挂掉了哦~"</span>, &#123;</span><br><span class="line">      body: <span class="string">'虽然离线了，但是我还可以访问'</span>,</span><br><span class="line">      icon: <span class="string">'http://si1.go2yd.com/get-image/0Gp8bLbHOkK'</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Service-Worker调试"><a href="#Service-Worker调试" class="headerlink" title="Service Worker调试"></a>Service Worker调试</h3><p>在 Chrome 中，service worker 的信息显示在 Application -&gt; Service Workers 中，就像这样</p><p>一些旧版本的Chrome可能把sw放在一个单独的地方，这时我们需要通过手动点击Service Worker后面的inspect来唤起调试窗口。<br>调试Service Worker可能是一项挑战，并且在涉及缓存的情况下，如果缓存未在您预期的时间进行更新，就可能变成一场更可怕的恶梦。典型Service Worker生命周期和代码错误的双重夹击可能很快令您感到失望。但请不要失望。您可以利用一些工具来改善自己的处境。</p><h3 id="Service-Worker更新"><a href="#Service-Worker更新" class="headerlink" title="Service Worker更新"></a>Service Worker更新</h3><p>如果 sw.js 文件的内容有改动，当访问网站页面时浏览器获取了新的文件，它会认为有更新，于是会安装新的文件并触发 install 事件。但是此时已经处于激活状态的旧的 Service Worker 还在运行，新的 Service Worker 完成安装后会进入 waiting 状态。直到所有已打开的页面都关闭，旧的 Service Worker 自动停止，新的 Service Worker 才会在接下来打开的页面里生效。<br>可以在 install 事件中执行 skipWaiting 方法跳过 waiting 状态，然后会直接进入 activate 阶段。接着在 activate 事件发生时，通过执行 clients.claim 方法，更新所有客户端上的 Service Worker。示例：</p><h3 id="一些参考链接"><a href="#一些参考链接" class="headerlink" title="一些参考链接"></a>一些参考链接</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener">MDN Cache</a></li><li><a href="https://zhuanlan.zhihu.com/p/27586862" target="_blank" rel="noopener">解锁缓存新姿势——更灵活的 Cache</a></li><li><a href="https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/?hl=zh-cn#_17" target="_blank" rel="noopener">your-first-pwapp</a></li><li><a href="https://github.com/camsong/blog/issues/2" target="_blank" rel="noopener">Fetch</a></li><li><a href="http://bubkoo.com/2015/05/08/introduction-to-fetch/" target="_blank" rel="noopener">fetch API 简介</a></li><li><a href="https://segmentfault.com/a/1190000010911535" target="_blank" rel="noopener">前端每周清单半年盘点之 PWA 篇</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在2014年，W3C公布了service worker的草案，service worker提供了很多新的能力，使得web app拥有与native app相同的离线体验、消息推送体验。&lt;br&gt;Service Worker是PWA的核心。谷歌给以 Service Worker API 为核心实现的 web 应用取了个高大上的名字：Progressive Web Apps（PWA，渐进式增强 WEB 应用），并且在其主要产品上进行了深入的实践。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.locusland.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="WebApp" scheme="http://blog.locusland.xyz/tags/WebApp/"/>
    
  </entry>
  
  <entry>
    <title>PWA:cache篇</title>
    <link href="http://blog.locusland.xyz/2017/09/19/pwa-cache/"/>
    <id>http://blog.locusland.xyz/2017/09/19/pwa-cache/</id>
    <published>2017-09-19T01:58:51.000Z</published>
    <updated>2017-12-28T02:52:08.305Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章介绍了Fetch API，这里主要介绍Service Worker API的另一个重要成员：Cache API。Cache 接口提供缓存的 Request / Response 对象对的存储机制，例如作为ServiceWorker 生命周期的一部分。 Cache 接口像 workers 一样, 是暴露在 window 作用域下的。尽管它被定义在 service worker 的标准中,  但是它不必一定要配合 service worker 使用。<br><a id="more"></a></p><h3 id="Cache-和-CacheStorage"><a href="#Cache-和-CacheStorage" class="headerlink" title="Cache 和 CacheStorage"></a>Cache 和 CacheStorage</h3><p>Cache 和 CacheStorage是两个不同的东西。Cache直接和请求打交道，CacheStorage和Cache对象打交道。通俗点来说，Cachestorage对象可以看作是当前域名下所有Cache对象的集合体，它提供了一系列接口去操作Cache对象，可以通过暴露在window中的caches属性来访问。例如，虽然API上显示的是CacheStorage.open()，但我们实际使用的时候，直接使用caches.open()。使用CacheStorage.open()打开一个Cache对象，就可以使用 Cache 对象的方法去处理缓存了。<br>你需要定期地清理缓存条目, 因为每个浏览器都严格限制了一个域下缓存数据的大小。 浏览器尽其所能去管理磁盘空间，浏览器有可能去删除一个域下的缓存数据，确保你的代码可以安全地操作缓存。</p><h3 id="了解CacheStorage"><a href="#了解CacheStorage" class="headerlink" title="了解CacheStorage"></a>了解CacheStorage</h3><p>刚刚提到过CacheStorage主要用来管理Cache对象，在 W3C 规范中，CacheStorage 对应到内核的 ServiceWorkerCacheStorage 对象。它提供了很多JS接口用于操作Cache 对象，这些接口均返回一个Promise对象：</p><ul><li>CacheStorage.open(cacheName) 用于获取一个 Cache 对象实例。传入一个cacheName，resolve结果是cacheName对应的Cache对象。</li><li>CacheStorage.match(request, options) 用于检查 CacheStorage 中是否存在以Request 为 key 的 Cache 对象。传入一个Request对象（或者url），resolve结果是对应Request所匹配的Response对象。</li><li>CacheStorage.has(cacheName) 用于检查是否存在指定名称的 Cache 对象。resolve结果是true或者false。</li><li>CacheStorage.keys() 用于返回 CacheStorage 中所有 Cache 对象的 cacheName 列表。resolve结果是对应的keyList。</li><li>CacheStorage.delete(cacheName) 用于删除指定 cacheName 的 Cache 对象。根据删除是否成功resolve对应的true或者false。</li></ul><p>一些注意事项：</p><ul><li>任意 CacheStorage 方法的调用，都有机会引起创建 ServiceWorkerCacheStorage 对象。</li><li>ServiceWorkerCacheStorageManager 维护一个 cache_storage<em>map</em>（std::map<gurl, serviceworkercachestorage*="">），这个 map 管理了所有的 origin + ServiceWorkerCacheStorage。</gurl,></li><li>任何一个域名只会创建一个 ServiceWorkerCacheStorage 对象,同一域名下的CacheStorage存储在一个目录。</li><li>ServiceWorkerCacheStorage 维护一个 cache<em>map</em>（std::map<std::string, base::weakptr<serviceworkercache=""> &gt;），这个 map 管理了同一 origin 下所有的 cacheName + ServiceWorkerCache。</std::string,></li></ul><p>前端从这些情况可以得到哪些信息呢？资源的存储不是按照资源的域名处理的，而是按照 Service Worker 的 origin 来处理，所以 Cache 的资源是无法跨域共享的，意思就是说，不同域的 Service Worker 无法共享使用对方的 Cache，即使是 Foreign Cache 请求的跨域资源，同样也是存放在这个 origin 之下。因为 ServiceWorkerCache 通过 cacheName 标记缓存版本，所以就会存在多个版本的 ServiceWorkerCache 资源。为什么需要 cacheName 来标记版本呢？</p><p>假设当前域名下所有的覆盖式发布的静态资源和接口数据全部存储在同一个 cacheName 里面，业务部署更新后，无法识别旧的冗余资源，单靠前端无法完全清除。这是因为 Service Worker 不知道完整的静态资源路径表，只能在客户端发起请求时去做判断，那些当前不会用到的资源不代表以后一定不会使用到。假如静态资源是非覆盖式发布，那么冗余的资源就更多了。这里要特别注意的是，Cache 不会过期，只能显式删除。</p><p>如果版本更新后，更换 cacheName，这意味着旧 cacheName 的资源是不会使用到了，业务逻辑可以放心的把旧 cacheName 对应的所有资源全部清除，而无需知道完整的静态资源路径表。</p><h3 id="了解Cache"><a href="#了解Cache" class="headerlink" title="了解Cache"></a>了解Cache</h3><p>一个域可以有多个 Cache 对象.  你将在你的代码中处理和更新缓存 (e.g. in a ServiceWorker) . 在 Cache 除非显示地更新缓存, 否则缓存将不会被更新; 缓存数据不会过期, 除非删除它. 使用 CacheStorage.open(cacheName) 打开一个Cache 对象, 再使用 Cache 对象的方法去处理缓存.<br>规范里 Cache 对应内核的 ServiceWorkerCache 对象，提供了已缓存的 Request / Response 对象体的存储管理机制。它提供了一系列管理存储的JS接口，除了add，addAll和put这三个用于添加cache的方法，其他接口接口同样统统返回一个Promise对象：</p><ul><li>Cache.match(request, options) 用于查找是否存在以 Request 为 key 的Cache 对象，resolve的结果是跟 Cache 对象匹配的第一个已经缓存的请求。</li><li>Cache.matchAll(request, options) 用于查找是否存在一组以 Request 为 key 的 Cache 对象组，resolve的结果是跟 Cache 对象匹配的所有请求组成的数组。</li><li>Cache.put(request, response)，同时抓取一个请求及其响应，并将其添加到给定的cache。</li><li>Cache.add(request)用于抓取这个URL, 检索并把返回的response对象添加到给定的Cache对象.这在功能上等同于调用 fetch(), 然后使用 Cache.put() 将response添加到cache中.</li><li>Cache.addAll(requests)，抓取一个URL数组，检索并把返回的response对象添加到给定的Cache对象。</li><li>Cache.delete(request, options)，搜索key值为request的Cache 条目。如果找到，则删除该Cache 条目，并且返回一个resolve为true的Promise对象；如果未找到，则返回一个resolve为false的Promise对象。</li><li>Cache.keys(request, options)，返回一个Promise对象，resolve的结果是Cache对象key值组成的数组。</li></ul><p>说到存储，那必然会涉及到存储的容量大小，Service Worker 规范并没有明确规定 ServiceWorkerCache 的容量限制，在 Chromium 50 以下版本的内核限制为 512M，Chromium 50 及以上版本内核不作限制（即为std::numeric_limits<int>::max）。当然，这只是 Service Worker 层面的限制，它还会受浏览器 QuotaManager 的限制。</int></p><p>一般来说，Service Worker 层面对 ServiceWorkerCache 的限制都会大于浏览器对每个域名的限制，所以，通常可理解为，ServiceWorkerCache 仅受浏览器 容量管理系统（QuotaManager） 对域名可使用存储的限制。对于前端开发同学来说，必须有清理冗余缓存的业务逻辑，并且提高缓存资源的使用率。</p><p>关于它与http cache的区别，HTTP Cache 中，一个 URL 只能对应一个 Response，但 Cache API 规范要求同一 URL（不同的 Header）可以对应多个 Response，另外，HTTP Cache 没有使用容量管理系统（QuotaManager）而 Cache API 需要使用。当 Service Worker 从 Cache 拿不到资源时，就会去 http cache 查找，找不到才去请求网络。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章介绍了Fetch API，这里主要介绍Service Worker API的另一个重要成员：Cache API。Cache 接口提供缓存的 Request / Response 对象对的存储机制，例如作为ServiceWorker 生命周期的一部分。 Cache 接口像 workers 一样, 是暴露在 window 作用域下的。尽管它被定义在 service worker 的标准中,  但是它不必一定要配合 service worker 使用。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.locusland.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="WebApp" scheme="http://blog.locusland.xyz/tags/WebApp/"/>
    
  </entry>
  
  <entry>
    <title>PWA：fetch API</title>
    <link href="http://blog.locusland.xyz/2017/09/14/pwa-fetch/"/>
    <id>http://blog.locusland.xyz/2017/09/14/pwa-fetch/</id>
    <published>2017-09-14T07:27:23.000Z</published>
    <updated>2017-12-25T03:37:26.158Z</updated>
    
    <content type="html"><![CDATA[<p>第一次听PWA（Progressive Web App）这个词，还是在刚入职的时候。当时刚入坑前端几个月的我还是一脸萌币的状态，只是有一种不明觉厉的感觉。后来忙来忙去的也就扔在一边了，然后最近看到裕波大大的一篇文章：<a href="https://zhuanlan.zhihu.com/p/28293894" target="_blank" rel="noopener">震惊！苹果向开发者低头？！！开始支持Service Worker</a>,之前都是说这东西在国内发展不起来主要是因为国内的果粉太多，而苹果对ServiceWork一直处于冷漠的观望态度- -实际上，好像并没有那么冷漠233333…废话完毕，把最近学到的东西整理下：<br><a id="more"></a></p><h3 id="打算分三个方面吧："><a href="#打算分三个方面吧：" class="headerlink" title="打算分三个方面吧："></a>打算分三个方面吧：</h3><ol><li>Fetch API</li><li>Cache API</li><li>Service Worker</li></ol><h3 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h3><p>嗯这里主要讲fetch。其实说到底，fetch API和PWA关系并不是很大(但还是要了解这个东东)，而且Fetch API并不是为了PWA而生的，确切的说，我倒是觉得这货是为了取代Ajax的XMLHttpRequest而生的。先看一下fetch的基本用法（取自<a href="https://www.sitepoint.com/introduction-to-the-fetch-api/" target="_blank" rel="noopener">Introduction to the Fetch API</a>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* API URL, you need to supply your API key */</span></span><br><span class="line"><span class="keyword">var</span> URL = <span class="string">'https://api.flickr.com/services/rest/?method=flickr.photos.search&amp;api_key=your_api_key&amp;format=json&amp;nojsoncallback=1&amp;tags=penguins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fetch(URL).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    insertPhotos(json);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetchDemo();</span><br></pre></td></tr></table></figure><p>fetch可以接受两个参数，基本语法为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise&lt;Response&gt; fetch(input[, init]);</span><br></pre></td></tr></table></figure><p>第一个参数input可以是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/USVString" target="_blank" rel="noopener">USVString</a> 字符串，包含要获取资源的 URL，也可以是一个Request对象。第二个参数init是一个可选的配置对象，详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch" target="_blank" rel="noopener">这里</a>。<br>返回值是一个Promise对象，resolve结果为该请求对应的Response对象。</p><h3 id="Request-amp-amp-Response"><a href="#Request-amp-amp-Response" class="headerlink" title="Request &amp;&amp; Response"></a>Request &amp;&amp; Response</h3><p>Fetch引入了三个接口：Headers，Request和Response。<br>上面提到了Request对象和Response对象，这两个对象用来表示Fetch API的资源请求和响应。<br>你可以使用  Request.Request() 构造函数创建一个 Request 对象，Request对象也可能被其他API返回，比如一个 service worker FetchEvent.request。Request对象接受两个参数，这两个参数和Fetch接受的参数一模一样,其中headers可以通过Headers对象生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line">headers.append(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>);</span><br><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> Request(URL, &#123;</span><br><span class="line">method: <span class="string">'GET'</span>,</span><br><span class="line">header: headers, </span><br><span class="line">cache: <span class="string">'reload'</span></span><br><span class="line">&#125;);</span><br><span class="line">fetch(req).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  insertPhotos(json);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而且，我们可以从一个Request去生成另一个Request，下面的例子通过一个GET类型的Request，使用相同的配置新建了一个POST类型的Request。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postReq = <span class="keyword">new</span> Request(req, &#123;<span class="attr">method</span>: <span class="string">'POST'</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>同样的，我们可以使用Response的构造器建立一个Response对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myResponse = <span class="keyword">new</span> Response();</span><br></pre></td></tr></table></figure><p>Response对象的相关属性可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response" target="_blank" rel="noopener">MDN</a>。<br>尽管如此，我们实际上使用的Response对象大多都是其他API返回的，比如Fetch API，之前也说过，Fetch API返回的promise对象resolve的结果就是一个Response对象。</p><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Request和Response对象都实现了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body" target="_blank" rel="noopener">Body</a>对象的方法。<br>body可以是以下类型的实例：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView" target="_blank" rel="noopener">ArrayBufferView</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank" rel="noopener">File</a></li><li>String</li><li><a href="https://url.spec.whatwg.org/#interface-urlsearchparams" target="_blank" rel="noopener">URLSearchParams</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" target="_blank" rel="noopener">FormData</a></li></ul><p>Request和Response都为他们的body提供了以下方法，这些方法都返回一个Promise对象：</p><ul><li>arrayBuffer()</li><li>blob()</li><li>json()</li><li>text()</li><li>formData()</li></ul><h3 id="WHY-FETCH？"><a href="#WHY-FETCH？" class="headerlink" title="WHY FETCH？"></a>WHY FETCH？</h3><p>使用XHR发起一个请求一般是这样： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, url);</span><br><span class="line">xhr.responseType = <span class="string">'json'</span>;</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>而使用fetch：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>即使我们现在有jquery等类库对ajax进行了完美的封装，但xhr终归是一个设计较为粗糙的API，配置和调用起来并不是那么友好，而且基于事件的异步模型写起来也没有现代的Promise，而Request和Response对象遵循HTTP协议规范设计，而且基于Promise实现，配合现在的箭头函数，async/await可以更好地表现。在使用非文本方面，Body提供的相应方法使得Fetch API和XHR相比提供了极大的便利。<br>这里可能有人会有个疑问：Response就应该是请求来返回的，我们在浏览器端制造Response对象有什么意义？Service Workers API会告诉你答案。</p><h3 id="一些常见的坑"><a href="#一些常见的坑" class="headerlink" title="一些常见的坑"></a>一些常见的坑</h3><ol><li>首先，Fetch API发起的请求默认是不带cookie的，如果需要携带cookie请设置 fetch(url, {credentials: ‘include’})。</li><li>服务器返回 400，500 错误码时并不会 reject，仅仅是Response的ok字段变为false，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li><li>关于跨域，Fetch的第二个参数对象有一个 mode 属性，mode 属性用来决定是否允许跨域请求，以及哪些response属性可读。可选的mode属性值为 same-origin ， no-cors （默认）以及 cors 。</li></ol><ul><li>same-origin 模式很简单，如果一个请求是跨域的，那么返回一个简单的error，这样确保所有的请求遵守同源策略。</li><li>no-cors 模式允许来自CDN的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的method只能是”HEAD”,”GET”或者”POST”。此外，任何 ServiceWorkers 拦截了这些请求，它不能随意添加或者改写任何headers，除了<a href="https://fetch.spec.whatwg.org/#simple-header" target="_blank" rel="noopener">这些</a> 。JavaScript不能访问Response中的任何属性，这保证了 ServiceWorkers 不会导致任何跨域下的安全问题而隐私信息泄漏。</li><li>cors 模式我们通常用作跨域请求来从第三方提供的API获取数据。这个模式遵守 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">CORS协议</a> 。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次听PWA（Progressive Web App）这个词，还是在刚入职的时候。当时刚入坑前端几个月的我还是一脸萌币的状态，只是有一种不明觉厉的感觉。后来忙来忙去的也就扔在一边了，然后最近看到裕波大大的一篇文章：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28293894&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;震惊！苹果向开发者低头？！！开始支持Service Worker&lt;/a&gt;,之前都是说这东西在国内发展不起来主要是因为国内的果粉太多，而苹果对ServiceWork一直处于冷漠的观望态度- -实际上，好像并没有那么冷漠233333…废话完毕，把最近学到的东西整理下：&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.locusland.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="WebApp" scheme="http://blog.locusland.xyz/tags/WebApp/"/>
    
  </entry>
  
  <entry>
    <title>那些移动端web踩过的坑</title>
    <link href="http://blog.locusland.xyz/2017/08/24/mobile-issues/"/>
    <id>http://blog.locusland.xyz/2017/08/24/mobile-issues/</id>
    <published>2017-08-24T07:43:38.000Z</published>
    <updated>2017-12-25T03:37:26.154Z</updated>
    
    <content type="html"><![CDATA[<p>扔了N久，还是捡回来了。好好弄一下吧。刚工作的时候挺忙的，后来不那么忙了，但是变懒了。<br>这一年大多数时间都在在做移动端的东东，做了之后才发现，同样是web前端，移动端的坑真的是深不可测，各种各样的，只有想不到，没有遇不到。在这里把最近踩过的坑整理一下。<br><a id="more"></a></p><h3 id="No-1-大字体问题"><a href="#No-1-大字体问题" class="headerlink" title="No.1 大字体问题"></a>No.1 大字体问题</h3><p>首先，要解决的关键问题是如何为设备选择可视视口尺寸，采用理想视口尺寸作为可视视口尺寸，代码也十分简单，只需要将缩放比定为 1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1,maximum-scale=1, minimum-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之所以把它放在第一个也是因为这个印象最深，记得第一次做移动端html5页面的时候，啥都不懂，还在用px作为像素单位，当然这个px是相对的（关于px可参考<a href="https://lscho.com/tech/css_company.html" target="_blank" rel="noopener">css 长度单位知多少</a>），然而在移动端使用px是相当不靠谱的，随随便便换一个大小不一样的设备，可能就会出现样式错乱。。。当然后来使用了rem，众所周知1rem=1 htmlFontSize,所以这里只要我们把html的字体大小事先定好，就可以基本上解决字体的适配问题。那么怎么选择这个htmlFontSize呢？<br>一般UI的设计稿都是3倍大小，这里已1080为例子（我拿到的一般都是1080的），实际上就是360px宽度的device，比如我自己习惯上想让1rem=100px(这里的px是实际像素，相当于设计稿的300像素)，那么问题关键就在于，htmlFontSize的多少px正好对应设计稿的300px，那么根元素html的fontsize（设为fz）与设备实际宽度(设为dw)的对应关系应为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dw/1080 = fz/300</span><br><span class="line">fz = dw/3.6</span><br></pre></td></tr></table></figure><p>这样，你的设备宽度用rem表示其实就是3.6rem，即使不是360px，也可以按比例来缩放，而设计稿中的每300px对应为1rem，使用rem布局，字体大小就可以随着设备宽度来自己调整。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRootFontSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="keyword">var</span> dw = r.getBoundingClientRect().width;</span><br><span class="line">  <span class="keyword">var</span> fz = ~~( dw &lt;= <span class="number">720</span> ? dw : <span class="number">720</span> ) / <span class="number">3.6</span>;</span><br><span class="line">  r.style.fontSize = fz + <span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setRootFontSize);</span><br><span class="line">setRootFontSize();</span><br></pre></td></tr></table></figure><p>这段代码基本上可以满足字体在移动端的自适应要求，可是如果用户主动把设备字体调大，也就是1px对应的大小变大，字体虽然px数不变，显示还是会变大，而有些比较复杂的h5页面字体稍微有些变化就会有问题，所以有时候还需要限定页面的字体大小不随设备字体的调整而影响，这时需要用到getComputedStyle这个方法，getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值（可参考<a href="http://www.zhangxinxu.com/wordpress/2012/05/getcomputedstyle-js-getpropertyvalue-currentstyle/" target="_blank" rel="noopener">获取元素CSS值之getComputedStyle方法熟悉</a>）。通过对比算出来的fz和实际的realfz，对其进行相应缩放即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRootFontSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="keyword">var</span> dw = r.getBoundingClientRect().width;</span><br><span class="line">  <span class="keyword">var</span> fz = ~~( dw &lt;= <span class="number">720</span> ? dw : <span class="number">720</span> ) / <span class="number">3.6</span>;</span><br><span class="line">  r.style.fontSize = fz + <span class="string">"px"</span>;</span><br><span class="line">  <span class="keyword">var</span> realfz = ~~(+<span class="built_in">window</span>.getComputedStyle(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"html"</span>)[<span class="number">0</span>]).fontSize.replace(<span class="string">'px'</span>,<span class="string">''</span>) * <span class="number">10000</span>) / <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">if</span>(fz !== realfz)&#123; r.style.fontSize = fz *(fz / realfz) + <span class="string">"px"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setRootFontSize);</span><br><span class="line">setRootFontSize();</span><br></pre></td></tr></table></figure><h3 id="No-2-滚动时最底层（或顶层）回弹问题"><a href="#No-2-滚动时最底层（或顶层）回弹问题" class="headerlink" title="No.2 滚动时最底层（或顶层）回弹问题"></a>No.2 滚动时最底层（或顶层）回弹问题</h3><p>这个坑应该做过移动端的都踩过（只是大多数情况根本不算坑，然而我要做的东西基本上都要禁掉这玩意），试过很多方法，都不是很理想，最终的解决方案就是禁用父级元素的滚动，手动模拟滚动条：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scroll = <span class="function"><span class="keyword">function</span>(<span class="params">container, childSelector, style</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!container || !container.length) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(container <span class="keyword">instanceof</span> $)) &#123;</span><br><span class="line">    container = $(container);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (container.css(<span class="string">'position'</span>) === <span class="string">'static'</span>) &#123;</span><br><span class="line">    container.css(<span class="string">'position'</span>, <span class="string">'relative'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> child = container.find(childSelector);</span><br><span class="line">  child.css(&#123;</span><br><span class="line">    <span class="string">'transform'</span>: <span class="string">'translate3d(0px, 0px, 0px)'</span>,</span><br><span class="line">    <span class="string">'-webkit-transform'</span>: <span class="string">'translate3d(0px, 0px, 0px)'</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> childTop = <span class="number">0</span>; <span class="comment">//距离容器顶部的距离 </span></span><br><span class="line">  <span class="keyword">var</span> conHeight = container.height(); <span class="comment">//容器高度</span></span><br><span class="line">  <span class="keyword">var</span> childHeight = child.height(); <span class="comment">//子容器高度</span></span><br><span class="line">  <span class="keyword">var</span> diffHeight = conHeight - childHeight; <span class="comment">//父子容器高度差</span></span><br><span class="line">  <span class="keyword">var</span> clientY = <span class="number">0</span>; <span class="comment">//手指在当前对象上触摸时的坐标</span></span><br><span class="line">  <span class="comment">//添加滚动条</span></span><br><span class="line">  <span class="keyword">var</span> defaultStyle = &#123;</span><br><span class="line">    width: <span class="string">'6px'</span>,</span><br><span class="line">    position: <span class="string">'absolute'</span>,</span><br><span class="line">    <span class="string">'border-radius'</span>: <span class="string">'10000px'</span>,</span><br><span class="line">    <span class="string">'background-color'</span>: <span class="string">'rgba(0, 0, 0, 0.3)'</span>,</span><br><span class="line">    <span class="string">'pointer-events'</span>: <span class="string">'none'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  $.extend(defaultStyle, style);</span><br><span class="line">  <span class="keyword">if</span> (!defaultStyle.height) &#123;</span><br><span class="line">    <span class="keyword">if</span> (diffHeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      defaultStyle.height = conHeight/childHeight * (conHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      defaultStyle.height = <span class="string">'0px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!defaultStyle.top &amp;&amp; !defaultStyle.right &amp;&amp; !defaultStyle.bottom &amp;&amp; !defaultStyle.left) &#123;</span><br><span class="line">    defaultStyle.top = <span class="number">0</span>;</span><br><span class="line">    defaultStyle.right = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> scrollBar = $(<span class="string">'&lt;section class="scroll-bar ui-scroll-bar"&gt;&lt;section&gt;'</span>);</span><br><span class="line">  scrollBar.css(defaultStyle);</span><br><span class="line">  container.find(<span class="string">'.scroll-bar'</span>).remove();</span><br><span class="line">  container.append(scrollBar);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定前先移除事件</span></span><br><span class="line">  container.off(<span class="string">'touchstart'</span>);</span><br><span class="line">  container.off(<span class="string">'touchmove'</span>);</span><br><span class="line">  container.on(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    childTop = child.position().top;</span><br><span class="line">    clientY = e.targetTouches[<span class="number">0</span>].clientY;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  container.on(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (diffHeight &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> curClientY = e.targetTouches[<span class="number">0</span>].clientY;</span><br><span class="line">    <span class="keyword">var</span> tempTop = childTop + (curClientY - clientY);</span><br><span class="line">    <span class="keyword">if</span> (tempTop &lt;= diffHeight) &#123;</span><br><span class="line">      tempTop = diffHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tempTop &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      tempTop = <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    child.css(&#123;</span><br><span class="line">      <span class="string">'transform'</span>: <span class="string">'translate3d(0px, '</span> + tempTop + <span class="string">'px, 0px)'</span>,</span><br><span class="line">      <span class="string">'-webkit-transform'</span>: <span class="string">'translate3d(0px, '</span> + tempTop + <span class="string">'px, 0px)'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    scrollBar.css(&#123;</span><br><span class="line">      <span class="string">'transform'</span>: <span class="string">'translate3d(0px, '</span> + (-tempTop* (conHeight/childHeight)) + <span class="string">'px, 0px)'</span>,</span><br><span class="line">      <span class="string">'-webkit-transform'</span>: <span class="string">'translate3d(0px, '</span> + (-tempTop* (conHeight/childHeight)) + <span class="string">'px, 0px)'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">scroll($(<span class="string">'.parent'</span>), <span class="string">'.child'</span>)</span><br></pre></td></tr></table></figure><p>原理其实还是很简单，先计算一下滚动条的高度，然后按照比例去设置transform（还有很多可优化扩展的地方），第一个参数是父元素的zepto（或jquery）选择器对象,第二个参数是需要滚动的子元素包裹层，第三个是滚动条的样式（可选，有默认），需要把parent元素设置为overflow：hidden，child元素的height设置为auto。</p><h3 id="No-3-Modal弹出层滚动带动底层一起滚动"><a href="#No-3-Modal弹出层滚动带动底层一起滚动" class="headerlink" title="No.3 Modal弹出层滚动带动底层一起滚动"></a>No.3 Modal弹出层滚动带动底层一起滚动</h3><p>这个也是只有移动端才有的坑，类似与一种穿透吧，手指在弹出层滑动的同时，如果底层有滚动条的话也会跟着一起滑动,解决方案:<br>css添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*禁止modal底层滚动*/</span></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.dialog-open</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SCROLL_TOP = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*禁止modal带动底部滚动*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">to</span>(<span class="params">scrollTop</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.scrollTop = <span class="built_in">document</span>.documentElement.scrollTop = scrollTop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollTop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*modal弹出时使用*/</span></span><br><span class="line">SCROLL_TOP = getScrollTop();</span><br><span class="line"><span class="built_in">document</span>.body.classList.add(<span class="string">'dialog-open'</span>); </span><br><span class="line"><span class="built_in">document</span>.body.style.top = -SCROLL_TOP + <span class="string">'px'</span>;</span><br><span class="line"><span class="comment">/*modal关闭时使用*/</span></span><br><span class="line">to(SCROLL_TOP);</span><br></pre></td></tr></table></figure><h3 id="No-4-tap事件穿透"><a href="#No-4-tap事件穿透" class="headerlink" title="No.4 tap事件穿透"></a>No.4 tap事件穿透</h3><p>这算是zepto的一个bug了，具体这个bug的源头还得追到zepto对于tap事件的模拟（参考<a href="https://segmentfault.com/a/1190000003848737" target="_blank" rel="noopener">也来说说touch事件与点击穿透问题</a>），我后来用的解决方法也是参考这里来的，就是使用pointer-events这个属性，这里就不多介绍了,这里的第三种方法，使用<a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">fastclick</a>库模拟click也可以完美解决移动端的点穿问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#closePopup'</span>).on(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    $(<span class="string">'#popupLayer'</span>).hide();</span><br><span class="line">    $(<span class="string">'#bgMask'</span>).hide();</span><br><span class="line"></span><br><span class="line">    $(<span class="string">'#underLayer'</span>).css(<span class="string">'pointer-events'</span>, <span class="string">'none'</span>);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">'#underLayer'</span>).css(<span class="string">'pointer-events'</span>, <span class="string">'auto'</span>);</span><br><span class="line">    &#125;, <span class="number">400</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="http://www.zhangxinxu.com/wordpress/2012/05/getcomputedstyle-js-getpropertyvalue-currentstyle/" target="_blank" rel="noopener">获取元素CSS值之getComputedStyle方法熟悉</a></li><li><a href="https://lscho.com/tech/css_company.html" target="_blank" rel="noopener">css 长度单位知多少</a></li><li><a href="https://zhuanlan.zhihu.com/p/25216275" target="_blank" rel="noopener">网易和淘宝移动WEB适配方案再分析</a></li><li><a href="https://segmentfault.com/a/1190000003848737" target="_blank" rel="noopener">也来说说touch事件与点击穿透问题</a></li><li><a href="https://github.com/hijiangtao/hijiangtao.github.io/blob/master/_posts/2017-07-08-Device-Viewport-and-Pixel-Introduction.md" target="_blank" rel="noopener">前端涉及的各种像素概念以及 viewport 汇总</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;扔了N久，还是捡回来了。好好弄一下吧。刚工作的时候挺忙的，后来不那么忙了，但是变懒了。&lt;br&gt;这一年大多数时间都在在做移动端的东东，做了之后才发现，同样是web前端，移动端的坑真的是深不可测，各种各样的，只有想不到，没有遇不到。在这里把最近踩过的坑整理一下。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="mobile" scheme="http://blog.locusland.xyz/tags/mobile/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS 8新特性(2)</title>
    <link href="http://blog.locusland.xyz/2017/06/30/nodejs8-2/"/>
    <id>http://blog.locusland.xyz/2017/06/30/nodejs8-2/</id>
    <published>2017-06-30T08:22:15.000Z</published>
    <updated>2017-12-28T07:19:28.583Z</updated>
    
    <content type="html"><![CDATA[<p>继续整理，这次写的都是我觉得在新特性里面比较实用的，最有用的应该算是ASYNC_HOOKS和promisify了。<br><a id="more"></a></p><h2 id="ASYNC-HOOKS"><a href="#ASYNC-HOOKS" class="headerlink" title="ASYNC_HOOKS"></a>ASYNC_HOOKS</h2><p><small>async_hooks模块提供了一个API来回溯跟踪Node.js应用创建的异步资源的生命周期。API预览如下：</small></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async_hooks = <span class="built_in">require</span>(<span class="string">'async_hooks'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前异步资源唯一id</span></span><br><span class="line"><span class="keyword">const</span> cid = async_hooks.currentId();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发当前异步行为的异步资源id</span></span><br><span class="line"><span class="keyword">const</span> tid = async_hooks.triggerId();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建异步勾子监听</span></span><br><span class="line"><span class="keyword">const</span> asyncHook = async_hooks.createHook(&#123; init, before, after, destroy &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始监听</span></span><br><span class="line">asyncHook.enable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束监听</span></span><br><span class="line">asyncHook.disable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源对象初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">asyncId, type, triggerId, resource</span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调开始之前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">before</span>(<span class="params">asyncId</span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调完成之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">asyncId</span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AsyncWrap实例销毁.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params">asyncId</span>) </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>Note:<br>init()异步资源生成时执行，用于初始化，这个函数执行的时候异步资源可能还没有完全生成，但是一定会生成一个唯一的asyncID，before()异步回调开始之前执行，它可能被执行0-N次(e.g. TCPWrap)，取决于这个异步资源执行了多少次回调，after()在异步回调finish的时候执行，destroy is called when an AsyncWrap instance is destroyed.</p><p>init(asyncId, type, triggerId, resource)</p><ul><li>asyncId &lt;number&gt; 当前异步资源的唯一标识</li><li>type &lt;string&gt; 异步资源的类型</li><li>triggerId &lt;number&gt; 触发当前异步行为的异步资源的asyncId</li><li>resource &lt;Object&gt; 异步资源对象，将在destory时释放，但是并不意味着每个实例都要在destroy之前执行before和after<br>Note:<br>asyncId当前异步资源的唯一标识，type异步资源的类型，triggerId触发当前异步行为的异步资源的asyncId，resource异步资源对象，将在destory时释放，但是并不意味着每个实例都要在destroy之前执行before和after。</li></ul><p>type:</p><p>FSEVENTWRAP, FSREQWRAP, GETADDRINFOREQWRAP, GETNAMEINFOREQWRAP, HTTPPARSER,<br>JSSTREAM, PIPECONNECTWRAP, PIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,<br>SIGNALWRAP, STATWATCHER, TCPCONNECTWRAP, TCPWRAP, TIMERWRAP, TTYWRAP,<br>UDPSENDWRAP, UDPWRAP, WRITEWRAP, ZLIB, SSLCONNECTION, PBKDF2REQUEST,<br>RANDOMBYTESREQUEST, TLSWRAP</p><p>trigger_id:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async_hooks.createHook(&#123;</span><br><span class="line">  init(asyncId, type, triggerId) &#123;</span><br><span class="line">    <span class="keyword">const</span> cId = async_hooks.currentId();</span><br><span class="line">    fs.writeSync(</span><br><span class="line">      <span class="number">1</span>, <span class="string">`<span class="subst">$&#123;type&#125;</span>(<span class="subst">$&#123;asyncId&#125;</span>): trigger: <span class="subst">$&#123;triggerId&#125;</span> scope: <span class="subst">$&#123;cId&#125;</span>\n`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).enable();</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'net'</span>).createServer(<span class="function">(<span class="params">conn</span>) =&gt;</span> &#123;&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><h2 id="UTIL"><a href="#UTIL" class="headerlink" title="UTIL"></a>UTIL</h2><div style="text-align: left;">util.inspect添加[Array]符号, 同时可以展示symbol key</div><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; const obj = util.inspect(&#123;<span class="string">'a'</span>: &#123;<span class="string">'b'</span>: [<span class="string">'c'</span>]&#125;&#125;, <span class="literal">false</span>, 1)</span><br><span class="line">&gt; obj</span><br><span class="line"><span class="string">'&#123; a: &#123; b: [Object] &#125; &#125;'</span></span><br><span class="line">&gt; assert.strictEqual(obj, <span class="string">'&#123; a: &#123; b: [Array] &#125; &#125;'</span>)</span><br><span class="line">AssertionError: <span class="string">'&#123; a: &#123; b: [Object] &#125; &#125;'</span> === <span class="string">'&#123; a: &#123; b: [Array] &#125; &#125;'</span></span><br><span class="line"></span><br><span class="line">// 8.0.0</span><br><span class="line">&gt; obj</span><br><span class="line"><span class="string">'&#123; a: &#123; b: [Array] &#125; &#125;'</span></span><br><span class="line">&gt; assert.strictEqual(obj, <span class="string">'&#123; a: &#123; b: [Array] &#125; &#125;'</span>)</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure><div style="text-align: left;">util.format新增整形——%i，浮点型——%f</div><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; util.format(<span class="string">'%d'</span>, 42.2)</span><br><span class="line"><span class="string">'42.2'</span></span><br><span class="line">&gt; util.format(<span class="string">'%i'</span>, 42.2)</span><br><span class="line"><span class="string">'%i 42.2'</span></span><br><span class="line">&gt; util.format(<span class="string">'%f'</span>, 42.2)</span><br><span class="line"><span class="string">'%f 42.2'</span></span><br><span class="line"></span><br><span class="line">// 8.0.0</span><br><span class="line">&gt; util.format(<span class="string">'%d'</span>, 42.2)</span><br><span class="line"><span class="string">'42.2'</span></span><br><span class="line">&gt; util.format(<span class="string">'%i'</span>, 42.2)</span><br><span class="line"><span class="string">'42'</span></span><br><span class="line">&gt; util.format(<span class="string">'%f'</span>, 42.2)</span><br><span class="line"><span class="string">'42.2'</span></span><br></pre></td></tr></table></figure><ul><li>添加 promisify()</li></ul><p>Node.js 一直以来的关键设计就是把用户关在一个“异步编程的监狱”里，以换取非阻塞 I/O 的高性能，让用户轻易开发出高度可扩展的网络服务器。这从 Node.js 的 API 设计上就可见一斑，很多API——如 fs.open(path, flags[, mode], callback)——要求用户必须把该操作执行成功后的逻辑放在最后参数里，作为函数传递进去；而 fs.open 本身是立即返回的，用户不能把依赖于 fs.open 结果的逻辑与 fs.open 本身线性地串联起来。为了减轻异步编程的痛苦，几年间我们见证了数个解决方案的出现：从深度嵌套的回调金字塔，到带有长长的 then() 链条的 Promise 设计模式，再到 Generator 函数，到如今 Node.js 8 的 async/await 操作符。笔者认为，所有这些解决方案中，async/await 操作符是最接近命令式编程风格的，使用起来最为自然的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> writeFile = <span class="built_in">require</span>(<span class="string">'fs'</span>).writeFile;</span><br><span class="line"><span class="keyword">const</span> stat = <span class="built_in">require</span>(<span class="string">'fs'</span>).stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> writeFile(<span class="string">'a_new_file.txt'</span>, <span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">await</span> stat(<span class="string">'a_new_file.txt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result.size);</span><br></pre></td></tr></table></figure><p>例如我们想先创建一个文件，再读取、输出它的大小，只需三行代码,这简直是最简单的异步编程了！我们用自然、流畅的代码表达了线性业务逻辑，同时还得到了 Node.js 非阻塞 I/O 带来的高性能，简直是兼得了鱼和熊掌。<br>但别着急，这段代码不是立即就可以执行的，细心的读者肯定会问：例子中的 writeFile 和 stat 分别是什么？其实它们就是标准库的 fs.writeFile 和 fs.stat，但又不完全是。这是因为 async 和 await 本质上是对 Promise 设计模式的封装，一般情况下 await 的参数应是一个返回 Promise 对象的函数。而 fs.writeFile 和 fs.stat 这些标准库 API 没有返回值（返回 undefined），需要一个方法把他们包装成返回 Promise 对象的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> writeFile = util.promisify(fs.writeFile);</span><br><span class="line"><span class="keyword">const</span> stat = util.promisify(fs.stat);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> writeFile(<span class="string">'a_new_file.txt'</span>, <span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> stat(<span class="string">'a_new_file.txt'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result.size);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="WHATWG-URL"><a href="#WHATWG-URL" class="headerlink" title="WHATWG URL"></a>WHATWG URL</h2><p>nodejs现在完美支持标准URL对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> URL = url.URL;</span><br><span class="line"><span class="comment">// or const &#123; URL &#125; = require('url');</span></span><br><span class="line"><span class="keyword">const</span> myURL =</span><br><span class="line">  <span class="keyword">new</span> URL(<span class="string">'https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash'</span>);</span><br><span class="line">myURL;</span><br></pre></td></tr></table></figure><p><img src="/images/nodejs8/url.png" alt="url"></p><p>Note:url 模块提供了一些实用函数，用于 URL 处理与解析。 可以通过以下方式使用：const url = require(‘url’);<br>一个 URL 字符串是一个结构化的字符串，它包含多个有意义的组成部分。 当被解析时，会返回一个 URL 对象，它包含每个组成部分作为属性。</p><p>Class: URLSearchParams</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; URLSearchParams &#125; = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br></pre></td></tr></table></figure><ul><li>urlSearchParams.get(name)</li><li>urlSearchParams.getAll(name)</li><li>urlSearchParams.set(name, value)</li><li>urlSearchParams.append(name, value)</li><li>urlSearchParams.delete(name)</li><li>urlSearchParams.entries()</li><li>urlSearchParams.forEach(fn[, thisArg])</li><li>urlSearchParams.has(name)</li><li>urlSearchParams.sort()<br>Note: 还有urlSearchParams.values()，urlSearchParams.toString()</li></ul><h2 id="INSPECTOR"><a href="#INSPECTOR" class="headerlink" title="INSPECTOR"></a>INSPECTOR</h2><p>命令行在 –inspector基础上，新增–inspector-brk，同时可以添加=[port]指定调试端口，默认9229，node –debug废弃</p><p>–debug-brk 通过这个参数，在开始调试的时候能够定位到代码的第一行。</p><p>新增inspector内置模块，支持程序化的debug。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inspector = <span class="built_in">require</span>(<span class="string">'inspector'</span>);</span><br></pre></td></tr></table></figure><ul><li>inspector.open([port[, host[, wait]]])</li><li>inspector.close()</li><li>inspector.url()</li><li>Class: inspector.Session</li></ul><p>如果wait为true，将阻塞，直到客户端连接到检查端口。<br>If wait is true, will block until a client has connected to the inspect port and flow control has been passed to the debugger client.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inspector = <span class="built_in">require</span>(<span class="string">'inspector'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> session = <span class="keyword">new</span> inspector.Session();</span><br><span class="line">session.connect();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for inspector events</span></span><br><span class="line">session.on(<span class="string">'inspectorNotification'</span>, (message) =&gt; &#123; <span class="comment">/** ... **/</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send messages to the inspector</span></span><br><span class="line">session.post(message);</span><br><span class="line"></span><br><span class="line">session.disconnect();</span><br></pre></td></tr></table></figure><p>Session这个class支持监听inspector的一些相关事件，可以向v8的inspector后台发送或接收message</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://cloud.tencent.com/community/article/171211?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">npm5 新版功能特性解析及与 yarn 评测对比</a></li><li><a href="https://cnodejs.org/topic/59084a9cbbaf2f3f569be482" target="_blank" rel="noopener">V8 Ignition：JS 引擎与字节码的不解之缘</a></li><li><a href="https://v8project.blogspot.co.id/2017/04/v8-release-59.html" target="_blank" rel="noopener">https://v8project.blogspot.co.id/2017/04/v8-release-59.html</a></li><li><a href="http://gitbook.cn/m/mazi/article/593763494ec5fa29296acea0?readArticle=yes" target="_blank" rel="noopener">从暴力到 NAN 到 NAPI——Node.js 原生模块开发方式变迁</a></li><li><a href="http://huziketang.com/blog/posts/detail?postId=58ce8036a6d8a07e449fdd27" target="_blank" rel="noopener">WebAssembly</a></li><li><a href="https://nodejs.org/en/blog/release/v8.0.0" target="_blank" rel="noopener">Node8 changes</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续整理，这次写的都是我觉得在新特性里面比较实用的，最有用的应该算是ASYNC_HOOKS和promisify了。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.locusland.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="Node" scheme="http://blog.locusland.xyz/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS 8新特性</title>
    <link href="http://blog.locusland.xyz/2017/06/25/nodejs8/"/>
    <id>http://blog.locusland.xyz/2017/06/25/nodejs8/</id>
    <published>2017-06-25T06:30:33.000Z</published>
    <updated>2017-12-28T07:21:39.225Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵子5月30日NodeJS 8终于发布了，而Node历来偶数版本都是一个长期稳定版（Long Term Support），这次的8.0版本新增了很多特性，在此整理一下~<br><a id="more"></a></p><h2 id="Long-Term-Support"><a href="#Long-Term-Support" class="headerlink" title="Long Term Support"></a>Long Term Support</h2><p>基本全面支持ES6新特性，<a href="http://node.green/#ES2017-features-async-functions" target="_blank" rel="noopener">以及ES7的async函数</a>。</p><h2 id="NPM-v5-x"><a href="#NPM-v5-x" class="headerlink" title="NPM v5.x"></a>NPM v5.x</h2><ul><li>宇宙最快(？貌似)，自带lock文件package-lock.json 来记录依赖树信息</li><li>–save以后不用写了，会自动发保存到package.json，可以使用参数 –no-save取消</li><li>node-gyp 在 Windows 提供对 node-gyp.cmd 的支持</li><li>包发布将同时生成 sha512 和 sha1 校验码，下载依赖时将使用强校验算法</li><li>Git依赖支持优化，文件依赖优化，缓存优化</li></ul><p>本次 npm5 新增了 package-lock.json 文件，在操作依赖时默认生成，用于记录和锁定依赖树的信息。使用过 yarn 的同学应该能感觉到，这次 npm5 的很多改动都有参考 yarn，这里估计也是在 yarn 的 lockfile 大受欢迎的背景下做出了这个修改（其实之前的 npm 版本并不是没有 lockfile）。</p><p>生成 package-lock.json 后，重复执行 npm install 时将会以其记录的版本来安装。这时如果手动修改 package.json 中的版本，重新安装也不会生效，只能手动执行 npm install 命令指定依赖版本来进行修改。而这一点 yarn 是可以做到的。猜想 yarn 在执行前是先对比了一遍 package.json 和 yarn.lock 中的版本，如果版本范围完全不符的话会重新安装并更新 lockfile。</p><p>npm5 新增的 package-lock.json 文件和之前通过 npm shrinkwrap 命令生成的 npm-shrinkwrap.json 文件的格式完全相同，文件内记录了版本，来源，树结构等所有依赖的 metadata。需要注意的是 npm shrinkwrap 并不是一个新功能特性，而是从 npm2 就开始有的功能。也就是说在 npm5 之前的版本也是可以通过 shrinkwrap 锁定依赖的。（在这一点上，其实 Facebook 也是早期在使用 npm shrinkwrap 等功能时无法满足需求才导致了现在 yarn 的出现。）</p><p>而最新的 npm5 在生成了 package-lock.json 之后，再运行 npm shrinkwrap 命令，会发现就是把 package-lock.json 重命名为 npm-shrinkwrap.json 而已。</p><p>因此 package-lock.json 表面上看只是把 npm-shrinkwrap.json 作为了默认创建，为何还要新建一个文件呢？官方对于此也给出了答复和解释：新增 package-lock.json 主要是为了使得 npm-shrinkwrap.json 可以向下兼容，保证旧版也可使用（比如已有 shrinkwrap 文件的项目，或是回滚旧版的场景）。另外 package-lock 的名称也比 shrinkwrap 相对更加直观。</p><h2 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a>V8引擎</h2><ul><li><strong>v5.7更新：</strong></li><li>promise 和 async 提速</li><li>spread operator, destructuring 和 generators 提速</li><li>通过 TurboFan, RegExp 提速了 15%</li><li>padStart 和 padEnd 被添加到了 es2017 (ECMA 262)</li><li>支持<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat" target="_blank" rel="noopener">Intl.DateTimeFormat.prototype.formatToParts</a></li><li><strong>WebAssembly 默认打开</strong></li><li><strong>添加 PromiseHook</strong></li></ul><ul><li><strong>v5.8更新：</strong></li><li>任意设置堆大小的限制值 (范围是带符号32位整数)</li><li>启动性能提升约5％</li><li>缩短 IC 系统的代码编译，分析，优化时间</li></ul><p>TurboFan &amp; Ingnition<br>TURBOFAN 编译器</p><p>V8 优化了 JIT 编译器，它是用 Sea of Nodes 概念进行设计的。之前采用的编译技术是 Crankshaft，它支持优化更多的代码。但是 ES 的标准发展很快，后来发现 Crankshaft 已经很难去优化 ES2015 代码了，而通过 Ignition 和 TurboFan 可以做到。</p><p>IGNITION 解释器</p><p>已知的是到目前为止 V8 都没有自己的解析器，都是直接把 JS 编译成机器码。<br>作为JIT的JIT的问题，即使代码被执行一次，它也消耗大量的存储空间，所以需要尽量避免内存开销。<br>使用 Ignition，可以精简 25% - 50% 的机器码。<br>Ignition 是没有依赖 Turbofan 的底层架构，它采用宏汇编指令。为每个操作码生成一个字节码处理程序。<br>通过 Ignition 可以较少系统内存使用情况。</p><p>之前 v8 选择了直接将 JS 代码编译到机器代码执行，机器码的执行性能已经非常之高，而这次引入字节码则是选择编译 JS 代码到一个中间态的字节码，执行时是解释执行，性能是低于机器代码的。最终的性能测试势必会降低，而不是提高。那么 V8 为什么要做这样一个退步的选择呢？为 V8 引入字节码的动机又是什么呢？笔者总结下来有三条：</p><p>（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间<br>提高代码的启动速度<br>对 v8 的代码进行重构，降低 v8 的代码复杂度</p><p>WebAssembly:WebAssembly 是除了 JavaScript 以外，另一种可以在浏览器中执行的编程语言。所以当人们说 WebAssembly 更快的时候，一般来讲是与 JavaScript 相比而言的。</p><h2 id="N-API"><a href="#N-API" class="headerlink" title="N-API"></a>N-API</h2><p>目前 Node 的实现中，V8 的 API 是直接暴露出来的。由于 V8 经常变更 API，那就存在下面的这些问题：</p><ul><li>Native 模块在每个版本间需要重新编译</li><li>Native 模块需要变更代码</li><li>Native 模块无法工作在其他JS engine 上 (比如: ChakraCore)<br>这些问题之前的 NAN(Native Abstractions for Node.js)(nodejs/nan) 搞不定。</li></ul><p>经历过 Node.js 大版本升级的同学肯定会发现，每次升级后我们都得重新编译像 node-sass 这种用 C++ 写的扩展模块，否则就会这样：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error: The module <span class="string">'node-sass'</span></span><br><span class="line">was compiled against a different Node.js version using</span><br><span class="line">NODE_MODULE_VERSION 51. This version of Node.js requires</span><br><span class="line">NODE_MODULE_VERSION 55. Please try re-compiling or re-installing</span><br><span class="line">the module (\<span class="keyword">for</span> instance, using `npm rebuild` or `npm install`).</span><br></pre></td></tr></table></figure><p>NODE_MODULE_VERSION 是每一个 Node.js 版本内人为设定的数值，意思为 ABI (Application Binary Interface) 的版本号。一旦这个号码与已经编译好的二进制模块的号码不符，便判断为 ABI 不兼容，需要用户重新编译。</p><p>这其实是一个工程难题，亦即 Node.js 上游的代码变化如何最小地降低对 C++ 模块的影响，从而维持一个良好的向下兼容的模块生态系统。最坏的情况下，每次发布 Node.js 新版本，因为 API 的变化，C++ 模块的作者都要修改它们的源代码，而那些不再有人维护或作者失联的老模块就会无法继续使用，在作者修改代码之前社区就失去了这些模块的可用性。其次坏的情况是，每次发布 Node.js 新版本，虽然 API 保持兼容使得 C++ 模块的作者不需要修改他们的代码，但 ABI 的变化导致必须这些模块必须重新编译。而最好的情况就是，Node.js 新版本发布后，所有已编译的 C++ 模块可以继续正常工作，完全不需要任何人工干预。</p><p>Node.js 8 的 Node.js API (N-API) 就是为了解决这个问题，做到上述最好的情况，为 Node.js 模块生态系统的长期发展铺平道路。N-API 追求以下目标：</p><ol><li>有稳定的 ABI</li><li>抽象消除 Node.js 版本之间的接口差异</li><li>抽象消除 V8 版本之间的接口差异</li><li>抽象消除 V8 与其他 JS 引擎（如 ChakraCore）之间的接口差异</li></ol><p>先整理这么多，还有一部分- -</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一阵子5月30日NodeJS 8终于发布了，而Node历来偶数版本都是一个长期稳定版（Long Term Support），这次的8.0版本新增了很多特性，在此整理一下~&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.locusland.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
      <category term="Node" scheme="http://blog.locusland.xyz/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>实现transition变换height为auto</title>
    <link href="http://blog.locusland.xyz/2017/03/09/transition-height/"/>
    <id>http://blog.locusland.xyz/2017/03/09/transition-height/</id>
    <published>2017-03-09T12:41:37.000Z</published>
    <updated>2017-12-28T07:37:49.642Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道transition可以指定特定的变换加一个过渡效果，它依赖于transition-property的这个属性，比如我们可以让一个蒙层的width在0和100%之间变换，同时加入transition，可以轻松完成一个滑动的效果，但在height上如果想实现一个类似的效果，就会有一些问题。<br><a id="more"></a><br>css3 transition动画的一些限制，那就是transition-property的起始值必须为具体数值或数值百分比，反正就是说得有个具体的数字，一旦你这个东西高度不确定，使用auto的话，transition便不会生效。一个比较简单的解决方法就是使用max-height。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.menu</span> <span class="selector-tag">li</span> <span class="selector-class">.sub</span>&#123;  </span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">0</span>;  </span><br><span class="line">    <span class="attribute">overflow</span>: hidden;  </span><br><span class="line">    <span class="attribute">transition</span>: max-height <span class="number">1s</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.menu</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.sub</span>&#123;  </span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">200px</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一点就是：需要确保max-height的值超过所有项中的最大值，确保一定要罩得住里面的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道transition可以指定特定的变换加一个过渡效果，它依赖于transition-property的这个属性，比如我们可以让一个蒙层的width在0和100%之间变换，同时加入transition，可以轻松完成一个滑动的效果，但在height上如果想实现一个类似的效果，就会有一些问题。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.locusland.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://blog.locusland.xyz/tags/CSS/"/>
    
      <category term="动画" scheme="http://blog.locusland.xyz/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>JS生成一个种子随机数（伪随机数）</title>
    <link href="http://blog.locusland.xyz/2016/09/12/js-random/"/>
    <id>http://blog.locusland.xyz/2016/09/12/js-random/</id>
    <published>2016-09-12T10:18:06.000Z</published>
    <updated>2017-12-28T10:04:46.644Z</updated>
    
    <content type="html"><![CDATA[<p>最近有一个需求，需要生成一个随机数，但是又不能完全随机，就是说需要一个种子seed，seed不变的时候，这个随机数就不变，根据不同的seed会生成不同的随机数= =反正就是一个伪随机数。自己想了好久也没有太好的办法，于是上网查了一下，还真有这么个东西~~<br><a id="more"></a><br>嗯就长这样，知乎链接在这里：<a href="https://www.zhihu.com/question/22818104" target="_blank" rel="noopener">https://www.zhihu.com/question/22818104</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rnd</span>(<span class="params"> seed </span>)</span>&#123;</span><br><span class="line">    seed = ( seed * <span class="number">9301</span> + <span class="number">49297</span> ) % <span class="number">233280</span>; <span class="comment">//为何使用这三个数?</span></span><br><span class="line">    <span class="keyword">return</span> seed / ( <span class="number">233280.0</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rand</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">    today = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line">    seed = today.getTime();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.ceil( rnd( seed ) * number );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myNum=(rand(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>他这个注释也写了，为啥是这三个数    🤣，当然后面也有一些很牛逼的讨论。。。不过我完全看不懂比如什么线性同余生成器啊，什么Hull-Dobell定理啊，反正用这三个数确实能生成一个依赖于seed的伪随机数。嗯就酱。暂且记录一下这个吧，以后说不定还会用到🤣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有一个需求，需要生成一个随机数，但是又不能完全随机，就是说需要一个种子seed，seed不变的时候，这个随机数就不变，根据不同的seed会生成不同的随机数= =反正就是一个伪随机数。自己想了好久也没有太好的办法，于是上网查了一下，还真有这么个东西~~&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.locusland.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://blog.locusland.xyz/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vim键位图以及常用命令</title>
    <link href="http://blog.locusland.xyz/2016/06/04/vim-command/"/>
    <id>http://blog.locusland.xyz/2016/06/04/vim-command/</id>
    <published>2016-06-04T08:42:54.000Z</published>
    <updated>2017-12-28T06:54:17.862Z</updated>
    
    <content type="html"><![CDATA[<p>其实Vim虽然是一个文本编辑器，但是它的功能似乎以及突破天际了，不愧上上古神器。这里简单整理记录一下vim的常用命令，方便查找。其实Vim只要稍微加一些插件，就可以打造成一个自己的IDE（暂时这里不介绍了- -以后有空再整理）。</p><a id="more"></a><h3 id="键位图："><a href="#键位图：" class="headerlink" title="键位图："></a>键位图：</h3><p><img src="https://geniuspeng.github.io/image-storage/blog/vim/vim-command.jpg" alt="vim键位图"></p><h3 id="进入vim"><a href="#进入vim" class="headerlink" title="进入vim"></a>进入vim</h3><p>vim filename                打开或新建文件，并将光标置于第一行首</p><p>vim +n filename           打开文件，并将光标置于第 n行首</p><p>vim + filename             打开文件，并将光标置于最后一行首</p><p>vim -r filename            在上次正用 vim编辑时发生系统崩溃，恢复文件</p><p>vim file1….filen            打开多个文件，依次编辑</p><h3 id="vim的工作模式"><a href="#vim的工作模式" class="headerlink" title="vim的工作模式"></a>vim的工作模式</h3><p>命令行模式 （command mode）：控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。</p><p>插入模式（Insert mode）：只有在 Insert mode 下，才可以做文字输入，按「ESC」键可回到命令行模式。</p><p>底行模式（last line mode）：将文件保存或退出 vi，也可以设置编辑环境，如寻找字符串、列出行号等。</p><h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><p>k、j、h、l      功能分别等同于上、下、左、右箭头键 </p><p>Ctrl+b            在文件中向上移动一页（相当于 PageUp 键）</p><p>Ctrl+f             在文件中向下移动一页（相当于 PageDown 键）</p><p>ctrl+u             屏幕往后移动半页</p><p>ctrl+d            屏幕往前移动半页</p><p>H                   将光标移到屏幕的最上行（Highest） </p><p>nH                 将光标移到屏幕的第 n 行（如 2H： 将光标移到屏幕的第 2 行）</p><p>M                  将光标移到屏幕的中间（Middle）</p><p>L                   将光标移到屏幕的最下行（Lowest） </p><p>nL                 将光标移到屏幕的倒数第 n 行（如 3L：将光标移到屏幕的倒数第 3 行）</p><p>w                  在指定行内右移光标，到下一个字的开头</p><p>e                   在指定行内右移光标，到一个字的末尾</p><p>b                   在指定行内左移光标，到前一个字的开头</p><p>0                   数字0，左移光标，到本行的开头 </p><p>G                  光标移动到文章的最后</p><p>nG                光标移动到文章的第 n行（如8G：移动到文章的第 8行）</p><p>$                   右移光标，到本行的末尾 </p><p>^                   移动光标，到本行的第一个非空字符</p><h4 id="替换和删除"><a href="#替换和删除" class="headerlink" title="替换和删除"></a>替换和删除</h4><p>rc                  用 c 替换光标所指向的当前字符</p><p>nrc                用 c 替换光标所指向的前 n 个字符（如 5rc： 用 c 替换光标所指向的前 5 个字符）</p><p>x                   删除光标所在位置后面的一个字符 </p><p>nx                 删除光标所在位置后面的 n 个字符（如 3x：删除光标所在位置后面的 3 个字符）</p><p>X                  大写的 X，删除光标所在位置前面的一个字符</p><p>nX                删除光标所在位置前面的 n 个字符（如 3X ： 删除光标所在位置前面的 3 个字符）</p><p>dd                删除光标所在行，并去除空隙 </p><p>ndd              从光标所在行开始删除 n 行内容，并去除空隙（如 3dd： 删除 3 行内容，并去除空隙） </p><h4 id="复制和粘贴"><a href="#复制和粘贴" class="headerlink" title="复制和粘贴"></a>复制和粘贴</h4><p>从正文中删除的内容（如字符、字或行）并没有真正丢失，而是被剪切并复制到了一个内存缓冲区中。用户可将其粘贴到正文中的指定位置。</p><p>p                  小写字母 p，将缓冲区的内容粘贴到光标的后面</p><p>P                  大写字母 P，将缓冲区的内容粘贴到光标的前面 </p><p>如果缓冲区的内容是字符或字，直接粘贴在光标的前面或后面；如果缓冲区的内容为整行正文则粘贴在当前光标所在行的上一行或下一行。</p><p>有时需要复制一段正文到新位置，同时保留原有位置的内容。这种情况下，首先应当把指定内容复制（而不是剪切）到内存缓冲区。完成这一操作的命令是：</p><p>yy                 复制当前行到内存缓冲区</p><p>nyy               复制 n 行内容到内存缓冲区（如 5yy： 复制 5 行内容到内存缓冲区）</p><h4 id="搜索字符串"><a href="#搜索字符串" class="headerlink" title="搜索字符串"></a>搜索字符串</h4><p>/str1             正向搜索字符串 str1 </p><p>n                  继续搜索，找出 str1 字符串下次出现的位置 </p><p>?str2            反向搜索字符串 str2 </p><h4 id="撤销和重复"><a href="#撤销和重复" class="headerlink" title="撤销和重复"></a>撤销和重复</h4><p>u                  撤消前一条命令的结果 </p><p>.                   重复最后一条修改正文的命令 </p><h4 id="文本选中"><a href="#文本选中" class="headerlink" title="文本选中"></a>文本选中</h4><p> v                  字符选中命令  </p><p>V                  行选中命令</p><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><h4 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h4><p>i                   在光标左侧输入正文</p><p>a                  在光标右侧输入正文</p><p>o                  在光标所在行的下一行增添新行 </p><p>O                 在光标所在行的上一行增添新行</p><p>I                   在光标所在行的开头输入正文 </p><p>A                 在光标所在行的末尾输入正文</p><h4 id="退出插入模式"><a href="#退出插入模式" class="headerlink" title="退出插入模式"></a>退出插入模式</h4><p> ESC 键或组合键Ctrl+[ </p><h3 id="底行模式"><a href="#底行模式" class="headerlink" title="底行模式"></a>底行模式</h3><p>在vim 的底行模式下，可以使用复杂的命令。</p><h4 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h4><p>在命令模式下可以用 ZZ 命令退出 vi 编辑程序，该命令保存对正文所作的修改，覆盖原始文件。如果只需要退出编辑程序，而不打算保存编辑的内容，可用下面的命令：</p><p>: q                   在未作修改的情况下退出</p><p>: q!                  放弃所有修改，退出编辑程序</p><h4 id="行号和文件保存"><a href="#行号和文件保存" class="headerlink" title="行号和文件保存"></a>行号和文件保存</h4><p>: n                    将光标移到第 n 行 </p><p>:set nu             显示行号 </p><p>:set nonu         取消行号显示 </p><p>底行模式下，可以规定命令操作的行号范围。数值用来指定绝对行号；字符“.”表示光标所在行的行号；字符“$”表示正文最后一行的行号；简单的表达式，例如“.+5”表示当前行往下的第 5 行。例如：</p><p>: .+5               将光标移到当前行之后的第5行 </p><p>: $                  将光标移到正文最后一行</p><p>在底行模式下，允许从文件中读取正文，或将正文写入文件。例如：</p><p>:w                  将编辑的内容写入原始文件，用来保存编辑的中间结果 </p><p>:wq                将编辑的内容写入原始文件并退出编辑程序（相当于 ZZ 命令） </p><p>:w file             将编辑的内容写入 file 文件，保持原有文件的内容不变 </p><p>:a,bw file        将第 a 行至第 b 行的内容写入 file 文件 （如:1,.w file    将第 1 行至当前行写入 file 文件）</p><p>:r file              读取 file 文件的内容，插入当前光标所在行的后面</p><p>:f file              将当前文件重命名为 file </p><h4 id="字符串搜索"><a href="#字符串搜索" class="headerlink" title="字符串搜索"></a>字符串搜索</h4><p>:/str/               正向搜索，将光标移到下一个包含字符串 str 的行</p><p>:?str?             反向搜索，将光标移到上一个包含字符串 str 的行</p><h4 id="正文替换"><a href="#正文替换" class="headerlink" title="正文替换"></a>正文替换</h4><p>:s/str1/str2/          用字符串 str2 替换行中首次出现的字符串 str1 </p><p>:s/str1/str2/g        用字符串 str2 替换行中所有出现的字符串 str1 </p><p>:.,$ s/str1/str2/g   用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1 </p><p>:1,$ s/str1/str2/g  用字符串 str2 替换正文中所有出现的字符串 str1 </p><p>:g/str1/s//str2/g    功能同上</p><p>从上述替换命令可以看到：g 放在命令末尾，表示对搜索字符串的每次出现进行替换；不加 g，表示只对搜索字符串的首次出现进行替换；g 放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作。</p><h4 id="删除正文"><a href="#删除正文" class="headerlink" title="删除正文"></a>删除正文</h4><p>:d                      删除光标所在行 </p><p>:3d                    删除第 3 行 </p><p>:.,$d                  删除当前行至正文的末尾 </p><p>:/str1/,/str2/d     删除从字符串 str1 到 str2 的所有行 </p><p>恢复文件<br>vim 在编辑某个文件时，会另外生成一个临时文件，这个文件的名称通常以 . 开头，并以 .swp 结尾。vim 在正常退出时，该文件被删除，若意外退出，而没有保存文件的最新修改内容，则可以使用恢复命令，也可以在启动 vim 时利用 -r 选项。</p><p>:recover           恢复文件</p><p>选项设置<br>为控制不同的编辑功能，vim 提供了很多内部选项。利用 :set 命令可以设置选项。基本语法为：</p><p>:set option         设置选项 option </p><p>常见的功能选项包括：</p><p>autoindent          设置该选项，则正文自动缩进 </p><p>ignorecase         设置该选项，则忽略规则表达式中大小写字母的区别 </p><p>number              设置该选项，则显示正文行号 </p><p>ruler                   设置该选项，则在屏幕底部显示光标所在行、列的位置 </p><p>tabstop               设置按 Tab 键跳过的空格数。例如 :set tabstop=n，n 默认值为 8 </p><p>mk                      将选项保存在当前目录的 .exrc 文件中 </p><p>shell切换<br>在编辑正文时，利用 vim 底行模式下提供的shell 切换命令，无须退出 vim 即可执行Linux 命令</p><p>:! command          执行完shell 命令 command 后回到vi </p><p>另外，在命令模式下，键入K ，可命令 vim 查找光标所在单词的手册页，相当于运行man命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实Vim虽然是一个文本编辑器，但是它的功能似乎以及突破天际了，不愧上上古神器。这里简单整理记录一下vim的常用命令，方便查找。其实Vim只要稍微加一些插件，就可以打造成一个自己的IDE（暂时这里不介绍了- -以后有空再整理）。&lt;/p&gt;
    
    </summary>
    
      <category term="效率" scheme="http://blog.locusland.xyz/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="常用命令" scheme="http://blog.locusland.xyz/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Vim" scheme="http://blog.locusland.xyz/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令(3) Grep--强大的文本搜索工具</title>
    <link href="http://blog.locusland.xyz/2016/05/28/linux-command3/"/>
    <id>http://blog.locusland.xyz/2016/05/28/linux-command3/</id>
    <published>2016-05-28T09:09:19.000Z</published>
    <updated>2017-12-28T06:50:39.393Z</updated>
    
    <content type="html"><![CDATA[<p>Grep这个命令真的很强大，接触到这个东西是因为最近有一次需要去后台搜索某些自己打的日志，但是整个项目上的日志输出太快太多，以至于很难抓取到，于是问了大神，才知道还有这么个东西…实际上只要 pm2 logs xxx | grep ‘match_pattern’ 就可以咯~~<br><a id="more"></a></p><p><strong>grep</strong> （global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-a --text  <span class="comment"># 不要忽略二进制数据。</span></span><br><span class="line">-A &lt;显示行数&gt;   --after-context=&lt;显示行数&gt;   <span class="comment"># 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</span></span><br><span class="line">-b --byte-offset                           <span class="comment"># 在显示符合范本样式的那一行之外，并显示该行之前的内容。</span></span><br><span class="line">-B&lt;显示行数&gt;   --before-context=&lt;显示行数&gt;   <span class="comment"># 除了显示符合样式的那一行之外，并显示该行之前的内容。</span></span><br><span class="line">-c --count    <span class="comment"># 计算符合范本样式的列数。</span></span><br><span class="line">-C&lt;显示行数&gt; --context=&lt;显示行数&gt;或-&lt;显示行数&gt; <span class="comment"># 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span></span><br><span class="line">-d&lt;进行动作&gt; --directories=&lt;动作&gt;  <span class="comment"># 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。</span></span><br><span class="line">-e&lt;范本样式&gt; --regexp=&lt;范本样式&gt;   <span class="comment"># 指定字符串作为查找文件内容的范本样式。</span></span><br><span class="line">-E --extended-regexp             <span class="comment"># 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。</span></span><br><span class="line">-f&lt;范本文件&gt; --file=&lt;规则文件&gt;     <span class="comment"># 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。</span></span><br><span class="line">-F --fixed-regexp   <span class="comment"># 将范本样式视为固定字符串的列表。</span></span><br><span class="line">-G --basic-regexp   <span class="comment"># 将范本样式视为普通的表示法来使用。</span></span><br><span class="line">-h --no-filename    <span class="comment"># 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</span></span><br><span class="line">-H --with-filename  <span class="comment"># 在显示符合范本样式的那一列之前，标示该列的文件名称。</span></span><br><span class="line">-i --ignore-case    <span class="comment"># 忽略字符大小写的差别。</span></span><br><span class="line">-l --file-with-matches   <span class="comment"># 列出文件内容符合指定的范本样式的文件名称。</span></span><br><span class="line">-L --files-without-match <span class="comment"># 列出文件内容不符合指定的范本样式的文件名称。</span></span><br><span class="line">-n --line-number         <span class="comment"># 在显示符合范本样式的那一列之前，标示出该列的编号。</span></span><br><span class="line">-q --quiet或--silent     <span class="comment"># 不显示任何信息。</span></span><br><span class="line">-R/-r  --recursive       <span class="comment"># 此参数的效果和指定“-d recurse”参数相同。</span></span><br><span class="line">-s --no-messages  <span class="comment"># 不显示错误信息。</span></span><br><span class="line">-v --revert-match <span class="comment"># 反转查找。</span></span><br><span class="line">-V --version      <span class="comment"># 显示版本信息。   </span></span><br><span class="line">-w --word-regexp  <span class="comment"># 只显示全字符合的列。</span></span><br><span class="line">-x --line-regexp  <span class="comment"># 只显示全列符合的列。</span></span><br><span class="line">-y <span class="comment"># 此参数效果跟“-i”相同。</span></span><br><span class="line">-o <span class="comment"># 只输出文件中匹配到的部分。</span></span><br></pre></td></tr></table></figure><h3 id="规则表达式"><a href="#规则表达式" class="headerlink" title="规则表达式"></a>规则表达式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">^    <span class="comment"># 锚定行的开始 如：'^grep'匹配所有以grep开头的行。    </span></span><br><span class="line">$    <span class="comment"># 锚定行的结束 如：'grep$'匹配所有以grep结尾的行。    </span></span><br><span class="line">.    <span class="comment"># 匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。    </span></span><br><span class="line">*    <span class="comment"># 匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。    </span></span><br><span class="line">.*   <span class="comment"># 一起用代表任意字符。   </span></span><br><span class="line">[]   <span class="comment"># 匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。    </span></span><br><span class="line">[^]  <span class="comment"># 匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    </span></span><br><span class="line">\(..\)  <span class="comment"># 标记匹配字符，如'\(love\)'，love被标记为1。    </span></span><br><span class="line">\&lt;      <span class="comment"># 锚定单词的开始，如:'\&lt;grep'匹配包含以grep开头的单词的行。    </span></span><br><span class="line">\&gt;      <span class="comment"># 锚定单词的结束，如'grep\&gt;'匹配包含以grep结尾的单词的行。    </span></span><br><span class="line">x\&#123;m\&#125;  <span class="comment"># 重复字符x，m次，如：'0\&#123;5\&#125;'匹配包含5个o的行。    </span></span><br><span class="line">x\&#123;m,\&#125;   <span class="comment"># 重复字符x,至少m次，如：'o\&#123;5,\&#125;'匹配至少有5个o的行。    </span></span><br><span class="line">x\&#123;m,n\&#125;  <span class="comment"># 重复字符x，至少m次，不多于n次，如：'o\&#123;5,10\&#125;'匹配5--10个o的行。   </span></span><br><span class="line">\w    <span class="comment"># 匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。   </span></span><br><span class="line">\W    <span class="comment"># \w的反置形式，匹配一个或多个非单词字符，如点号句号等。   </span></span><br><span class="line">\b    <span class="comment"># 单词锁定符，如: '\bgrep\b'只匹配grep。</span></span><br></pre></td></tr></table></figure><h2 id="grep命令常见用法"><a href="#grep命令常见用法" class="headerlink" title="grep命令常见用法"></a>grep命令常见用法</h2><p>在文件中搜索一个单词，命令会返回一个包含 <strong>“match_pattern”</strong> 的文本行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep match_pattern file_name</span><br><span class="line">grep &quot;match_pattern&quot; file_name</span><br></pre></td></tr></table></figure><p>在多个文件中查找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;match_pattern&quot; file_1 file_2 file_3 ...</span><br></pre></td></tr></table></figure><p>输出除之外的所有行  <strong>-v</strong>  选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v &quot;match_pattern&quot; file_name</span><br></pre></td></tr></table></figure><p>标记匹配颜色  <strong>–color=auto</strong>  选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;match_pattern&quot; file_name --color=auto</span><br></pre></td></tr></table></figure><p>使用正则表达式  <strong>-E</strong>  选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -E &quot;[1-9]+&quot;</span><br><span class="line">或</span><br><span class="line">egrep &quot;[1-9]+&quot;</span><br></pre></td></tr></table></figure><p>只输出文件中匹配到的部分  <strong>-o</strong>  选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo this is a test line. | grep -o -E &quot;[a-z]+\.&quot;</span><br><span class="line">line.</span><br><span class="line"></span><br><span class="line">echo this is a test line. | egrep -o &quot;[a-z]+\.&quot;</span><br><span class="line">line.</span><br></pre></td></tr></table></figure><p>统计文件或者文本中包含匹配字符串的行数  <strong>-c</strong>  选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c &quot;text&quot; file_name</span><br></pre></td></tr></table></figure><p>输出包含匹配字符串的行数  <strong>-n</strong>  选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;text&quot; -n file_name</span><br><span class="line">或</span><br><span class="line">cat file_name | grep &quot;text&quot; -n</span><br><span class="line"></span><br><span class="line">#多个文件</span><br><span class="line">grep &quot;text&quot; -n file_1 file_2</span><br></pre></td></tr></table></figure><p>打印样式匹配所位于的字符或字节偏移：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo gun is not unix | grep -b -o &quot;not&quot;</span><br><span class="line">7:not</span><br><span class="line"></span><br><span class="line">#一行中字符串的字符便宜是从该行的第一个字符开始计算，起始值为0。选项  **-b -o**  一般总是配合使用。</span><br></pre></td></tr></table></figure><p>搜索多个文件并查找匹配文本在哪些文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l &quot;text&quot; file1 file2 file3...</span><br></pre></td></tr></table></figure><h3 id="grep递归搜索文件"><a href="#grep递归搜索文件" class="headerlink" title="grep递归搜索文件"></a>grep递归搜索文件</h3><p>在多级目录中对文本进行递归搜索：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;text&quot; . -r -n</span><br><span class="line"># .表示当前目录。</span><br></pre></td></tr></table></figure><p>忽略匹配样式中的字符大小写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello world&quot; | grep -i &quot;HELLO&quot;</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>选项  <strong>-e</strong>  制动多个匹配样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo this is a text line | grep -e &quot;is&quot; -e &quot;line&quot; -o</span><br><span class="line">is</span><br><span class="line">line</span><br><span class="line"></span><br><span class="line">#也可以使用 **-f** 选项来匹配多个样式，在样式文件中逐行写出需要匹配的字符。</span><br><span class="line">cat patfile</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line"></span><br><span class="line">echo aaa bbb ccc ddd eee | grep -f patfile -o</span><br></pre></td></tr></table></figure><p>在grep搜索结果中包括或者排除指定文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#只在目录中所有的.php和.html文件中递归搜索字符&quot;main()&quot;</span><br><span class="line">grep &quot;main()&quot; . -r --include *.&#123;php,html&#125;</span><br><span class="line"></span><br><span class="line">#在搜索结果中排除所有README文件</span><br><span class="line">grep &quot;main()&quot; . -r --exclude &quot;README&quot;</span><br><span class="line"></span><br><span class="line">#在搜索结果中排除filelist文件列表里的文件</span><br><span class="line">grep &quot;main()&quot; . -r --exclude-from filelist</span><br></pre></td></tr></table></figure><p>使用0值字节后缀的grep与xargs：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试文件：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aaa"</span> &gt; file1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bbb"</span> &gt; file2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aaa"</span> &gt; file3</span><br><span class="line"></span><br><span class="line">grep <span class="string">"aaa"</span> file* -lZ | xargs -0 rm</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行后会删除file1和file3，grep输出用-Z选项来指定以0值字节作为终结符文件名（\0），xargs -0 读取输入并用0值字节终结符分隔文件名，然后删除匹配文件，-Z通常和-l结合使用。</span></span><br></pre></td></tr></table></figure><p>grep静默输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -q <span class="string">"test"</span> filename</span><br><span class="line"><span class="comment"># 不会输出任何信息，如果命令运行成功返回0，失败则返回非0值。一般用于条件测试。</span></span><br></pre></td></tr></table></figure><p>打印出匹配文本之前或者之后的行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示匹配某个结果之后的3行，使用 -A 选项：</span></span><br><span class="line">seq 10 | grep <span class="string">"5"</span> -A 3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示匹配某个结果之前的3行，使用 -B 选项：</span></span><br><span class="line">seq 10 | grep <span class="string">"5"</span> -B 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示匹配某个结果的前三行和后三行，使用 -C 选项：</span></span><br><span class="line">seq 10 | grep <span class="string">"5"</span> -C 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果匹配结果有多个，会用“--”作为各匹配结果之间的分隔符：</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"a\nb\nc\na\nb\nc"</span> | grep a -A 1</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">--</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Grep这个命令真的很强大，接触到这个东西是因为最近有一次需要去后台搜索某些自己打的日志，但是整个项目上的日志输出太快太多，以至于很难抓取到，于是问了大神，才知道还有这么个东西…实际上只要 pm2 logs xxx | grep ‘match_pattern’ 就可以咯~~&lt;br&gt;
    
    </summary>
    
      <category term="效率" scheme="http://blog.locusland.xyz/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="常用命令" scheme="http://blog.locusland.xyz/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="http://blog.locusland.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令(2)</title>
    <link href="http://blog.locusland.xyz/2016/05/25/linux-command2/"/>
    <id>http://blog.locusland.xyz/2016/05/25/linux-command2/</id>
    <published>2016-05-25T12:40:33.000Z</published>
    <updated>2017-12-28T06:17:54.345Z</updated>
    
    <content type="html"><![CDATA[<p>整理一些Linux的常用命令：</p><ul><li><a href="https://github.com/jaywcjlove/linux-command" target="_blank" rel="noopener">这里有个工具</a><a id="more"></a></li></ul><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>===</p><p><strong>mkdir命令</strong> 用来创建目录。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir (选项)(参数)</span><br></pre></td></tr></table></figure><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Z：设置安全上下文，当使用SELinux时有效；</span><br><span class="line">-m&lt;目标属性&gt;或--mode&lt;目标属性&gt;建立目录的同时设置目录的权限；</span><br><span class="line">-p或--parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；</span><br><span class="line">--version 显示版本信息。</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>目录：指定要创建的目录列表，多个目录之间用空格隔开。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在目录<code>/usr/meng</code>下建立子目录test，并且只有文件主有读、写和执行权限，其他人无权访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -m 700 /usr/meng/test</span><br></pre></td></tr></table></figure><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>===<br><strong>touch命令</strong> 有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch(选项)(参数)</span><br></pre></td></tr></table></figure><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-a：或--time=atime或--time=access或--time=use  只更改存取时间；</span><br><span class="line">-c：或--no-create  不建立任何文件；</span><br><span class="line">-d：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间；</span><br><span class="line">-f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；</span><br><span class="line">-m：或--time=mtime或--time=modify  只更该变动时间；</span><br><span class="line">-r：&lt;参考文件或目录&gt;  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；</span><br><span class="line">-t：&lt;日期时间&gt;  使用指定的日期时间，而非现在的时间；</span><br><span class="line">--help：在线帮助；</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>文件：指定要设置时间属性的文件列表。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ex2</span><br></pre></td></tr></table></figure><p>在当前目录下建立一个空文件ex2，然后，利用<code>ls -l</code>命令可以发现文件ex2的大小为0，表示它是空文件。</p><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>===</p><p><strong>cp命令</strong> 用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp(选项)(参数)</span><br></pre></td></tr></table></figure><h3 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-a：此参数的效果和同时指定&quot;-dpR&quot;参数相同；</span><br><span class="line">-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；</span><br><span class="line">-f：强行复制文件或目录，不论目标文件或目录是否已存在；</span><br><span class="line">-i：覆盖既有文件之前先询问用户；</span><br><span class="line">-l：对源文件建立硬连接，而非复制文件；</span><br><span class="line">-p：保留源文件或目录的属性；</span><br><span class="line">-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；</span><br><span class="line">-s：对源文件建立符号连接，而非复制文件；</span><br><span class="line">-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；</span><br><span class="line">-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；</span><br><span class="line">-b：覆盖已存在的文件目标前将目标文件备份；</span><br><span class="line">-v：详细显示命令执行的操作。</span><br></pre></td></tr></table></figure><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul><li>源文件：制定源文件列表。默认情况下，cp命令不能复制目录，如果要复制目录，则必须使用<code>-R</code>选项；</li><li>目标文件：指定目标文件。当“源文件”为多个文件时，要求“目标文件”为指定的目录。</li></ul><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p><strong>rm</strong>  <strong>命令</strong> 可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。</p><p>注意：使用rm命令要格外小心。因为一旦删除了一个文件，就无法再恢复它。所以，在删除文件之前，最好再看一下文件的内容，确定是否真要删除。rm命令可以用-i选项，这个选项在使用文件扩展名字符删除多个文件时特别有用。使用这个选项，系统会要求你逐一确定是否要删除。这时，必须输入y并按Enter键，才能删除文件。如果仅按Enter键或其他字符，文件不会被删除。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm (选项)(参数)</span><br></pre></td></tr></table></figure><h3 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录；</span><br><span class="line">-f：强制删除文件或目录；</span><br><span class="line">-i：删除已有文件或目录之前先询问用户；</span><br><span class="line">-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；</span><br><span class="line">--preserve-root：不对根目录进行递归操作；</span><br><span class="line">-v：显示指令的详细执行过程。</span><br></pre></td></tr></table></figure><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><p>文件：指定被删除的文件列表，如果参数中含有目录，则必须加上<code>-r</code>或者<code>-R</code>选项。</p><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p><strong>mv命令</strong> 用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source表示源文件或目录，target表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。</p><p>mv命令可以用来将源文件移至一个目标文件中，或将一组文件移至一个目标目录中。源文件被移至目标文件有两种不同的结果：</p><ol><li>如果目标文件是到某一目录文件的路径，源文件会被移到此目录下，且文件名不变。</li><li>如果目标文件不是目录文件，则源文件名（只能有一个）会变为此目标文件名，并覆盖己存在的同名文件。如果源文件和目标文件在同一个目录下，mv的作用就是改文件名。当目标文件是目录文件时，源文件或目录参数可以有多个，则所有的源文件都会被移至目标文件中。所有移到该目录下的文件都将保留以前的文件名。</li></ol><p>注意事项：mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv(选项)(参数)</span><br></pre></td></tr></table></figure><h3 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--backup=&lt;备份模式&gt;：若需覆盖文件，则覆盖前先行备份；</span><br><span class="line">-b：当文件存在时，覆盖前，为其创建一个备份；</span><br><span class="line">-f：若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录；</span><br><span class="line">-i：交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。</span><br><span class="line">--strip-trailing-slashes：删除源文件中的斜杠“/”；</span><br><span class="line">-S&lt;后缀&gt;：为备份文件指定后缀，而不使用默认的后缀；</span><br><span class="line">--target-directory=&lt;目录&gt;：指定源文件要移动到目标目录；</span><br><span class="line">-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</span><br></pre></td></tr></table></figure><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><ul><li>源文件：源文件列表。</li><li>目标文件：如果“目标文件”是文件名则在移动文件的同时，将其改名为“目标文件”；如果“目标文件”是目录名则将源文件移动到“目标文件”下。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一些Linux的常用命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jaywcjlove/linux-command&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里有个工具&lt;/a&gt;
    
    </summary>
    
      <category term="效率" scheme="http://blog.locusland.xyz/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="常用命令" scheme="http://blog.locusland.xyz/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="http://blog.locusland.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://blog.locusland.xyz/2016/04/10/linux-command/"/>
    <id>http://blog.locusland.xyz/2016/04/10/linux-command/</id>
    <published>2016-04-10T10:12:38.000Z</published>
    <updated>2017-12-28T04:06:16.743Z</updated>
    
    <content type="html"><![CDATA[<p>整理一些Linux的常用命令：</p><ul><li><a href="https://github.com/jaywcjlove/linux-command" target="_blank" rel="noopener">这里有个工具</a><a id="more"></a></li></ul><h2 id="cd：切换用户当前工作目录"><a href="#cd：切换用户当前工作目录" class="headerlink" title="cd：切换用户当前工作目录"></a>cd：切换用户当前工作目录</h2><p>===</p><p><strong>cd命令</strong> 用来切换工作目录至dirname。 其中dirName表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的home directory(也就是刚login时所在的目录)。另外，<code>~</code>也表示为home directory的意思，<code>.</code>则是表示目前所在的目录，<code>..</code>则表示目前目录位置的上一层目录。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd (选项) (参数)</span><br></pre></td></tr></table></figure><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p 如果要切换到的目标目录是一个符号连接，直接切换到符号连接指向的目标目录</span><br><span class="line">-L 如果要切换的目标目录是一个符号的连接，直接切换到字符连接名代表的目录，而非符号连接所指向的目标目录。</span><br><span class="line">- 当仅实用&quot;-&quot;一个选项时，当前工作目录将被切换到环境变量&quot;OLDPWD&quot;所表示的目录。</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd    进入用户主目录；</span><br><span class="line">cd ~  进入用户主目录；</span><br><span class="line">cd -  返回进入此目录之前所在的目录；</span><br><span class="line">cd ..  返回上级目录（若当前目录为“/“，则执行完后还在“/&quot;；&quot;..&quot;为上级目录的意思）；</span><br><span class="line">cd ../..  返回上两级目录；</span><br><span class="line">cd !$  把上个命令的参数作为cd参数使用。</span><br></pre></td></tr></table></figure><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>===<br><strong>ls命令</strong> 用来显示目标列表，在Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。<br>ls的选项很多，这里列出一些常用的实例：</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls       <span class="comment"># 仅列出当前目录可见文件</span></span><br><span class="line">$ ls -l    <span class="comment"># 列出当前目录可见文件详细信息</span></span><br><span class="line">$ ls -hl   <span class="comment"># 列出详细信息并以可读大小显示文件大小</span></span><br><span class="line">$ ls -al   <span class="comment"># 列出所有文件（包括隐藏）的详细信息</span></span><br></pre></td></tr></table></figure><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>===</p><p><strong>cat命令</strong> 连接文件并打印到标准输出设备上，cat经常用来显示文件的内容，类似于下的type命令。</p><p>注意：当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用more等命令分屏显示。为了控制滚屏，可以按Ctrl+S键，停止滚屏；按Ctrl+Q键可以恢复滚屏。按Ctrl+C（中断）键可以终止该命令的执行，并且返回Shell提示符状态。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat(选项)(参数)</span><br></pre></td></tr></table></figure><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-n或-number：有1开始对所有输出的行数编号；</span><br><span class="line">-b或--number-nonblank：和-n相似，只不过对于空白行不编号；</span><br><span class="line">-s或--squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行；</span><br><span class="line">-A：显示不可打印字符，行尾显示“$”；</span><br><span class="line">-e：等价于&quot;-vE&quot;选项；</span><br><span class="line">-t：等价于&quot;-vT&quot;选项；</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>文件列表：指定要连接的文件列表。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>设ml和m2是当前目录下的两个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat m1 （在屏幕上显示文件ml的内容）</span><br><span class="line">cat m1 m2 （同时显示文件ml和m2的内容）</span><br><span class="line">cat m1 m2 &gt; file （将文件ml和m2合并后放入文件file中）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一些Linux的常用命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jaywcjlove/linux-command&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里有个工具&lt;/a&gt;
    
    </summary>
    
      <category term="效率" scheme="http://blog.locusland.xyz/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="常用命令" scheme="http://blog.locusland.xyz/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="http://blog.locusland.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>GIT常用命令</title>
    <link href="http://blog.locusland.xyz/2016/01/29/git-command/"/>
    <id>http://blog.locusland.xyz/2016/01/29/git-command/</id>
    <published>2016-01-29T13:15:43.000Z</published>
    <updated>2017-12-28T03:51:05.006Z</updated>
    
    <content type="html"><![CDATA[<p>最近刚刚入职，感觉自己还有好多不知道的东西，比如一些git的命令啊，Linux、Vim的命令啊。。。在这里整理一些git常用命令。大多是参考以下链接</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰git教程</a></li><li><a href="https://backlog.com/git-tutorial/cn/" target="_blank" rel="noopener">猴子都能懂的git入门</a><a id="more"></a></li></ul><h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>git clone <url><br>url为远程仓库地址，可以使用ssh，也可以用https链接。</url></p><h3 id="配置与别名alias"><a href="#配置与别名alias" class="headerlink" title="配置与别名alias"></a>配置与别名alias</h3><p>配置你的账号和邮箱，这些出现在每次的commit信息之中。当然这个信息可以通过.git文件夹内的config文件修改。</p><p>git config –global user.name<br>git config –global user.email<br>使用–global选项，配置的信息是放在用户主目录上的。如果想在自己的项目里面使用单独的配置账号邮箱，可以不加这个选项，这个时候的配置信息是放在.git/config里面的。</p><p>git config –list<br>使用–list参数可以看到所有的配置信息，可能会看到重复的变量名，那就说明它们来自不同的配置文件，不过最终 Git 实际采用的是最后一个。</p><p>同时配置的时候可以为一些常用的命令命别名，这样可以提高工作效率，例如</p><p>git config –global alias.co checkout<br>git config –global alias.br branch<br>git config –global alias.ci commit<br>git config –global alias.st status<br>这样我们想切换分支的时候只需要使用 git co即可。</p><h3 id="对比diff"><a href="#对比diff" class="headerlink" title="对比diff"></a>对比diff</h3><p>对未暂存的文件使用git diff命令能查看工作区这次修改的文件和上次提交的文件之间的区别，使用git status命令是查看具体有哪些文件有改动，在使用git status之后推荐使用git diff来查看具体的改动是什么。</p><p>注意这里 git diff是查看未暂存的文件和上次提交的区别，如果是查看已经暂存的文件和上次提交的文件的区别使用 git diff –cached。</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>移除文件主要使用的有两个命令rm,git rm。移除文件主要是从暂存区移除文件，然后提交，这时候可以使用git rm命令,然后再提交，也可以使用rm命令，然后再git add,git commit。</p><p>这两个命令最主要的区别就是使用rm仅仅是删除工作区域的文件，需要再使用git add命令，而git rm相当于删除暂存区的文件，可以一步做完。</p><p>如果在删除之前修改过并且放在暂存区之后就需要使用强制删除 -f 选项。还有一种情况是有时候我们只希望删除暂存区的一些不起作用的文件但是希望在工作区保留这些文件，可以使用git rm –cached命令。</p><h3 id="修改前一次提交信息"><a href="#修改前一次提交信息" class="headerlink" title="修改前一次提交信息"></a>修改前一次提交信息</h3><p>如果在提交的时候发现自己的commit的信息写错了，你想修改这一次提交的信息，就可以使用git commit – amend命令。</p><p>这个命令主要是用来修改最后一次提交，使用之后会出现 git 默认的文本编辑器，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才失误的提交。</p><p>如果在上一次的提交中发现还有一部分信息需要一起提交，也可以先git add上忘记的文件，然后使用git commit – amend命令，成为一次提交。</p><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>如果自己在使用git add添加文件到暂存区的时候，一不小心将两个文件添加了，或者不小心使用了– all参数，可是自己只想添加一个文件，这个时候如果想撤销之前的操作，就可以使用git reset HEAD <file>命令，这样这个文件就会变成未暂存的状态。</file></p><p>这个命令还有一个很强大的地方，就是可以回退版本，同时对于一个文件自己可以修改无数次，每次修改提交之后就会有一个commit 的 id，这个 id 是一个SHA1计算出来的一个非常大的数字，每个 id 都会是唯一的。</p><p>可以使用git log查看每个 commit 的 id，也可以使用git reflog，这个命令记录了每一次提交，如果自己想退回到某个版本去，可以使用git reset –hard HEAD^，在 git 中用 HEAD 表示当前版本， HEAD^表示上一个版本，如果想退回到前几十个版本之前，可以直接使用git reset –hard commitID就可以直接将HEAD指针指向那个版本。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>如果自己将工作区的某个文件改动完之后还未添加到暂存区发现之前的改动是完全没有必要的，这个时候也有一个命令可以撤销之前的修改，就是git checkout – file。</p><p>这个命令只有自己真的觉得自己的修改是完全没有必要的情况下再使用，因为这个命令会将之前版本的复制过来重写整个文件，如果觉得自己当前的修改是想保留下来可以提交之后选择回退版本。</p><p>如果自己的文件在改动之后已经添加到暂存区了，这个时候可以使用git reset HEAD <file>命令，使文件变成未暂存的状态，然后使用 checkout 即可。</file></p><p>如果已经提交了，可以选择版本回退到自己想要的版本。</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>在本地建了一个仓库之后如果需要关联到某个远程仓库进行文件的上传下拉等操作，需要先使用git remote add <name> <url>将远程的仓库关联到本地仓库，这里的 name 是自己为这个仓库取得名字，url是远程仓库的地址。</url></name></p><p>可以使用git remote -v来查看自己的仓库关联了哪些远程仓库，关联到远程仓库之后可以使用git fetch <remote-name>将远程分支上面的数据抓取到本地。</remote-name></p><p>之后可以使用git branch -a查看自己的分支并可以使用git checkout <branch-name>切换到自己新抓取的那个分支上面看看都下拉了什么，也可以使用git merge合并分支。</branch-name></p><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>git fetch 用于将远程主机版本库的更新取回本地。<br>git fetch &lt;远程主机名&gt;命令将某个远程主机的更新，全部取回本地。。</p><p>注意，fetch只会拉取数据到本地，但不会自动合并到当前工作分支。<br>默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。<br>git fetch &lt;远程主机名&gt; &lt;分支名&gt;<br>当然这个命令可以再加一个本地分支：<br>git fetch &lt;远程主机名&gt; &lt;分支名&gt;:&lt;本地分支名&gt;<br>比如： git fetch origin remotebranch: newBrach<br>此命令可以拉取远程的 remotebranch取回到本地的newBrach分支（如果没有会自动建立）。<br>取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建/切换到一个新的分支。<br>git checkout -b newBrach origin/remotebranch</p><h3 id="pull-amp-amp-push"><a href="#pull-amp-amp-push" class="headerlink" title="pull &amp;&amp; push"></a>pull &amp;&amp; push</h3><p>git pull，这个命令自动抓取数据下来，会将远端分支自动合并到本地仓库中当前分支。相当于fetch + merge。</p><p>说完拉取数据之后，还有一个命令git push [remote-name] [branch-name]可以将本地的数据推到远程仓库上面，如果在推数据前，已经有其他人推送了若干更新，那这个 push 就会被拒绝。必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。</p><p>对远程仓库如果想更名可以使用git remote rename <name> <anothername>命令，如果想删除，可以使用git remote rm <name>。</name></anothername></name></p><p>只是一些简单的整理，最后贴一张图：<br><img src="http://files.jb51.net/file_images/article/201409/git_big_jb51.jpg" alt="git命令"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刚刚入职，感觉自己还有好多不知道的东西，比如一些git的命令啊，Linux、Vim的命令啊。。。在这里整理一些git常用命令。大多是参考以下链接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;廖雪峰git教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://backlog.com/git-tutorial/cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;猴子都能懂的git入门&lt;/a&gt;
    
    </summary>
    
      <category term="效率" scheme="http://blog.locusland.xyz/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="git" scheme="http://blog.locusland.xyz/tags/git/"/>
    
      <category term="常用命令" scheme="http://blog.locusland.xyz/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>一个目前的to-do-list</title>
    <link href="http://blog.locusland.xyz/2015/11/10/todolist/"/>
    <id>http://blog.locusland.xyz/2015/11/10/todolist/</id>
    <published>2015-11-10T13:42:28.000Z</published>
    <updated>2017-12-25T03:37:26.162Z</updated>
    
    <content type="html"><![CDATA[<p>自十一假期回来就进入了疯狂的笔试面试阶段，到11月初终于工作尘埃落定。前一阵子也是写了个传说中的励志的故事<a href="http://mp.weixin.qq.com/s?__biz=MzI5MjA5MDQzNA==&amp;mid=400211500&amp;idx=1&amp;sn=881f3ce8213571ac223db7c250cd35b9#rd" target="_blank" rel="noopener">链接戳我</a>，从3月接触前端走到现在真的是不容易，好在没有放弃。不过这段时间一直忙着找工作的事情也是好久没有去搞一搞自己喜欢的东西了，确实前端这里还有好多东西要学，于是先来搞一个TODOlist：<br><a id="more"></a></p><ul><li><a href="http://www.phperz.com/article/15/0523/129259.html" target="_blank" rel="noopener">reactJS</a></li><li><a href="http://docs.reactjs-china.com/react/docs/why-react-zh-CN.html" target="_blank" rel="noopener">为什么使用react</a></li><li><a href="https://www.codecademy.com/en/learn/learn-angularjs?utm_campaign=2015-06-10-learn-angularjs-announce&amp;utm_source=email" target="_blank" rel="noopener">angularJS</a></li><li><a href="http://amazeui.org/getting-started?utm_source=baidu&amp;utm_medium=cpc&amp;utm_campaign=Download" target="_blank" rel="noopener">amazeUI</a></li><li><a href="http://coffee-script.org/" target="_blank" rel="noopener">coffee script</a></li><li><a href="http://www.1024i.com/demo/less/" target="_blank" rel="noopener">less</a></li><li><a href="http://www.w3cplus.com/sassguide/" target="_blank" rel="noopener">sass</a></li><li><a href="http://www.zhangxinxu.com/jq/stylus/" target="_blank" rel="noopener">stylus</a></li><li><a href="http://www.gulpjs.com.cn/docs/getting-started/" target="_blank" rel="noopener">gulp</a></li><li><a href="http://www.gruntjs.net/" target="_blank" rel="noopener">grunt</a><br>好吧先这么多，总之从一个菜鸟成长起来一定会有些辛苦的，要加油啦！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自十一假期回来就进入了疯狂的笔试面试阶段，到11月初终于工作尘埃落定。前一阵子也是写了个传说中的励志的故事&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MjA5MDQzNA==&amp;amp;mid=400211500&amp;amp;idx=1&amp;amp;sn=881f3ce8213571ac223db7c250cd35b9#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接戳我&lt;/a&gt;，从3月接触前端走到现在真的是不容易，好在没有放弃。不过这段时间一直忙着找工作的事情也是好久没有去搞一搞自己喜欢的东西了，确实前端这里还有好多东西要学，于是先来搞一个TODOlist：&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://blog.locusland.xyz/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="web前端" scheme="http://blog.locusland.xyz/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础面试问题总结</title>
    <link href="http://blog.locusland.xyz/2015/09/20/it-interview/"/>
    <id>http://blog.locusland.xyz/2015/09/20/it-interview/</id>
    <published>2015-09-20T11:12:04.000Z</published>
    <updated>2017-12-25T03:37:26.152Z</updated>
    
    <content type="html"><![CDATA[<p>这几天奔波于各路招聘会以及笔试，我一个应聘前端的各种考计算机基础题和C，感觉整个人都不好了，笔试过后还有面试，导师那边还得偷着跑出去，人生真是如此艰难。。。吐槽完毕开始总结(毕竟我是个前端，还是主要总结一下网络这方面的)：</p><a id="more"></a><h1 id="IT-interview"><a href="#IT-interview" class="headerlink" title="IT-interview"></a>IT-interview</h1><p>为了面试，为了面试，为了面试，我决定回到考研那个年代：</p><h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="$算法与数据结构"></a>$算法与数据结构</h2><p>这个我是真不太懂，反正都是网上摘的，就直接上链接了：</p><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><a href="http://blog.csdn.net/whuslei/article/details/6442755" target="_blank" rel="noopener">常见排序算法小结</a></p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p><a href="http://blog.csdn.net/luckyxiaoqiang/article/details/7518888/" target="_blank" rel="noopener">轻松搞定面试中的二叉树题目</a></p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="$计算机网络"></a>$计算机网络</h2><h3 id="http-https协议详解"><a href="#http-https协议详解" class="headerlink" title="http/https协议详解"></a>http/https协议详解</h3><p>[http协议]（<a href="http://blog.csdn.net/hguisu/article/details/8680808" target="_blank" rel="noopener">http://blog.csdn.net/hguisu/article/details/8680808</a>)</p><h3 id="post与get方法的区别"><a href="#post与get方法的区别" class="headerlink" title="post与get方法的区别"></a>post与get方法的区别</h3><p>1.GET是从服务器上获取数据，POST是向服务器传送数据，在FORM（表单）中，Method默认为”GET”。<br>2.GET 是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。POST是通过HTTP POST机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。<br>3.对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据。<br>4.GET传送的数据量较小，不能大于2KB（这主要是因为受URL长度限制）。POST传送的数据量较大，一般被默认为不受限制。但理论上，限制取决于服务器的处理能力。<br>5.GET 安全性较低，POST安全性较高。因为GET在传输过程，数据被放在请求的URL中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记 录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一 同显示在用户面前。POST的所有操作对用户来说都是不可见的。</p><p><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="noopener">然而对于网上流传的说法这些区别有些并不准确</a><br><a href="http://blog.csdn.net/gideal_wang/article/details/4316691" target="_blank" rel="noopener">这个文章还不错</a></p><h3 id="osi七层，tcp-ip四层。区别？"><a href="#osi七层，tcp-ip四层。区别？" class="headerlink" title="osi七层，tcp/ip四层。区别？"></a>osi七层，tcp/ip四层。区别？</h3><p>TCP/IP:<br>数据链路层：ARP,RARP<br>网络层： IP,ICMP,IGMP<br>传输层：TCP ,UDP,UGP<br>应用层：Telnet,FTP,SMTP,SNMP.</p><p>OSI:<br>物理层：EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45, Ethernet, 802.3, 802.5, FDDI, NRZI, NRZ, B8ZS<br>数据链路层：Frame Relay, HDLC, PPP, IEEE 802.3/802.2, FDDI, ATM,  IEEE 802.5/802.2<br>网络层：IP，IPX，AppleTalk DDP<br>传输层：TCP，UDP，SPX<br>会话层：RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP<br>表示层:TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML<br>应用层：FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP</p><p>应用层<br>1.主要功能 ：用户接口、应用程序<br>application 2.典型设备：网关<br>3.典型协议、标准和应用：TELNET, FTP, HTTP</p><p>表示层<br>1.主要功能 ：数据的表示、压缩和加密<br>presentation2.典型设备：网关<br>3.典型协议、标准和应用：ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG</p><p>会话层<br>1.主要功能 ：会话的建立和结束<br>session2.典型设备：网关<br>3.典型协议、标准和应用：RPC、SQL、NFS 、X WINDOWS、ASP</p><p>传输层<br>1.主要功能 ：端到端控制<br>transport 2.典型设备：网关<br>3.典型协议、标准和应用：TCP、UDP、SPX</p><p>网络层<br>1.主要功能 ：路由，寻址<br>network2.典型设备：路由器<br>3.典型协议、标准和应用：IP、IPX、APPLETALK、ICMP</p><p>数据链路层<br>1.主要功能 ：保证误差错的数据链路<br>data link 2.典型设备：交换机、网桥、网卡<br>3.典型协议、标准和应用：802.2、802.3ATM、HDLC、FRAME RELAY</p><p>物理层<br>1.主要功能 ：传输比特流<br>physical2.典型设备：集线器、中继器<br>3.典型协议、标准和应用：V.35、EIA/TIA-232</p><p>TCP/IP网络协议<br>TCP/IP(Transmission Control Protocol/Internet Protocol，传输控制协议/网间网协议)是目前世界上应用最为广泛的协议，它的流行与Internet的迅猛发展密切相关—TCP/IP最初是为互联网的原型ARPANET所设计的，目的是提供一整套方便实用、能应用于多种网络上的协议，事实证明TCP/IP做到了这一点，它使网络互联变得容易起来，并且使越来越多的网络加入其中，成为Internet的事实标准。</p><ul><li><p>应用层—应用层是所有用户所面向的应用程序的统称。ICP/IP协议族在这一层面有着很多协议来支持不同的应用，许多大家所熟悉的基于Internet的应用的实现就离不开这些协议。如我们进行万维网（WWW）访问用到了HTTP协议、文件传输用FTP协议、电子邮件发送用SMTP、域名的解析用DNS协议、远程登录用Telnet协议等等，都是属于TCP/IP应用层的；就用户而言，看到的是由一个个软件所构筑的大多为图形化的操作界面，而实际后台运行的便是上述协议。</p></li><li><p>传输层—这一层的的功能主要是提供应用程序间的通信，TCP/IP协议族在这一层的协议有TCP和UDP。</p></li><li><p>网络层—是TCP/IP协议族中非常关键的一层，主要定义了IP地址格式，从而能够使得不同应用类型的数据在Internet上通畅地传输，IP协议就是一个网络层协议。</p></li><li><p>网络接口层—这是TCP/IP软件的最低层，负责接收IP数据包并通过网络发送之，或者从网络上接收物理帧，抽出IP数据报，交给IP层。</p></li></ul><p>OSI与TCP/IP的比较：<br>分层结构<br>OSI参考模型与TCP/IP协议都采用了分层结构，都是基于独立的协议栈的概念。OSI参考模型有7层，而TCP/IP协议只有4层，即TCP/IP协议没有了表示层和会话层，并且把数据链路层和物理层合并为网络接口层。不过，二者的分层之间有一定的对应关系</p><p>标准的特色<br>OSI参考模型的标准最早是由ISO和CCITT（ITU的前身）制定的，有浓厚的通信背景，因此也打上了深厚的通信系统的特色，比如对服务质量（QoS）、差错率的保证，只考虑了面向连接的服务。并且是先定义一套功能完整的构架，再根据该构架来发展相应的协议与系统。</p><p>TCP/IP协议产生于对Internet网络的研究与实践中，是应实际需求而产生的，再由IAB、IETF等组织标准化，而并不是之前定义一个严谨的框架。而且TCP/IP最早是在UNIX系统中实现的，考虑了计算机网络的特点，比较适合计算机实现和使用。</p><p>连接服务<br>OSI的网络层基本与TCP/IP的网际层对应，二者的功能基本相似，但是寻址方式有较大的区别。</p><p>OSI的地址空间为不固定的可变长，由选定的地址命名方式决定，最长可达160byte，可以容纳非常大的网络，因而具有较大的成长空间。根据OSI的规定，网络上每个系统至多可以有256个通信地址。</p><p>TCP/IP网络的地址空间为固定的4byte（在目前常用的IPV4中是这样，在IPV6中将扩展到16byte）。网络上的每一个系统至少有一个唯一的地址与之对应。</p><p>传输服务<br>OSI与TCP/IP的传输层都对不同的业务采取不同的传输策略。OSI定义了五个不同层次的服务：TP1，TP2，TP3，TP4，TP5。TCP/IP定义了TCP和UPD两种协议，分别具有面向连接和面向无连接的性质。其中TCP与OSI中的TP4，UDP与OSI中的TP0在构架和功能上大体相同，只是内部细节有一些差异。</p><p>应用范围<br>OSI由于体系比较复杂，而且设计先于实现，有许多设计过于理想，不太方便计算机软件实现，因而完全实现OSI参考模型的系统并不多，应用的范围有限。而TCP/IP协议最早在计算机系统中实现，在UNIX、Windows平台中都有稳定的实现，并且提供了简单方便的编程接口（API），可以在其上开发出丰富的应用程序，因此得到了广泛的应用。TCP/IP协议已成为目前网际互联事实上的国际标准和工业标准。</p><h3 id="什么是TCP-UDP协议，IP协议"><a href="#什么是TCP-UDP协议，IP协议" class="headerlink" title="什么是TCP/UDP协议，IP协议"></a>什么是TCP/UDP协议，IP协议</h3><p>1．TCP/UDP协议<br>TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。其中TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；而UDP则不为IP提供可靠性、流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。TCP支持的应用协议主要有：Telnet、FTP、SMTP等；UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。</p><ol><li>IP协议的定义、IP地址的分类及特点</li></ol><p>什么是IP协议，IP地址如何表示，分为几类，各有什么特点？<br>为了便于寻址和层次化地构造网络，IP地址被分为A、B、C、D、E五类，商业应用中只用到A、B、C三类。</p><p>IP协议(Internet Protocol)又称互联网协议，是支持网间互连的数据报协议，它与TCP协议（传输控制协议）一起构成了TCP/IP协议族的核心。它提供网间连接的完善功能， 包括IP数据报规定互连网络范围内的IP地址格式。</p><p>Internet 上，为了实现连接到互联网上的结点之间的通信，必须为每个结点（入网的计算机）分配一个地址，并且应当保证这个地址是全网唯一的，这便是IP地址。</p><p>目前的IP地址（IPv4：IP第4版本）由32个二进制位表示，每8位二进制数为一个整数，中间由小数点间隔，如159.226.41.98，整个IP地址空间有4组8位二进制数，由表示主机所在的网络的地址（类似部队的编号）以及主机在该网络中的标识（如同士兵在该部队的编号）共同组成。</p><p>为了便于寻址和层次化的构造网络，IP地址被分为A、B、C、D、E五类，商业应用中只用到A、B、C三类。</p><ul><li><p>A类地址：A类地址的网络标识由第一组8位二进制数表示，网络中的主机标识占3组8位二进制数，A类地址的特点是网络标识的第一位二进制数取值必须为 “0”。不难算出，A类地址允许有126个网段，每个网络大约允许有1670万台主机，通常分配给拥有大量主机的网络（如主干网）。</p></li><li><p>B类地址：B类地址的网络标识由前两组8位二进制数表示，网络中的主机标识占两组8位二进制数，B类地址的特点是网络标识的前两位二进制数取值必须为“10”。B类地址允许有16384个网段，每个网络允许有65533台主机，适用于结点比较多的网络（如区域网）。</p></li><li><p>C类地址：C类地址的网络标识由前3组8位二进制数表示，网络中主机标识占1组8位二进制数，C类地址的特点是网络标识的前3位二进制数取值必须为“110”。具有C类地址的网络允许有254台主机，适用于结点比较少的网络（如校园网）。</p></li></ul><p>为了便于记忆，通常习惯采用4个十进制数来表示一个IP地址，十进制数之间采用句点“.”予以分隔。这种IP地址的表示方法也被称为点分十进制法。如以这种方式表示，A类网络的IP地址范围为1.0.0.1－127.255.255.254；B类网络的IP地址范围为：128.1.0.1－191.255.255.254；C类网络的IP地址范围为：192.0.1.1－223.255.255.254。</p><p>由于网络地址紧张、主机地址相对过剩，采取子网掩码的方式来指定网段号。</p><p>TCP/IP协议与低层的数据链路层和物理层无关，这也是TCP/IP的重要特点。正因为如此 ，它能广泛地支持由低两层协议构成的物理网络结构。目前已使用TCP/IP连接成洲际网、全国网与跨地区网。</p><h3 id="TCP连接三次握手、断开四次挥手的过程"><a href="#TCP连接三次握手、断开四次挥手的过程" class="headerlink" title="TCP连接三次握手、断开四次挥手的过程"></a>TCP连接三次握手、断开四次挥手的过程</h3><p>三次握手：客户端发起请求（序列号）-服务器回应ack并给出自己的序列号-客户端回应ack。<br>断开四次挥手：一端发起断开（FIN），另外一端回应ack；这样一端的写就关闭了；另外一端发起断开请求（FIN），本端回应ack。这样双方都关闭了连接。因为一端关闭了写，但是另外一端可能还有数据要发送，所以两端可能不同时关掉连接，就出现了4次挥手的过程。</p><p>还有一些web综合的问题，在另一个前端面试总结中···</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="$操作系统"></a>$操作系统</h2><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>进程是分配资源的基本单位（CPU、内存等），有独立的地址空间。线程是进程中的一个实体，共享进程的地址空间，是轻量级的进程，是CPU调度和分配的基本单位，但是各个线程拥有自己的栈空间。 使用多线程编程的好处：（1）单线程遇到阻塞，会卡死，影响交互；（2）发挥多核CPU的计算能力；（3）简化程序结构，使程序便于维护；（4）与进程相比，线程的创建和切换开销更小。<br>参考<a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程</a></p><h3 id="阻塞、非阻塞，同步、异步的区别"><a href="#阻塞、非阻塞，同步、异步的区别" class="headerlink" title="阻塞、非阻塞，同步、异步的区别"></a>阻塞、非阻塞，同步、异步的区别</h3><p><a href="http://blog.csdn.net/klarclm/article/details/8828486" target="_blank" rel="noopener">http://blog.csdn.net/klarclm/article/details/8828486</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天奔波于各路招聘会以及笔试，我一个应聘前端的各种考计算机基础题和C，感觉整个人都不好了，笔试过后还有面试，导师那边还得偷着跑出去，人生真是如此艰难。。。吐槽完毕开始总结(毕竟我是个前端，还是主要总结一下网络这方面的)：&lt;/p&gt;
    
    </summary>
    
      <category term="整理" scheme="http://blog.locusland.xyz/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="面试" scheme="http://blog.locusland.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://blog.locusland.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://blog.locusland.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="计算机网络" scheme="http://blog.locusland.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="操作系统" scheme="http://blog.locusland.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
