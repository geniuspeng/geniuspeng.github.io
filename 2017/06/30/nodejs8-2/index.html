<!DOCTYPE html><html class="fixed-top" lang="zh-cn"><head><link rel=manifest href=/manifest.json><meta charset="UTF-8"><meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Blog PWA"><link rel="apple-touch-icon" href="images/icons/icon-152x152.png"><meta name="msapplication-TileImage" content="images/icons/icon-144x144.png"><meta name="msapplication-TileColor" content="#2F3BA2"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?50461fe435ccda0fde8858f08eae2050";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><title>NodeJS 8新特性(2) [ 牧羊少年的个人博客 ]</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/media.css"><link rel="icon" href="/favicon.ico"></head><body><div id="menu-outer"><dev class="bd-special-shadow" id="specialShadow" style="transform: scaleY(1);"></dev><nav class="container" id="menu-inner"><div class="navbar-brand"><a class="navbar-item" href="#"><img src="/images/avatar.png" alt="头像"><span>牧羊少年</span></a><div class="navbar-burger" id="navbarBurger"><span></span><span></span><span></span></div></div><div class="navbar-menu" id="navMenuIndex"><div class="navbar-start"><div class="navbar-item"><a class="navbar-link" href="/">首页</a></div><div class="navbar-item"><a class="navbar-link active" href="/archives">归档</a></div><div class="navbar-item"><a class="navbar-link" href="/about">关于</a></div></div></div></nav></div><div id="content-outer"><div class="content" id="content-inner"><div class="post-wrap"><article class="post" id="post"><div class="post-header"><h1 class="post-title">NodeJS 8新特性(2)</h1></div><div class="post-meta"><div class="tags"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/">Node</a></li></ul></div><time datetime="2017-06-30T08:22:15.000Z">2017-06-30</time></div><section class="post-content"><p>继续整理，这次写的都是我觉得在新特性里面比较实用的，最有用的应该算是ASYNC_HOOKS和promisify了。<br><a id="more"></a></p>
<h2 id="ASYNC-HOOKS"><a href="#ASYNC-HOOKS" class="headerlink" title="ASYNC_HOOKS"></a>ASYNC_HOOKS</h2><p><small>async_hooks模块提供了一个API来回溯跟踪Node.js应用创建的异步资源的生命周期。API预览如下：</small></p>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async_hooks = <span class="built_in">require</span>(<span class="string">'async_hooks'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前异步资源唯一id</span></span><br><span class="line"><span class="keyword">const</span> cid = async_hooks.currentId();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发当前异步行为的异步资源id</span></span><br><span class="line"><span class="keyword">const</span> tid = async_hooks.triggerId();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建异步勾子监听</span></span><br><span class="line"><span class="keyword">const</span> asyncHook = async_hooks.createHook(&#123; init, before, after, destroy &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始监听</span></span><br><span class="line">asyncHook.enable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束监听</span></span><br><span class="line">asyncHook.disable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源对象初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">asyncId, type, triggerId, resource</span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调开始之前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">before</span>(<span class="params">asyncId</span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调完成之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">asyncId</span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AsyncWrap实例销毁.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params">asyncId</span>) </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>Note:<br>init()异步资源生成时执行，用于初始化，这个函数执行的时候异步资源可能还没有完全生成，但是一定会生成一个唯一的asyncID，before()异步回调开始之前执行，它可能被执行0-N次(e.g. TCPWrap)，取决于这个异步资源执行了多少次回调，after()在异步回调finish的时候执行，destroy is called when an AsyncWrap instance is destroyed.</p>
<p>init(asyncId, type, triggerId, resource)</p>
<ul>
<li>asyncId &lt;number&gt; 当前异步资源的唯一标识</li>
<li>type &lt;string&gt; 异步资源的类型</li>
<li>triggerId &lt;number&gt; 触发当前异步行为的异步资源的asyncId</li>
<li>resource &lt;Object&gt; 异步资源对象，将在destory时释放，但是并不意味着每个实例都要在destroy之前执行before和after<br>Note:<br>asyncId当前异步资源的唯一标识，type异步资源的类型，triggerId触发当前异步行为的异步资源的asyncId，resource异步资源对象，将在destory时释放，但是并不意味着每个实例都要在destroy之前执行before和after。</li>
</ul>
<p>type:</p>
<p>FSEVENTWRAP, FSREQWRAP, GETADDRINFOREQWRAP, GETNAMEINFOREQWRAP, HTTPPARSER,<br>JSSTREAM, PIPECONNECTWRAP, PIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,<br>SIGNALWRAP, STATWATCHER, TCPCONNECTWRAP, TCPWRAP, TIMERWRAP, TTYWRAP,<br>UDPSENDWRAP, UDPWRAP, WRITEWRAP, ZLIB, SSLCONNECTION, PBKDF2REQUEST,<br>RANDOMBYTESREQUEST, TLSWRAP</p>
<p>trigger_id:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async_hooks.createHook(&#123;</span><br><span class="line">  init(asyncId, type, triggerId) &#123;</span><br><span class="line">    <span class="keyword">const</span> cId = async_hooks.currentId();</span><br><span class="line">    fs.writeSync(</span><br><span class="line">      <span class="number">1</span>, <span class="string">`<span class="subst">$&#123;type&#125;</span>(<span class="subst">$&#123;asyncId&#125;</span>): trigger: <span class="subst">$&#123;triggerId&#125;</span> scope: <span class="subst">$&#123;cId&#125;</span>\n`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).enable();</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'net'</span>).createServer(<span class="function">(<span class="params">conn</span>) =&gt;</span> &#123;&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
<h2 id="UTIL"><a href="#UTIL" class="headerlink" title="UTIL"></a>UTIL</h2><div style="text-align: left;">util.inspect添加[Array]符号, 同时可以展示symbol key</div>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; const obj = util.inspect(&#123;<span class="string">'a'</span>: &#123;<span class="string">'b'</span>: [<span class="string">'c'</span>]&#125;&#125;, <span class="literal">false</span>, 1)</span><br><span class="line">&gt; obj</span><br><span class="line"><span class="string">'&#123; a: &#123; b: [Object] &#125; &#125;'</span></span><br><span class="line">&gt; assert.strictEqual(obj, <span class="string">'&#123; a: &#123; b: [Array] &#125; &#125;'</span>)</span><br><span class="line">AssertionError: <span class="string">'&#123; a: &#123; b: [Object] &#125; &#125;'</span> === <span class="string">'&#123; a: &#123; b: [Array] &#125; &#125;'</span></span><br><span class="line"></span><br><span class="line">// 8.0.0</span><br><span class="line">&gt; obj</span><br><span class="line"><span class="string">'&#123; a: &#123; b: [Array] &#125; &#125;'</span></span><br><span class="line">&gt; assert.strictEqual(obj, <span class="string">'&#123; a: &#123; b: [Array] &#125; &#125;'</span>)</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>
<div style="text-align: left;">util.format新增整形——%i，浮点型——%f</div>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; util.format(<span class="string">'%d'</span>, 42.2)</span><br><span class="line"><span class="string">'42.2'</span></span><br><span class="line">&gt; util.format(<span class="string">'%i'</span>, 42.2)</span><br><span class="line"><span class="string">'%i 42.2'</span></span><br><span class="line">&gt; util.format(<span class="string">'%f'</span>, 42.2)</span><br><span class="line"><span class="string">'%f 42.2'</span></span><br><span class="line"></span><br><span class="line">// 8.0.0</span><br><span class="line">&gt; util.format(<span class="string">'%d'</span>, 42.2)</span><br><span class="line"><span class="string">'42.2'</span></span><br><span class="line">&gt; util.format(<span class="string">'%i'</span>, 42.2)</span><br><span class="line"><span class="string">'42'</span></span><br><span class="line">&gt; util.format(<span class="string">'%f'</span>, 42.2)</span><br><span class="line"><span class="string">'42.2'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>添加 promisify()</li>
</ul>
<p>Node.js 一直以来的关键设计就是把用户关在一个“异步编程的监狱”里，以换取非阻塞 I/O 的高性能，让用户轻易开发出高度可扩展的网络服务器。这从 Node.js 的 API 设计上就可见一斑，很多API——如 fs.open(path, flags[, mode], callback)——要求用户必须把该操作执行成功后的逻辑放在最后参数里，作为函数传递进去；而 fs.open 本身是立即返回的，用户不能把依赖于 fs.open 结果的逻辑与 fs.open 本身线性地串联起来。为了减轻异步编程的痛苦，几年间我们见证了数个解决方案的出现：从深度嵌套的回调金字塔，到带有长长的 then() 链条的 Promise 设计模式，再到 Generator 函数，到如今 Node.js 8 的 async/await 操作符。笔者认为，所有这些解决方案中，async/await 操作符是最接近命令式编程风格的，使用起来最为自然的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> writeFile = <span class="built_in">require</span>(<span class="string">'fs'</span>).writeFile;</span><br><span class="line"><span class="keyword">const</span> stat = <span class="built_in">require</span>(<span class="string">'fs'</span>).stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> writeFile(<span class="string">'a_new_file.txt'</span>, <span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">await</span> stat(<span class="string">'a_new_file.txt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result.size);</span><br></pre></td></tr></table></figure>
<p>例如我们想先创建一个文件，再读取、输出它的大小，只需三行代码,这简直是最简单的异步编程了！我们用自然、流畅的代码表达了线性业务逻辑，同时还得到了 Node.js 非阻塞 I/O 带来的高性能，简直是兼得了鱼和熊掌。<br>但别着急，这段代码不是立即就可以执行的，细心的读者肯定会问：例子中的 writeFile 和 stat 分别是什么？其实它们就是标准库的 fs.writeFile 和 fs.stat，但又不完全是。这是因为 async 和 await 本质上是对 Promise 设计模式的封装，一般情况下 await 的参数应是一个返回 Promise 对象的函数。而 fs.writeFile 和 fs.stat 这些标准库 API 没有返回值（返回 undefined），需要一个方法把他们包装成返回 Promise 对象的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> writeFile = util.promisify(fs.writeFile);</span><br><span class="line"><span class="keyword">const</span> stat = util.promisify(fs.stat);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> writeFile(<span class="string">'a_new_file.txt'</span>, <span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> stat(<span class="string">'a_new_file.txt'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result.size);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h2 id="WHATWG-URL"><a href="#WHATWG-URL" class="headerlink" title="WHATWG URL"></a>WHATWG URL</h2><p>nodejs现在完美支持标准URL对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> URL = url.URL;</span><br><span class="line"><span class="comment">// or const &#123; URL &#125; = require('url');</span></span><br><span class="line"><span class="keyword">const</span> myURL =</span><br><span class="line">  <span class="keyword">new</span> URL(<span class="string">'https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash'</span>);</span><br><span class="line">myURL;</span><br></pre></td></tr></table></figure>
<p><img src="/images/nodejs8/url.png" alt="url"></p>
<p>Note:url 模块提供了一些实用函数，用于 URL 处理与解析。 可以通过以下方式使用：const url = require(‘url’);<br>一个 URL 字符串是一个结构化的字符串，它包含多个有意义的组成部分。 当被解析时，会返回一个 URL 对象，它包含每个组成部分作为属性。</p>
<p>Class: URLSearchParams</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; URLSearchParams &#125; = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>urlSearchParams.get(name)</li>
<li>urlSearchParams.getAll(name)</li>
<li>urlSearchParams.set(name, value)</li>
<li>urlSearchParams.append(name, value)</li>
<li>urlSearchParams.delete(name)</li>
<li>urlSearchParams.entries()</li>
<li>urlSearchParams.forEach(fn[, thisArg])</li>
<li>urlSearchParams.has(name)</li>
<li>urlSearchParams.sort()<br>Note: 还有urlSearchParams.values()，urlSearchParams.toString()</li>
</ul>
<h2 id="INSPECTOR"><a href="#INSPECTOR" class="headerlink" title="INSPECTOR"></a>INSPECTOR</h2><p>命令行在 –inspector基础上，新增–inspector-brk，同时可以添加=[port]指定调试端口，默认9229，node –debug废弃</p>
<p>–debug-brk 通过这个参数，在开始调试的时候能够定位到代码的第一行。</p>
<p>新增inspector内置模块，支持程序化的debug。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inspector = <span class="built_in">require</span>(<span class="string">'inspector'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>inspector.open([port[, host[, wait]]])</li>
<li>inspector.close()</li>
<li>inspector.url()</li>
<li>Class: inspector.Session</li>
</ul>
<p>如果wait为true，将阻塞，直到客户端连接到检查端口。<br>If wait is true, will block until a client has connected to the inspect port and flow control has been passed to the debugger client.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inspector = <span class="built_in">require</span>(<span class="string">'inspector'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> session = <span class="keyword">new</span> inspector.Session();</span><br><span class="line">session.connect();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for inspector events</span></span><br><span class="line">session.on(<span class="string">'inspectorNotification'</span>, (message) =&gt; &#123; <span class="comment">/** ... **/</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send messages to the inspector</span></span><br><span class="line">session.post(message);</span><br><span class="line"></span><br><span class="line">session.disconnect();</span><br></pre></td></tr></table></figure>
<p>Session这个class支持监听inspector的一些相关事件，可以向v8的inspector后台发送或接收message</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://cloud.tencent.com/community/article/171211?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">npm5 新版功能特性解析及与 yarn 评测对比</a></li>
<li><a href="https://cnodejs.org/topic/59084a9cbbaf2f3f569be482" target="_blank" rel="noopener">V8 Ignition：JS 引擎与字节码的不解之缘</a></li>
<li><a href="https://v8project.blogspot.co.id/2017/04/v8-release-59.html" target="_blank" rel="noopener">https://v8project.blogspot.co.id/2017/04/v8-release-59.html</a></li>
<li><a href="http://gitbook.cn/m/mazi/article/593763494ec5fa29296acea0?readArticle=yes" target="_blank" rel="noopener">从暴力到 NAN 到 NAPI——Node.js 原生模块开发方式变迁</a></li>
<li><a href="http://huziketang.com/blog/posts/detail?postId=58ce8036a6d8a07e449fdd27" target="_blank" rel="noopener">WebAssembly</a></li>
<li><a href="https://nodejs.org/en/blog/release/v8.0.0" target="_blank" rel="noopener">Node8 changes</a></li>
</ul>
</section></article></div></div></div><div id="bottom-outer"><div id="bottom-inner"><span>Site construction by</span><span> 牧羊少年 </span><span>using</span><a href="http://hexo.io"><span>hexo blog framework</span></a><span>.</span></div></div><script>window.is_home = false</script><script src="/js/resLoader.js"></script><script src="/js/main.js"></script><script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1521690707039')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body></html>